{"meta":{"title":"灏絯喔","subtitle":"努力学习，艰苦奋斗","description":"好记性不如烂笔头","author":"haohaio","url":"https://haohaio.github.io"},"pages":[{"title":"为何建站 && 为何写作","date":"2018-12-12T04:12:12.000Z","updated":"2018-12-15T11:56:25.307Z","comments":false,"path":"about/index.html","permalink":"https://haohaio.github.io/about/index.html","excerpt":"","text":"为何建站这个网站主要是为了在学习的过程中记一下笔记，深化一下记忆。当然大家浏览本网站时，我相信大家也可以学到一点东西。 为何写作目前在我看来，写作还是个比较花时间的活儿。但是在写作的过程中，对自己各方面的提升还是蛮大的，所以我会尽量坚持下去。 作为内容站，持续输出高质量的内容是件不太容易的事情，本站的任何文章，你可任意转载，但请保留原文链接。"},{"title":"QA - 帮助中心","date":"2018-12-12T04:12:12.000Z","updated":"2018-12-15T11:59:51.436Z","comments":true,"path":"help/index.html","permalink":"https://haohaio.github.io/help/index.html","excerpt":"","text":"Q: 为什么博客有时候打开速度很慢，一直在加载呢？ A: 评论组件使用的Disqus等资源的服务器在墙外，你懂的…(不懂问搜狗)。不过不影响文章阅读。 暂时更新这些，需要什么本文底部留言…"},{"title":"嘉宾推荐","date":"2018-12-12T04:12:12.000Z","updated":"2018-12-15T14:49:20.094Z","comments":false,"path":"links/index.html","permalink":"https://haohaio.github.io/links/index.html","excerpt":"","text":"以下摘录有趣、有意义、有影响力、有正能量的博客、资源 此处不做网址导航，因此不接受以SEO为目的的友链。排序不分那啥… JS大法系 阮一峰博客闲情写手腾讯AlloyTeam 苹果派 王巍（喵神）的博客Objc.ioSwifter 娱乐圈 VIMCodeTank 公众号 没有链接，请直接关注微信公众号：涔汐(zhangcenxi99)、小道消息、MacTalk等等"},{"title":"标签云","date":"2017-02-04T07:37:12.000Z","updated":"2018-12-16T02:38:49.205Z","comments":true,"path":"tags/index.html","permalink":"https://haohaio.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"[JavaScript LeetCode]209. 长度最小的子数组","slug":"leetcode-minimum-size-subarray-sum","date":"2020-05-11T07:31:29.000Z","updated":"2020-05-11T08:14:57.547Z","comments":true,"path":"data-structure/leetcode-minimum-size-subarray-sum.html","link":"","permalink":"https://haohaio.github.io/data-structure/leetcode-minimum-size-subarray-sum.html","excerpt":"","text":"原题链接 滑动窗口第 4 题 示例： 输入: s = 7, nums = [2,3,1,2,4,3]输出: 2解释: 子数组 [4,3] 是该条件下的长度最小的连续子数组。 滑动窗口解法var minSubArrayLen = function (s, nums) &#123; let left = 0; let right = 0; let minLen = Number.MAX_SAFE_INTEGER; let sum = 0; while (right &lt; nums.length) &#123; sum += nums[right++]; while (sum &gt;= s) &#123; minLen = Math.min(minLen, right - left); sum -= nums[left++]; &#125; &#125; return minLen === Number.MAX_SAFE_INTEGER ? 0 : minLen;&#125;;","categories":[{"name":"数据结构","slug":"data-structure","permalink":"https://haohaio.github.io/categories/data-structure/"}],"tags":[{"name":"LeetCode","slug":"leetcode","permalink":"https://haohaio.github.io/tags/leetcode/"}]},{"title":"[JavaScript LeetCode]76. 最小覆盖子串","slug":"leetcode-minimum-window-substring","date":"2020-05-11T02:53:25.000Z","updated":"2020-05-11T07:08:59.756Z","comments":true,"path":"data-structure/leetcode-minimum-window-substring.html","link":"","permalink":"https://haohaio.github.io/data-structure/leetcode-minimum-window-substring.html","excerpt":"","text":"原题链接 滑动窗口第 3 题 给你一个字符串 S、一个字符串 T，请在字符串 S 里面找出：包含 T 所有字符的最小子串。 示例： 输入: S = &quot;ADOBECODEBANC&quot;, T = &quot;ABC&quot;输出: &quot;BANC&quot; 说明： 如果 S 中不存这样的子串，则返回空字符串 “”。 如果 S 中存在这样的子串，我们保证它是唯一的答案。 滑动窗口解法解题思路与 30 题基本一致。 var minWindow = function (s, t) &#123; let left = 0; let right = 0; let needs = &#123;&#125;; let windows = &#123;&#125;; let match = 0; let start = 0; let minLen = Number.MAX_SAFE_INTEGER; for (let c of t) &#123; needs[c] ? needs[c]++ : (needs[c] = 1); &#125; let needsKeyLen = Object.keys(needs).length; while (right &lt; s.length) &#123; let c1 = s[right]; if (needs[c1]) &#123; windows[c1] ? windows[c1]++ : (windows[c1] = 1); if (windows[c1] === needs[c1]) match++; &#125; right++; while (match === needsKeyLen) &#123; if (right - left &lt; minLen) &#123; minLen = right - left; start = left; &#125; let c2 = s[left]; if (needs[c2]) &#123; windows[c2]--; if (windows[c2] &lt; needs[c2]) &#123; match--; &#125; &#125; left++; &#125; &#125; return minLen === Number.MAX_SAFE_INTEGER ? \"\" : s.substr(start, minLen);&#125;;","categories":[{"name":"数据结构","slug":"data-structure","permalink":"https://haohaio.github.io/categories/data-structure/"}],"tags":[{"name":"LeetCode","slug":"leetcode","permalink":"https://haohaio.github.io/tags/leetcode/"}]},{"title":"JavaScript 之 继承","slug":"javascript-extend","date":"2020-05-07T06:38:38.000Z","updated":"2020-05-07T08:43:54.855Z","comments":true,"path":"front-end/javascript-extend.html","link":"","permalink":"https://haohaio.github.io/front-end/javascript-extend.html","excerpt":"","text":"构造函数继承原型链继承原型链继承就是将父类的实例作为子类的原型 function Animal() &#123; this.species = \"Animal\"; this.color = [\"black\", \"white\"];&#125;Animal.prototype.sayHello = function () &#123; console.log(\"Hello, my species is Animal.\");&#125;;function Cat(name) &#123; this.name = name;&#125;// 将父类的实例作为子类的原型Cat.prototype = new Animal();let cat1 = new Cat(\"Tom\");console.log(cat1.species); // Animalconsole.log(cat1.name); // Tomconsole.log(cat1.color); // [\"black\", \"white\"]cat1.sayHello(); // Hello, my species is Animal.let cat2 = new Cat(\"Jack\");cat2.color.push(\"blue\");// 父类的引用属性会被所有子类实例共享console.log(cat2.color); // [\"black\", \"white\", \"blue\"]console.log(cat1.color); // [\"black\", \"white\", \"blue\"] 优点 简单，易于实现 父类新增原型方法、原型属性，子类都能访问到 缺点 无法实现多继承，因为原型一次只能被一个实例更改 父类的引用属性会被所有子类实例共享 子类构建实例时不能向父类传递参数 构造函数继承function Animal(species) &#123; this.species = species; this.color = [\"black\", \"white\"];&#125;Animal.prototype.sayHello = function () &#123; console.log(`Hello, my species is $&#123;this.species&#125;.`);&#125;;function Cat(name) &#123; Animal.call(this, \"Cat\"); this.name = name;&#125;let cat1 = new Cat(\"Tom\");console.log(cat1.species); // Catconsole.log(cat1.name); // Tomconsole.log(cat1.color); // [\"black\", \"white\"]cat1.sayHello(); // Uncaught TypeError: cat1.sayHello is not a functionlet cat2 = new Cat(\"Jack\");cat2.color.push(\"blue\");console.log(cat2.color); // [\"black\", \"white\", \"blue\"]console.log(cat1.color); // [\"black\", \"white\"] 优点 解决了原型链继承中子类实例共享父类引用属性的问题 创建子类实例时，可以向父类传递参数 可以实现多继承（call 多个父类对象） 缺点 只能继承父类实例的属性和方法，不能继承其原型上的属性和方法 父类的方法不能复用，子类实例的方法每次都是单独创建的。 组合继承function Animal(species) &#123; this.species = species; this.color = [\"black\", \"white\"];&#125;Animal.prototype.sayHello = function () &#123; console.log(`Hello, my species is $&#123;this.species&#125;.`);&#125;;function Cat(name) &#123; Animal.call(this, \"Cat\"); this.name = name;&#125;Cat.prototype = new Animal();let cat1 = new Cat(\"Tom\");cat1.sayHello(); // Hello, my species is Cat.console.log(cat1 instanceof Animal); // trueconsole.log(cat1 instanceof Cat); // trueconsole.log(cat1.constructor === Animal); // trueconsole.log(cat1.constructor === Cat); // false 优点 父类的方法可以被复用 父类的引用属性不会被共享 子类构建实例时可以向父类传递参数 缺点 调用了两次父类的构造函数，第一次通过将父类的实例作为子类的原型，给子类的原型添加了父类构造函数的属性以及原型上的属性；第二次调用子类构造函数时又执行了父类的构造函数覆盖了子类原型中的同名参数，这种被覆盖的情况造成了性能上的浪费。 实例继承为父类实例添加新特征，作为子类实例返回。 function Animal(species) &#123; this.species = species; this.color = [\"black\", \"white\"];&#125;Animal.prototype.sayHello = function () &#123; console.log(`Hello, my species is $&#123;this.species&#125;.`);&#125;;function Cat(name) &#123; let animal = new Animal(\"Cat\"); animal.name = \"Tom\"; return animal;&#125;let cat1 = new Cat(\"Tom\");console.log(cat1.species); // Catconsole.log(cat1.name); // Tomconsole.log(cat1.color); // [\"black\", \"white\"]cat1.sayHello(); // Hello, my species is Cat.let cat2 = new Cat(\"Jack\");cat2.color.push(\"blue\");console.log(cat2.color); // [\"black\", \"white\", \"blue\"]console.log(cat1.color); // [\"black\", \"white\"] 优点 不限制调用方式，不管是 new 子类()还是子类()，返回的对象具有相同的效果 父类的引用属性不会被共享 子类构建实例时可以向父类传递参数 缺点 实例是父类的实例，不是子类的实例 不支持多继承 拷贝继承function Animal(species) &#123; this.species = species; this.color = [\"black\", \"white\"];&#125;Animal.prototype.sayHello = function () &#123; console.log(`Hello, my species is $&#123;this.species&#125;.`);&#125;;function Cat(name) &#123; let f = new Animal(\"Cat\"); for (let k in f) &#123; Cat.prototype[k] = f[k]; &#125; Cat.prototype.name = name;&#125;let cat1 = new Cat(\"Tom\");console.log(cat1.species); // Catconsole.log(cat1.name); // Tomconsole.log(cat1.color); // [\"black\", \"white\"]cat1.sayHello(); // Hello, my species is Cat.let cat2 = new Cat(\"Jack\");cat2.color.push(\"blue\");console.log(cat2.color); // [\"black\", \"white\", \"blue\"]console.log(cat1.color); // [\"black\", \"white\", \"blue\"] 优点 支持多继承 缺点 效率低，性能差，占用内存高（因为需要拷贝父类属性） 使用的是浅拷贝的方式，父类的引用属性依然会被子类共享 寄生组合继承function Animal(species) &#123; this.species = species; this.color = [\"black\", \"white\"];&#125;Animal.prototype.sayHello = function () &#123; console.log(`Hello, my species is $&#123;this.species&#125;.`);&#125;;function Cat(name) &#123; Animal.call(this, \"Cat\"); this.name = name;&#125;Cat.prototype = Object.create(Animal.prototype);// 修复构造函数指向（修改子类 prototype 时，会修改 constructor 的指向）Cat.prototype.constructor = Cat;let cat1 = new Cat(\"Tom\");cat1.sayHello(); // Hello, my species is Cat. 解决了组合继承会两次调用父类的构造函数造成浪费的缺点。是一种比较完美的继承方式。 ES6 Class extendsclass Animal &#123; constructor(species) &#123; this.species = species; this.color = [\"black\", \"white\"]; &#125;&#125;class Cat extends Animal &#123; constructor(species, name) &#123; super(species); this.name = name; &#125;&#125;let cat1 = new Cat(\"Cat\", \"Tom\");console.log(cat1.species); // Catconsole.log(cat1.name); // Tomconsole.log(cat1.color); // [\"black\", \"white\"]let cat2 = new Cat(\"Jack\");cat2.color.push(\"blue\");console.log(cat2.color); // [\"black\", \"white\", \"blue\"]console.log(cat1.color); // [\"black\", \"white\"] 除了兼容性问题，完美。 非构造函数继承原型式继承利用一个空对象作为中介，将某个对象直接赋值给空对象构造函数的原型。其本质上是对参数对象的一个浅复制。 function object(obj) &#123; function F() &#123;&#125; F.prototype = obj; return new F();&#125;let animal = &#123; species: \"Animal\", color: [\"black\", \"white\"],&#125;;let cat1 = object(animal);console.log(cat1.species); // Animal ES5 还提供了 Object.create() 方法规范化了原型式继承，可以使用 Object.create() 方法替换 object() 方法： let animal = &#123; species: \"Animal\", color: [\"black\", \"white\"],&#125;;let cat1 = Object.create(animal);console.log(cat1.species); // Animal 优缺点与原型链继承相同。 拷贝继承使用深拷贝的方式解决子类会共享父类引用属性的问题。 let animal = &#123; species: \"Animal\", color: [\"black\", \"white\"],&#125;;function deepCopy(p, c) &#123; var c = c || &#123;&#125;; for (var i in p) &#123; if (typeof p[i] === \"object\") &#123; c[i] = Array.isArray(p[i]) ? [] : &#123;&#125;; deepCopy(p[i], c[i]); &#125; else &#123; c[i] = p[i]; &#125; &#125; return c;&#125;let cat1 = deepCopy(animal);let cat2 = deepCopy(animal);cat2.color.push(\"blue\");console.log(cat2.color); // [\"black\", \"white\", \"blue\"]console.log(cat1.color); // [\"black\", \"white\"]","categories":[{"name":"前端","slug":"front-end","permalink":"https://haohaio.github.io/categories/front-end/"}],"tags":[{"name":"JavaScript","slug":"javascript","permalink":"https://haohaio.github.io/tags/javascript/"}]},{"title":"[JavaScript LeetCode]30. 串联所有单词的子串","slug":"leetcode-substring-with-concatenation-of-all-words","date":"2020-04-30T03:25:21.000Z","updated":"2020-05-11T07:09:30.672Z","comments":true,"path":"data-structure/leetcode-substring-with-concatenation-of-all-words.html","link":"","permalink":"https://haohaio.github.io/data-structure/leetcode-substring-with-concatenation-of-all-words.html","excerpt":"","text":"原题链接 滑动窗口第 2 题 给定一个字符串 s 和一些长度相同的单词 words。找出 s 中恰好可以由 words 中所有单词串联形成的子串的起始位置。 注意子串要与 words 中的单词完全匹配，中间不能有其他字符，但不需要考虑 words 中单词串联的顺序。 示例： 输入：s = &quot;barfoothefoobarman&quot;, words = [&quot;foo&quot;,&quot;bar&quot;]输出：[0,9]解释：从索引 0 和 9 开始的子串分别是 &quot;barfoo&quot; 和 &quot;foobar&quot;。输出的顺序不重要, [9,0] 也是有效答案。输入：s = &quot;wordgoodgoodgoodbestword&quot;, words = [&quot;word&quot;,&quot;good&quot;,&quot;best&quot;,&quot;word&quot;]输出：[] 暴力解法解题思路： 用 map 来存储 words，把 words 中的单词作为 key，单词出现的次数作为 value 循环字符串 s，然后每次从字符串 s 中截取一段长度为 words 单词总长的字符串，然后按照单个 words 单词的长度，对其进行拆分成单词 使用拆分后的单词去 map 中查询，如果存在，则将其 value - 1，否则表明当前字符串不符合要求 内层循环结束后，如果 map 所有的 value 都为 0，则表明当前子字符串符合要求，将其起始索引放入结果集中 最后返回结果集 var findSubstring = function (s, words) &#123; if (!s || !words || !words.length) return []; let wordLen = words[0].length; let allWordsLen = wordLen * words.length; let len = s.length; let map = &#123;&#125;; let ans = []; for (let word of words) &#123; map[word] ? map[word]++ : (map[word] = 1); &#125; for (let i = 0; i &lt;= len - allWordsLen; i++) &#123; let vm = &#123; ...map &#125;; for (let j = i; j &lt;= i + allWordsLen - wordLen; j += wordLen) &#123; // 将字符串切割成长度为 wordLen 的子字符串 let w = s.slice(j, j + wordLen); if (vm[w]) &#123; vm[w]--; &#125; else &#123; break; &#125; &#125; if (Object.values(vm).every((item) =&gt; item === 0)) &#123; ans.push(i); &#125; &#125; return ans;&#125;; 滑动窗口解法var findSubstring = function (s, words) &#123; if (!s || !words || !words.length) return []; let wordLen = words[0].length; let allWordsLen = wordLen * words.length; let len = s.length; let windows = &#123;&#125;; // 存储滑动窗口收集到的目标 words let needs = &#123;&#125;; // 存储目标 words for (let word of words) &#123; needs[word] ? needs[word]++ : (needs[word] = 1); &#125; let needsKeyLen = Object.keys(needs).length; let left = 0; let right = 0; let match = 0; // 若 windows[word] === needs[word]， 则 match + 1 let ans = []; // 只需遍历一个 word 的长度，就可知道切割成一个 word 长度的子字符串的所有情况 for (let i = 0; i &lt; wordLen; i++) &#123; windows = &#123;&#125;; right = left = i; match = 0; while (right &lt;= len - wordLen) &#123; // 滑动窗口右边界以一个 word 的长度为单位进行递增，并截取子字符串 let w1 = s.slice(right, right + wordLen); right += wordLen; // 若切割得到的子字符串不是目标 word, 直接让左边界等于右边界，重新滑动窗口 if (!needs[w1]) &#123; windows = &#123;&#125;; left = right; match = 0; continue; &#125; windows[w1] ? windows[w1]++ : (windows[w1] = 1); if (windows[w1] === needs[w1]) match++; while (match === needsKeyLen) &#123; // 若滑动窗口长度等于目标 words 的所有长度， 则将左边界添加到结果中， // 例如 s：\"barbarfoothefoobarman\"，words：[\"foo\",\"bar\"]，第一次进入 while 循环时，needs = &#123;foo: 1, bar: 1&#125;; windows &#123;bar: 2, foo: 1&#125; if (right - left === allWordsLen) &#123; ans.push(left); &#125; // 此时 windows 内的存储的 word 值多余 needs, 故需要滑动窗口左边界向右移动 let w2 = s.slice(left, left + wordLen); left += wordLen; if (needs[w2]) &#123; windows[w2]--; if (windows[w2] &lt; needs[w2]) match--; &#125; &#125; &#125; &#125; return ans;&#125;;","categories":[{"name":"数据结构","slug":"data-structure","permalink":"https://haohaio.github.io/categories/data-structure/"}],"tags":[{"name":"LeetCode","slug":"leetcode","permalink":"https://haohaio.github.io/tags/leetcode/"}]},{"title":"[JavaScript LeetCode]3. 无重复字符的最长子串","slug":"leetcode-longest-substring-without-repeating-characters","date":"2020-04-28T03:05:10.000Z","updated":"2020-04-30T03:24:53.081Z","comments":true,"path":"data-structure/leetcode-longest-substring-without-repeating-characters.html","link":"","permalink":"https://haohaio.github.io/data-structure/leetcode-longest-substring-without-repeating-characters.html","excerpt":"","text":"原题链接 滑动窗口第 1 题 给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。 示例： 输入: &quot;abcabcbb&quot;输出: 3解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。输入: &quot;bbbbb&quot;输出: 1解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。输入: &quot;pwwkew&quot;输出: 3解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。 暴力解法我们先枚举所有的子串，然后判断子串内是否有重复字符，更新最长子串的长度值 var lengthOfLongestSubstring = function (s) &#123; let len = s.length; let longestLen = 0; for (let i = 0; i &lt; len; i++) &#123; for (let j = 1; j &lt;= len; j++) &#123; if (allUnique(s, i, j)) longestLen = Math.max(longestLen, j - i); &#125; &#125; return longestLen;&#125;;function allUnique(s, start, end) &#123; let set = new Set(); for (let i = start; i &lt; end; i++) &#123; if (set.has(s[i])) return false; set.add(s[i]); &#125; return true;&#125; 但是这中解法太慢了，在 LeetCode 上此答案会超出时间限制 - - 滑动窗口解法 滑动窗口是数组/字符串问题中常用的抽象概念。窗口通常是在数组/字符串中由开始和结束索引定义的一系列元素的集合，即 [i, j)（左闭，右开）。而滑动窗口是可以将两个边界向某一方向“滑动”的窗口。例如，我们将 [i, j) 向右滑动 1 个元素，则它将变为 [i+1, j+1)（左闭，右开）。它可以将嵌套的循环问题，转换为单循环问题，降低时间复杂度。 在暴力法中，我们会反复检查一个子字符串是否含有有重复的字符，但这是没有必要的。如果从索引 i 到 j - 1 之间的子字符串 sij 已经被检查为没有重复字符。我们只需要检查 s[j] 对应的字符是否已经存在于子字符串 sij 中。 接下来看一下滑动窗口解法： var lengthOfLongestSubstring = function (s) &#123; let len = s.length; let set = new Set(); let i = 0; let j = 0; let ans = 0; while (i &lt; len &amp;&amp; j &lt; len) &#123; if (!set.has(s[j])) &#123; set.add(s[j++]); ans = Math.max(ans, j - i); &#125; else &#123; set.delete(s[i++]); &#125; &#125; return ans;&#125;; 我们还可以使用数组及其 push 和 shift 方法来模拟滑动窗口： var lengthOfLongestSubstring = function (s) &#123; let ans = 0; let temp = []; let i = 0; while (i &lt; s.length) &#123; if (temp.indexOf(s[i]) === -1) &#123; temp.push(s[i++]); ans = Math.max(ans, temp.length); &#125; else &#123; temp.shift(); &#125; &#125; return ans;&#125;; 滑动窗口优化当滑动窗口右边界扩大时发现元素与滑动窗口内元素重复时，其实不需要对左边界一位一位的递增，可以找到与滑动窗口内重复元素的下标，可以直接让左边界等于该下标的后一位。 因此我们需要对下标进行维护。 针对使用数组模拟滑动窗口的方法我们可以这样优化： var lengthOfLongestSubstring = function (s) &#123; let ans = 0; let temp = []; let i = 0; while (i &lt; s.length) &#123; let index = temp.indexOf(s[i]); if (index === -1) &#123; temp.push(s[i++]); ans = Math.max(ans, temp.length); &#125; else &#123; temp.splice(0, index + 1) &#125; &#125; return ans;&#125;; 也可以使用 Map 数据结构来对下标进行维护： var lengthOfLongestSubstring = function (s) &#123; let len = s.length; let map = new Map(); let ans = 0; for (let i = 0, j = 0; j &lt; len; j++) &#123; if (map.has(s[j])) &#123; // 例如 'abcaabc'，当移动到第二个 b 时， i = 4，j = 5，map.get('b') = 2，即 map 内重复的 b 不在滑动窗口内，故此时不能直接让 i = map.get(s[j])，需要对边界进行判断 i = Math.max(i, map.get(s[j])); &#125; ans = Math.max(ans, j + 1 - i); map.set(s[j], j + 1); &#125; return ans;&#125;; set 和 map 是用 hash 实现的，故其 has 方法的时间复杂度肯定是优于基于索引的 indexOf 的。","categories":[{"name":"数据结构","slug":"data-structure","permalink":"https://haohaio.github.io/categories/data-structure/"}],"tags":[{"name":"LeetCode","slug":"leetcode","permalink":"https://haohaio.github.io/tags/leetcode/"}]},{"title":"[JavaScript LeetCode]100. 相同的树","slug":"leetcode-same-tree","date":"2020-04-27T14:37:55.000Z","updated":"2020-04-28T01:55:27.852Z","comments":true,"path":"data-structure/leetcode-same-tree.html","link":"","permalink":"https://haohaio.github.io/data-structure/leetcode-same-tree.html","excerpt":"","text":"原题链接 给定两个二叉树，编写一个函数来检验它们是否相同。 如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。 示例： 输入: 1 1 / \\ / \\ 2 3 2 3 [1,2,3], [1,2,3]输出: true输入: 1 1 / \\ 2 2 [1,2], [1,null,2]输出: false输入: 1 1 / \\ / \\ 2 1 1 2 [1,2,1], [1,1,2]输出: false 解法先看一下定义的树结点构造函数： function TreeNode(val) &#123; this.val = val; this.left = this.right = null;&#125; 深度优先遍历（先序遍历）。 /** * @param &#123;TreeNode&#125; p * @param &#123;TreeNode&#125; q * @return &#123;boolean&#125; */var isSameTree = function (p, q) &#123; // 当两棵树的当前节点都为 null 时返回 true if (p === null &amp;&amp; q === null) return true; // 当其中一个为 null 另一个不为 null 时返回 false if (p === null || q === null) return false; // 当两个都不为 null 但是值不相等时，返回 false if (p.val !== q.val) return false; // 当不满足上述终止条件时，继续判断左子树和右子树 return isSameTree(p.left, q.left) &amp;&amp; isSameTree(p.right, q.right);&#125;;","categories":[{"name":"数据结构","slug":"data-structure","permalink":"https://haohaio.github.io/categories/data-structure/"}],"tags":[{"name":"LeetCode","slug":"leetcode","permalink":"https://haohaio.github.io/tags/leetcode/"}]},{"title":"Vue 3.0 之 PatchFlags","slug":"vue-patch-flags","date":"2020-04-26T06:58:38.000Z","updated":"2020-04-27T03:18:10.420Z","comments":true,"path":"front-end/vue-patch-flags.html","link":"","permalink":"https://haohaio.github.io/front-end/vue-patch-flags.html","excerpt":"","text":"在 4 月 21 日晚，Vue 作者尤雨溪在 B 站直播分享了 Vue.js 3.0 Beta 最新进展。 其中在介绍性能提升方面时，提到了编译模板的优化。例如下面的模板代码： &lt;div&gt; &lt;span /&gt; &lt;span class=\"highlight\"&gt;&#123;&#123; msg &#125;&#125;&lt;/span&gt;&lt;/div&gt; 会被编译成： import &#123; createVNode as _createVNode, toDisplayString as _toDisplayString, openBlock as _openBlock, createBlock as _createBlock &#125; from \"vue\"export function render(_ctx, _cache) &#123; return (_openBlock(), _createBlock(\"div\", null, [ _createVNode(\"span\"), _createVNode(\"span\", &#123; class: \"highlight\" &#125;, _toDisplayString(_ctx.msg), 1 /* TEXT */) ]))&#125; 可以看到，创建第二个虚拟 DOM span 时，最后一个参数为 1 /* TEXT */。这个 1 就是一个 PatchFlag，代表具有动态的 textContent。在新版本的 Vue 中，只会对带有 PatchFlag 的节点进行真正的追踪，并且在更新的时候，通过枚举值判断，只会比较该节点文字的变化，无需再去比较其它属性的变化。显而易见，这对性能提升有很大的帮助。 可以看下源码中对 PatchFlags 枚举值是如何定义的：vue-next patchFlags export const enum PatchFlags &#123; TEXT = 1, // 表示具有动态textContent的元素 CLASS = 1 &lt;&lt; 1, // 表示有动态Class的元素 STYLE = 1 &lt;&lt; 2, // 表示有动态样式的元素 PROPS = 1 &lt;&lt; 3, // 表示具有非类/样式动态属性的元素。(组件定义的 class 和 style 也属于 PROPS) FULL_PROPS = 1 &lt;&lt; 4, // 表示带有动态属性的元素，与上面 CLASS, STYLE and PROPS 相斥 HYDRATE_EVENTS = 1 &lt;&lt; 5, // 表示带有事件监听器的元素 STABLE_FRAGMENT = 1 &lt;&lt; 6, // 表示子元素顺序不变的 fragment。(在React中，有一个 React.Fragments 的虚拟标签，其作用就是说在一个组件返回多个元素，意味着组件下根节点不只一个。新版本的 Vue 中 template 支持多个根节点了，不需要用一个根节点包裹所有的元素了，render 可以返回一个数组。新版本的 Vue 会把这些自动的变成 fragment，特别在模板语法中时无感知的) KEYED_FRAGMENT = 1 &lt;&lt; 7, // 表示子元素有 key或部分子元素有 key 的 fragment UNKEYED_FRAGMENT = 1 &lt;&lt; 8, // 表示带有无key绑定的 fragment NEED_PATCH = 1 &lt;&lt; 9, // 表示只需要非属性比较的元素，例如 ref 或 directives DYNAMIC_SLOTS = 1 &lt;&lt; 10, // 表示具有动态插槽的元素 // 特殊 FLAGS： 负整数表示永远不会用作 diff,只需检查 patchFlag === FLAG HOISTED = -1, // 表示静态节点 BAIL = -2, // 与 renderSlot() 相关&#125; 枚举与位运算可以看到上面源码中使用了位操作符对枚举值进行定义，接下来我们来了解一下为什么这么写。 位运算概览位运算就是直接对整数在内存中的二进制位进行操作。接下来我们先来系统的了解下位运算的各种操作符。 按位与运算符（&amp;）&amp; 运算符表示按位与，即两个位都为 1 时，结果才为 1，例如 3 &amp; 5，即 0000 0011 &amp; 0000 0101，结果为 0000 0001。即 3 &amp; 5 的值为 1。 按位或运算符（|）| 运算符表示按位或，即两个位有一位为 1 时，结果就为 1，例如 3 | 5，即 0000 0011 | 0000 0101，结果为 0000 0111，即 3 | 5 的值为 7。 按位异或运算符（^）^ 运算符表示按位异或，即两个位相同时结果为 0，相异时结果为 1。例如 3 ^ 5，即 0000 0011 ^ 0000 0101，结果为 0000 0110，即 3 ^ 5 的值为 6。 按位取反运算符（~）~ 运算符表示按位取反，即对一个二进制数按位取反，即将 0 变 1， 1 变 0。例如 ~3，即将 0000 0011 变成 1111 1100。很明显是一个负数。现在计算机普遍使用补码表示负数，补码转换成原码就是等于其绝对值取反然后末位加 1，先绝对值取反就是 1000 0011，末位加 1，变成1000 0100，即 ~3 的值为 -4 左移运算符（&lt;&lt;）&lt;&lt; 表示把各二进位全部左移若干位，高位丢弃，低位补 0。例如二进制 1010 1110 左移两位就是 1011 1000。 右移运算符（&gt;&gt;）&gt;&gt; 表示把各二进位全部右移若干位，对无符号数，高位补 0，有符号数，各编译器处理方法不一样，有的补符号位（算术右移），有的补 0（逻辑右移）。 PatchFlags 中的枚举值再来看一下 PatchFlags 中定义的枚值就很清楚了： export const enum PatchFlags &#123; TEXT = 1, // 1 二进制: 0000 0001 (1) CLASS = 1 &lt;&lt; 1, // 二进制: 0000 0010 (2) STYLE = 1 &lt;&lt; 2, // 二进制: 0000 0100 (4) PROPS = 1 &lt;&lt; 3, // 二进制: 0000 1000 (8) FULL_PROPS = 1 &lt;&lt; 4 // 二进制: 0001 0000 (16) ...&#125; 通过观察可以看到，每个枚举值的二进制数中都只有一个 1，通过左移的位数不同来进行区分。就是通过这个特点，我们可以方便的进行多枚举值情况的处理。 接下来我们看下当同时需要对 TEXT 和 PROPS 需要进行 patching 时，PatchFlag 的枚举值是多少 &lt;div&gt; &lt;span /&gt; &lt;span :id=\"123\"&gt;&#123;&#123; msg &#125;&#125;&lt;/span&gt;&lt;/div&gt; import &#123; createVNode as _createVNode, toDisplayString as _toDisplayString, openBlock as _openBlock, createBlock as _createBlock &#125; from \"vue\"export function render(_ctx, _cache) &#123; return (_openBlock(), _createBlock(\"div\", null, [ _createVNode(\"span\"), _createVNode(\"span\", &#123; id: _ctx.id &#125;, _toDisplayString(_ctx.msg), 9 /* TEXT, PROPS */, [\"id\"]) ]))&#125; 可以看到 PatchFlag 的值为 9 /* TEXT, PROPS */。 那么 9 是如何得来的呢？ 其实就是通过按位或运算得来的。TEXT 对应的二进制为 0000 0001，PROPS 对应的二进制为 0000 1000，执行按位或运算后结果就是 0000 1001，也就是 9 了。 在源码 vue-next/packages/compiler-core/src/transforms/transformElement.ts 的 buildProps 方法中，有这样一段代码，我们来看一下： // patchFlag analysisif (hasDynamicKeys) &#123; patchFlag |= PatchFlags.FULL_PROPS&#125; else &#123; if (hasClassBinding) &#123; patchFlag |= PatchFlags.CLASS &#125; if (hasStyleBinding) &#123; patchFlag |= PatchFlags.STYLE &#125; if (dynamicPropNames.length) &#123; patchFlag |= PatchFlags.PROPS &#125; if (hasHydrationEventBinding) &#123; patchFlag |= PatchFlags.HYDRATE_EVENTS &#125;&#125;if ((patchFlag === 0 || patchFlag === PatchFlags.HYDRATE_EVENTS) &amp;&amp; (hasRef || runtimeDirectives.length &gt; 0)) &#123; patchFlag |= PatchFlags.NEED_PATCH&#125; 可以看到 Vue 中就是使用按位或运算 | 来合并多个枚举值的 ~~ 那我们如何通过 9 来判断包含了枚举值 TEXT 和 PROPS 呢？ 其实是通过按位与运算来判断的。TEXT 的值为 1，9 &amp; 1 的值，二进制为 0000 0001，值为 1。PROPS 的值为 8，9 &amp; 8 的值，二进制为 0000 1000，值为 8。两个值都不为 0，那么转换成布尔值的话就都是 true。 在源码 vue-next/packages/runtime-core/src/componentRenderUtils.ts 的 shouldUpdateComponent 方法中，有这样一段代码，我们来看一下： if (patchFlag &gt; 0) &#123; if (patchFlag &amp; PatchFlags.DYNAMIC_SLOTS) &#123; // slot content that references values that might have changed, // e.g. in a v-for return true &#125; if (patchFlag &amp; PatchFlags.FULL_PROPS) &#123; // presence of this flag indicates props are always non-null return hasPropsChanged(prevProps!, nextProps!) &#125; else if (patchFlag &amp; PatchFlags.PROPS) &#123; const dynamicProps = nextVNode.dynamicProps! for (let i = 0; i &lt; dynamicProps.length; i++) &#123; const key = dynamicProps[i] if (nextProps![key] !== prevProps![key]) &#123; return true &#125; &#125; &#125;&#125; 可以看到 Vue 中就是使用按位与运算 &amp; 来判断枚举值的 ~~ 现在再来看下 9 的二进制表示： 0000 1001。可以看到有 2 个 1，第一个 1 与 PROPS(8) 二进制数 0000 1000 中的 1 位置相同，第二个 1 与 TEXT(1) 二进制数 0000 0001 中的 1 位置相同。如果第一次接触位运算的话，看到这里是不是恍然大悟了呢。通过按位或运算和按位与运算，可以很方便的处理多枚举的情况哦 ~~ 位运算编程小技巧奇偶数判断当一个数为奇数时，那么其二进制末位肯定为 1。当其与 1 执行按位与运算时，则结果肯定为 1。反之，偶数的二进制末位肯定为 0，当其与 1 执行按位与运算时，则结果肯定为 0。因此，可以通过位运算很方便的写一个判断奇偶数的方法： const isOdd = (num) =&gt; &#123; return !!(num &amp; 1)&#125; 乘以 2 和 除以 2看到上面枚举值可以看到左移一位就是乘以 2，那么右移一位就是除以 2 了，但是这个除以 2 和 JavaScript 中的除以 2 还是有些不同的，比如 3 的二进制为 0011，那么右移一位为 0001，等于 1，相当于 JavaScript 中除以 2 后向下取整了。 3 &lt;&lt; 1 // 63 &gt;&gt; 1 // 1 小结本文对 Vue 3.0 中的 PatchFlags 做了一些了解，更多的是对位运算重新学习了一遍 ~~","categories":[{"name":"前端","slug":"front-end","permalink":"https://haohaio.github.io/categories/front-end/"}],"tags":[{"name":"JavaScript","slug":"javascript","permalink":"https://haohaio.github.io/tags/javascript/"}]},{"title":"Curl 常用用法","slug":"curl","date":"2020-04-24T08:09:52.000Z","updated":"2020-04-26T02:27:38.337Z","comments":true,"path":"others/curl.html","link":"","permalink":"https://haohaio.github.io/others/curl.html","excerpt":"","text":"curl 是常用的命令行工具，用来请求 Web 服务器。它的名字就是客户端（client）的 URL 工具的意思。 它的功能非常强大，命令行参数多达几十种。如果熟练的话，完全可以取代 Postman 这一类的图形界面工具。 今天来了解一下 curl 的常用用法。 不带参数# 向 `www.example.com` 发送一个 GET 请求，服务器返回的内容会在命令行输出。$ curl https://www.example.com -b-b 参数用来向服务器发送 Cookie。 # 向服务器发送一个名为 foo，值为 bar 的 Cookie。$ curl -b 'foo=bar' https://www.example.com# 发送多个 cookie 时，中间用 ; 隔开$ curl -b 'foo1=bar;foo2=bar2' https://www.example.com -d-d 参数用于发送 POST 请求的数据体。 $ curl -d 'username=emma＆password=123' -X POST https://google.com/login# 或者$ curl -d 'username=emma' -d 'password=123' -X POST https://google.com/login --data-urlencode--data-urlencode 参数等同于 -d，发送 POST 请求的数据体，区别在于会自动将发送的数据进行 URL 编码。 $ curl --data-urlencode 'comment=hello world' https://google.com/login -G-G 参数用来构造 URL 的查询字符串。 $ curl -G -d 'q=kitties' -d 'count=20' https://google.com/search 上面命令会发出一个 GET 请求，实际请求的 URL 为 https://google.com/search?q=kitties&amp;count=20。如果省略 -G，会发出一个 POST 请求。 如果数据需要 URL 编码，可以结合 --data-urlencode 参数。 -H-H 参数添加 HTTP 请求的标头。 $ curl -d '&#123;\"login\": \"emma\", \"pass\": \"123\"&#125;' -H 'Content-Type: application/json' https://google.com/login -i-i 参数打印出服务器回应的 HTTP 标头。 $ curl -i https://www.example.com 上面命令收到服务器回应后，先输出服务器回应的标头，然后空一行，再输出网页的源码。 -I(--head)-I 参数向服务器发出 HEAD 请求，然会将服务器返回的 HTTP 标头打印出来。 $ curl -I https://www.example.com --limit-rate--limit-rate 用来限制 HTTP 请求和回应的带宽，模拟慢网速的环境。 $ curl --limit-rate 200k https://google.com 上面命令将带宽限制在每秒 200K 字节。 -o-o 参数将服务器的回应保存成文件，等同于 wget 命令。 $ curl -o example.html https://www.example.com 上面命令将 www.example.com 保存成 example.html。 -O-O 参数将服务器回应保存成文件，并将 URL 的最后部分当作文件名。 $ curl -O https://www.example.com/foo/bar.html 上面命令将服务器回应保存成文件，文件名为 bar.html。 -v-v 参数输出通信的整个过程，用于调试。 $ curl -v https://www.example.com -X-X 参数指定 HTTP 请求的方法。 $ curl -X POST https://www.example.com 上面命令对 https://www.example.com 发出 POST 请求。 参考curl 的用法指南","categories":[{"name":"其它","slug":"others","permalink":"https://haohaio.github.io/categories/others/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://haohaio.github.io/tags/工具/"}]},{"title":"[JavaScript LeetCode]88. 合并两个有序数组","slug":"leetcode-merge-sorted-array","date":"2020-04-24T01:17:25.000Z","updated":"2020-04-28T01:55:33.622Z","comments":true,"path":"data-structure/leetcode-merge-sorted-array.html","link":"","permalink":"https://haohaio.github.io/data-structure/leetcode-merge-sorted-array.html","excerpt":"","text":"原题链接 给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 nums1 成为一个有序数组。 说明: 初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。 你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。 示例: 输入:nums1 = [1,2,3,0,0,0], m = 3nums2 = [2,5,6], n = 3输出: [1,2,2,3,5,6] 解法一直接在不超过数组空间的情况下合并两个数组（splice），再进行排序。 var merge = function (nums1, m, nums2, n) &#123; nums1.splice(m, n, ...nums2); nums1.sort((a, b) =&gt; a - b);&#125;; 解法二设置指针 len1 和 len2 分别指向 nums1 和 nums2 的有数字尾部，从尾部值开始比较遍历，同时设置指针 len 指向 nums1 的最末尾，每次遍历比较值大小之后，则进行填充。 当 len2 先小于 0 时，此时 num2 已全部填充进 nums1 中，则已经得到目标结果。 若 len1 先小于 0 时，表明此时 nums2 中 len2 之前的值都比 nums1 中的元素小，替换掉 nums1 中长度为 len2 + 1 的元素即可。 var merge = function (nums1, m, nums2, n) &#123; let len1 = m - 1; let len2 = n - 1; let len = m + n - 1; while (len1 &gt;= 0 &amp;&amp; len2 &gt;= 0) &#123; nums1[len--] = nums1[len1] &gt; nums2[len2] ? nums1[len1--] : nums2[len2--]; &#125; if (len1 &lt; 0) &#123; nums1.splice(0, len2 + 1, ...nums2.slice(0, len2 + 1)); &#125;&#125;;","categories":[{"name":"数据结构","slug":"data-structure","permalink":"https://haohaio.github.io/categories/data-structure/"}],"tags":[{"name":"LeetCode","slug":"leetcode","permalink":"https://haohaio.github.io/tags/leetcode/"}]},{"title":"[JavaScript LeetCode]70. 爬楼梯","slug":"leetcode-climbing-stairs","date":"2020-04-23T15:12:17.000Z","updated":"2020-04-24T03:16:20.654Z","comments":true,"path":"data-structure/leetcode-climbing-stairs.html","link":"","permalink":"https://haohaio.github.io/data-structure/leetcode-climbing-stairs.html","excerpt":"","text":"原题链接 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？ 注意：给定 n 是一个正整数。 示例: 输入： 2输出： 2解释： 有两种方法可以爬到楼顶。1. 1 阶 + 1 阶2. 2 阶输入： 3输出： 3解释： 有三种方法可以爬到楼顶。1. 1 阶 + 1 阶 + 1 阶2. 1 阶 + 2 阶3. 2 阶 + 1 阶 解法一本题可以采用动态规划的思想，可以将问题分成多个子问题，爬第 n 阶楼梯的方法数量，等于 2 部分之和： 爬上 n-1 阶楼梯的方法数量。因为再爬 1 阶就能到第 n 阶 爬上 n-2 阶楼梯的方法数量。因为再爬 2 阶就能到第 n 阶 所以我们得到公式 dp[n] = dp[n-1] + dp[n-2]。 同时需要初始化 dp[1]=1 和 dp[2]=2。（由于 n 是正整数，故从 dp[1]初始化） 时间复杂度：O(n)。 var climbStairs = function (n) &#123; const dp = []; dp[1] = 1; dp[2] = 2; for (let i = 3; i &lt;= n; i++) &#123; dp[i] = dp[i - 1] + dp[i - 2]; &#125; return dp[n];&#125;; 解法二不使用数组，对空间复杂度进行优化。但使用这种方法时，考虑到 n 为 1 或者 2 的情况，故从 dp[0] 开始初始化。 var climbStairs = function (n) &#123; let preOfPre = 1; // 相当于 dp[0] let pre = 1; // 相当于 dp[1] let res = 1; for (let i = 2; i &lt;= n; i++) &#123; res = pre + preOfPre; preOfPre = pre; pre = res; &#125; return res;&#125;;","categories":[{"name":"数据结构","slug":"data-structure","permalink":"https://haohaio.github.io/categories/data-structure/"}],"tags":[{"name":"LeetCode","slug":"leetcode","permalink":"https://haohaio.github.io/tags/leetcode/"}]},{"title":"[JavaScript LeetCode]69. X 的平方根","slug":"leetcode-sqrtx","date":"2020-04-23T14:41:31.000Z","updated":"2020-04-24T08:09:40.127Z","comments":true,"path":"data-structure/leetcode-sqrtx.html","link":"","permalink":"https://haohaio.github.io/data-structure/leetcode-sqrtx.html","excerpt":"","text":"原题链接 实现 int sqrt(int x) 函数。 计算并返回 x 的平方根，其中 x 是非负整数。 由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。 示例: 输入: 4输出: 2输入: 8输出: 2说明: 8 的平方根是 2.82842..., 由于返回类型是整数，小数部分将被舍去。 解法一直接使用 Math.sqrt() 方法 var mySqrt = function (x) &#123; return parseInt(Math.sqrt(x));&#125;; 解法二暴力破解 var mySqrt = function (x) &#123; let res = 0; while (!(res * res &lt;= x &amp;&amp; (res + 1) * (res + 1) &gt; x)) &#123; res++; &#125; return res;&#125;; 解法三二分查找法 var mySqrt = function (x) &#123; let left = 0; let right = x; while (left &lt;= right) &#123; let mid = Math.round((left + right) / 2); if (mid * mid &lt;= x &amp;&amp; (mid + 1) * (mid + 1) &gt; x) &#123; return mid; &#125; else if (mid * mid &gt; x) &#123; right = mid - 1; &#125; else &#123; left = mid + 1; &#125; &#125; return -1;&#125;;","categories":[{"name":"数据结构","slug":"data-structure","permalink":"https://haohaio.github.io/categories/data-structure/"}],"tags":[{"name":"LeetCode","slug":"leetcode","permalink":"https://haohaio.github.io/tags/leetcode/"}]},{"title":"使用 Sentry 对前端项目进行异常监控","slug":"sentry","date":"2020-04-22T03:36:09.000Z","updated":"2020-04-23T14:43:45.317Z","comments":true,"path":"front-end/sentry.html","link":"","permalink":"https://haohaio.github.io/front-end/sentry.html","excerpt":"","text":"前面在 前端异常监控 一文里大概了解了前端是如何进行异常监控的，但是要搭建一个完整的异常监控系统还是很麻烦的，不仅仅需要完善一下我们前端的异常监控代码，还需要单独开发一个异常管理系统。好在我们有现成的轮子可以使用，Sentry 是就是一个非常出色的服务，今天我们就来了解一下如何使用 Sentry 进行异常监控的。 创建前端项目我们以 Vue 的项目为例，首先使用 vue-cli 创建一个项目 vue create hello-world 然后在在项目里手动抛出一个异常，以便后续异常上报。 在 /src/components/HelloWorld.vue 文件第 40 行抛出一个错误： 注册我们可以使用 Sentry 提供的在线服务来帮助我们进行异常监控。首先我们需要注册一个帐号，注册地址 如上图所示，填写姓名、组织、邮箱、密码后就可以了。 创建 Sentry 项目创建一个 Sentry 非常简单，只需要选中我们想要类型的项目就可以了： 前端项目相关配置按照创建完项目后 Sentry 的提示，在我们的 Vue 项目中进行配置即可： 安装 @sentry/browser # Using npm$ npm install @sentry/browser# Using yarn$ yarn add @sentry/browser 安装 @sentry/integrations # Using npm$ npm install @sentry/integrations --save# Using yarn$ yarn add @sentry/integrations 在 /src/main.js 中添加代码 import * as Sentry from '@sentry/browser';import &#123; Vue as VueIntegration &#125; from '@sentry/integrations';Sentry.init(&#123; dsn: 'https://66ed9457c0e5405397f465b4f9223aa1@o381494.ingest.sentry.io/5208892', // 创建项目后会生成 dsn integrations: [new VueIntegration(&#123;Vue, attachProps: true&#125;)],&#125;); OK，配置完成。 开发环境启动我们的项目，然后打开我们的前端页面。 npm run serve 打开控制台，发现浏览器并没有打印我们的错误，可见 Sentry 已经捕获到错误了。 若需要浏览器在控制台打印错误，可通过设置 integrations 的 logErrors 选项为 true。 然后看一下我们的 Sentry 项目管理页面，可以看到已经收集到异常了： 点开错误详情看一下： 可以看到，错误信息收集的十分完整，不仅有错误的堆栈信息，还有浏览器环境相关信息等等。 现在已经可以愉快的收集异常了，是不是非常简单 ~~ 生产环境生产环境中我们的代码肯定都是经过压缩的，那我们看一下在生产环境中，Sentry 的表现是怎样的。可以本地通过 docker 启动一个 nginx 服务来部署我们的代码，这里就不详细介绍了。项目部署之后，再去看一下我们收集到的异常详细信息： 只能看到错误发生在哪个组件的生命周期钩子里，错误的堆栈信息是代码压缩后的代码堆栈信息，这对我们对错误进行定位就不是很方便了，为了解决这个问题，我们需要把webpack打包生成的 js 文件以及 sourceMap 文件上传到 Sentry 上面，这样，Sentry 就能够帮助我们准确定位了。 我们需要做以下操作： 1. 安装 @sentry/webpack-plugin# Using npm$ npm install --save-dev @sentry/webpack-plugin# Using yarn$ yarn add --dev @sentry/webpack-plugin 2. 修改 webpack 配置 和 release 相关版本配置 新增 /src/settings.js 文件，方便进行 release 版本管理。 module.exports = &#123; version: 'v1.0.0',&#125; 在 /src/main.js 中初始化 Sentry 时添加 release 相关配置。 import settings from './settings.js'Sentry.init(&#123; release: settings.version, dsn: 'https://66ed9457c0e5405397f465b4f9223aa1@o381494.ingest.sentry.io/5208892', // 创建项目后会生成 dsn integrations: [new VueIntegration(&#123;Vue, attachProps: true, logErrors: process.env.NODE_ENV === \"production\" ? false : true&#125;)],&#125;); 新增 .sentryclirc 文件 [defaults]url=https://sentry.io/org=orgproject=org[auth]token=token 对文件中的参数进行一下说明： 使用 Sentry 在线服务的话，url 设置为 https://sentry.io/ org 和 project 可按下图进行配置： token 按以下步骤获取： 点击红框标出的 setting 点击红框标出的 Auth Tokens 点击红框标出的 Create New Token 选中 project:write 复制 token 到 .sentryclirc 文件中 新增 vue.config.js 文件 \"use strict\";const SentryCliPlugin = require(\"@sentry/webpack-plugin\");const settings = require(\"./src/settings.js\");module.exports = &#123; configureWebpack: &#123; plugins: [ new SentryCliPlugin(&#123; release: settings.version, include: \"./dist\", ignore: [\"node_modules\", \"vue.config.js\"], &#125;), ], &#125;,&#125;; 3. 重新打包部署执行打包命令: npm run build 可以在命令行中看到我们上传了打包后生成的 js 文件 和 map 文件： 上传后的文件可以在 Sentry 的管理页面中 Releases 相关版本详情中看到： 部署后，刷新页面，然后进入到 error 详情中查看，如下： 发现可以精准的对错误信息进行定位，完美 ~~ 私有化部署如果企业内部使用的话，私有化部署还是很有必要的。接下来我们就使用 Docker 部署一个 Sentry 服务 1. 启动Redis容器docker run -d --name sentry-redis redis 2. 启动 Postgres 容器docker run -d --name sentry-postgres -e POSTGRES_PASSWORD=secret -e POSTGRES_USER=sentry postgres 3. 生成所有 Sentry 容器共享的密钥export SECRET_KEY=$(docker run --rm sentry config generate-secret-key|tail -n 1) 4. 如果这是一个新数据库，则需要运行 upgradedocker run -it --rm -e SENTRY_SECRET_KEY=$&#123;SECRET_KEY&#125; --link sentry-postgres:postgres --link sentry-redis:redis sentry upgrade 输入邮箱、密码 创建用户。 5. 启动 Sentry 容器docker run -d -p 9000:9000 --name my-sentry -e SENTRY_SECRET_KEY=$&#123;SECRET_KEY&#125; --link sentry-redis:redis --link sentry-postgres:postgres sentry 6. 启动调度器和 workerdocker run -d --name sentry-cron -e SENTRY_SECRET_KEY=$&#123;SECRET_KEY&#125; --link sentry-postgres:postgres --link sentry-redis:redis sentry run crondocker run -d --name sentry-worker-1 -e SENTRY_SECRET_KEY=$&#123;SECRET_KEY&#125; --link sentry-postgres:postgres --link sentry-redis:redis sentry run worker 使用本地 Sentry 服务依次执行命令后，没有问题的话就可以访问 http://localhost:9000 来看一下我们部署的 Sentry 服务了。页面与 Sentry 的在线服务有些区别，但操作流程基本一样。 登陆成功后，新建一个项目，然后修改一下配置： 1. 在 /src/main.js 中修改 dsnimport * as Sentry from '@sentry/browser';import &#123; Vue as VueIntegration &#125; from '@sentry/integrations';Sentry.init(&#123; dsn: 'http://7b4af4c05ee84328a2497b4493bacc74@localhost:9000/3', // 创建项目后会生成 dsn integrations: [new VueIntegration(&#123;Vue, attachProps: true&#125;)],&#125;); 2. 重新生成 token 并修改 .sentryclirc 文件[defaults]url=http://localhost:9000org=sentryproject=vue-exception-monitor[auth]token=037bf45801df4404b410dcc224768c907d5f09f1d9b8496e9228507371bd105d 然后重新部署 Vue 项目，测试一下： 可以看到我们本地部署的 Sentry 服务，也能帮我们收集异常了。完美 ~~","categories":[{"name":"前端","slug":"front-end","permalink":"https://haohaio.github.io/categories/front-end/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://haohaio.github.io/tags/Web/"}]},{"title":"[JavaScript LeetCode]66. 加一","slug":"leetcode-plus-one","date":"2020-04-21T15:16:57.000Z","updated":"2020-04-21T15:50:58.973Z","comments":true,"path":"data-structure/leetcode-plus-one.html","link":"","permalink":"https://haohaio.github.io/data-structure/leetcode-plus-one.html","excerpt":"","text":"给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。 最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。 你可以假设除了整数 0 之外，这个整数不会以零开头。 示例: 输入: [1,2,3]输出: [1,2,4]解释: 输入数组表示数字 123。输入: [4,3,2,1]输出: [4,3,2,2]解释: 输入数组表示数字 4321。 解法var plusOne = function (digits) &#123; const len = digits.length; for (let i = len - 1; i &gt;= 0; i--) &#123; digits[i]++; // 除10取余 digits[i] %= 10; // 不等于0，即没有进位，不再继续遍历，返回数组即可。（499 -&gt; 500） if (digits[i] !== 0) return digits; &#125; // 循环结束还没有返回时，则意味着数组中全部数字都为9。（999 -&gt; 1000） digits.shift(1); return digits;&#125;;","categories":[{"name":"数据结构","slug":"data-structure","permalink":"https://haohaio.github.io/categories/data-structure/"}],"tags":[{"name":"LeetCode","slug":"leetcode","permalink":"https://haohaio.github.io/tags/leetcode/"}]},{"title":"[JavaScript LeetCode]58. 最后一个单词的长度","slug":"leetcode-length-of-last-word","date":"2020-04-21T14:47:11.000Z","updated":"2020-04-21T15:51:03.463Z","comments":true,"path":"data-structure/leetcode-length-of-last-word.html","link":"","permalink":"https://haohaio.github.io/data-structure/leetcode-length-of-last-word.html","excerpt":"","text":"给定一个仅包含大小写字母和空格 ‘ ‘ 的字符串 s，返回其最后一个单词的长度。如果字符串从左向右滚动显示，那么最后一个单词就是最后出现的单词。 如果不存在最后一个单词，请返回 0 。 说明：一个单词是指仅由字母组成、不包含任何空格字符的 最大子字符串。 示例: 输入: &quot;Hello World&quot;输出: 5 解法一由于存在字符串末位存在空格的情况，可以使用 trim() 方法去除首尾空格，然后找到最后一个空格的下标即可。 var lengthOfLastWord = function (s) &#123; s = s.trim(); return s.length - 1 - s.lastIndexOf(\" \");&#125;; 解法二不使用 JavaScript 提供的便捷方法，使用纯算法实现。 var lengthOfLastWord = function (s) &#123; // \b最后一个单词的末位下标 let end = s.length - 1; // 逆序遍历，若字符串末尾又空格，则最后一个单词的末位下标向前移动 while (end &gt;= 0 &amp;&amp; s[end] === \" \") end--; if (end &lt; 0) return 0; // \b最后一个单词的首位下标 let start = end; // 逆序遍历，找到空格或到字符串首位为止 while (start &gt;= 0 &amp;&amp; s[start] !== \" \") start--; return end - start;&#125;;","categories":[{"name":"数据结构","slug":"data-structure","permalink":"https://haohaio.github.io/categories/data-structure/"}],"tags":[{"name":"LeetCode","slug":"leetcode","permalink":"https://haohaio.github.io/tags/leetcode/"}]},{"title":"[JavaScript LeetCode]38. 外观数列","slug":"leetcode-count-and-say","date":"2020-04-20T03:23:37.000Z","updated":"2020-04-21T15:50:49.679Z","comments":true,"path":"data-structure/leetcode-count-and-say.html","link":"","permalink":"https://haohaio.github.io/data-structure/leetcode-count-and-say.html","excerpt":"","text":"原题链接 「外观数列」是一个整数序列，从数字 1 开始，序列中的每一项都是对前一项的描述。前五项如下： 1. 12. 113. 214. 12115. 111221 1 被读作 &quot;one 1&quot; (&quot;一个一&quot;) , 即 11。11 被读作 &quot;two 1s&quot; (&quot;两个一&quot;）, 即 21。21 被读作 &quot;one 2&quot;, &quot;one 1&quot; （&quot;一个二&quot; , &quot;一个一&quot;) , 即 1211。 给定一个正整数 n（1 ≤ n ≤ 30），输出外观数列的第 n 项。 示例输入: 1输出: &quot;1&quot;解释：这是一个基本样例。输入: 4输出: &quot;1211&quot;解释：当 n = 3 时，序列是 &quot;21&quot;，其中我们有 &quot;2&quot; 和 &quot;1&quot; 两组，&quot;2&quot; 可以读作 &quot;12&quot;，也就是出现频次 = 1 而 值 = 2；类似 &quot;1&quot; 可以读作 &quot;11&quot;。所以答案是 &quot;12&quot; 和 &quot;11&quot; 组合在一起，也就是 &quot;1211&quot;。 解法通过正则匹配连续出现的数字，进行累加。下面正则中的 \\1 表示正则前面第一个括号内匹配到的字符串。 var countAndSay = function (n) &#123; let str = '1' for (let i = 1; i &lt; n; i++) &#123; str = str.replace(/(\\d)\\1*/g, item =&gt; `$&#123;item.length&#125;$&#123;item[0]&#125;`) &#125; return str&#125;;","categories":[{"name":"数据结构","slug":"data-structure","permalink":"https://haohaio.github.io/categories/data-structure/"}],"tags":[{"name":"LeetCode","slug":"leetcode","permalink":"https://haohaio.github.io/tags/leetcode/"}]},{"title":"如何在 JavaScript 中使用正则表达式","slug":"javascript-regex","date":"2020-04-17T17:13:08.000Z","updated":"2020-04-17T17:18:08.512Z","comments":true,"path":"front-end/javascript-regex.html","link":"","permalink":"https://haohaio.github.io/front-end/javascript-regex.html","excerpt":"","text":"之前我们已经了解了如何写正则表达式，今天就来具体了解一下正则表达式在 JavaScript 中的使用。 正则表达式的创建在 JavaScript 中，正则表达式就是 RegExp 对象。有两种方法来创建正则表达式，一种是使用字面量创建，另一种是使用 RegExp 构造函数来创建了一个正则表达式对象。 // 使用字面量创建正则表达式var regex = /ab+c/i;regex instanceof RegExp; // true// 使用 `RegExp` 构造函数创建正则表达式var regex = new RegExp(\"ab+c\", \"i\");var regex = new RegExp(/ab+c/, \"i\"); 两种创建方式对于结果来说，没什么区别。所以一般我们都是语法采用更为简单的字面量创建方法。 RegExp 方法test()test() 方法用来测试当前正则是否能匹配目标字符串。 直接举个栗子看一下： var regex = /ab+c/i;regex.test(\"Abbc\"); // true 有一点需要注意的是，如果正则表达式设置了全局搜索，test() 的执行会改变正则表达式 lastIndex 属性。连续的执行 test() 方法，后续的执行将会从 lastIndex 处开始匹配字符串，来看下栗子： var regex = /foo/g;// regex.lastIndex is at 0regex.test(\"foo\"); // true// regex.lastIndex is now at 3regex.test(\"foo\"); // false exec()exec 方法用来在目标字符串中执行一次正则匹配操作。返回一个结果数组或 null。 var url = \"https://www.google.com/\";var regex = /[^.]+/;console.log(regex.exec(url)); // [\"https://www\", index: 0, input: \"https://www.google.com/\", groups: undefined] 和 test() 方法一样，当表达式设置了全局搜索时，exec() 的执行也会改变正则表达式 lastIndex 属性。使用此特性，exec() 可用来对单个字符串中的多次匹配结果进行逐条的遍历。还是直接看个栗子： var url = \"https://www.google.com/\";var regex = /[^.]+/g;var arr;while ((arr = regex.exec(url)) !== null) &#123; console.log(`Found $&#123;arr[0]&#125; Next starts at $&#123;regex.lastIndex&#125;.`);&#125;// Found https://www Next starts at 11.// Found google Next starts at 18.// Found com/ Next starts at 23. 字符串相关正则方法match()在上一篇文章中，我们已经多次使用 match() 方法了，这里我们再说一下。 使用字符串的 match() 方法时，如果未使用 g 标志，则仅返回第一个完整匹配及其相关的结果数组。如果正则使用了 g 标志，则将返回与完整正则表达式匹配的所有结果。 search()使用字符串的 search() 方法，会返回匹配到的第一个字符串起始位置的下标（无论是否使用了 g 标志）： var url = \"https://www.google.com/\";var regex = /[^.]+/;console.log(url.search(regex)); // [\"https://www\", index: 0, input: \"https://www.google.com/\", groups: undefined] split()我们经常使用 split() 方法来分割字符串，其实我们也可以传入一个正则表达式作为参数，来分割字符串： var classNameStr = `container user-info flex-container`;var regex = /\\s+/;var classNames = classNameStr.split(regex);console.log(classNames); // [\"container\", \"user-info\", \"flex-container\"] replace()我们在开发中会使用 replace() 方法来替换字符串中子串，先来看看语法： str.replace(regexp|subStr, newSubStr|function) 接下里看个栗子，使用空字符串替换非数字和空格的字符： var str = \"- -The car parked in the garage.@123\";var regex = /[^A-Za-z\\s]/g;str = str.replace(regex, \"\");console.log(str); // The car parked in the garage 最后看一下 replace() 方法第二个参数为函数的情况。 先看一下该函数的参数： 变量名 代表值 match 匹配的子串 p1,p2, ... 假如 replace() 方法的第一个参数是一个 RegExp 对象，则代表第 n 个括号匹配的字符串。例如，如果是用 /(\\a+)(\\b+)/ 这个来匹配，p1 就是匹配的 \\a+，p2 就是匹配的 \\b+。 offset 匹配到的子字符串在原字符串中的偏量。 string 被匹配的原字符串。 接下来看个栗子吧： var str = '&lt;div&gt;&#123;&#123; name &#125;&#125;&lt;/div&gt;'var regex = /\\&#123;\\&#123;\\s*(.+?)\\s*\\&#125;\\&#125;/str.replace(regex, (...args) =&gt; &#123; console.log(args)&#125;)// [\"&#123;&#123; name &#125;&#125;\", \"name\", 5, \"&lt;div&gt;&#123;&#123; name &#125;&#125;&lt;/div&gt;\"] 可以看到 args 中第以个元素 是匹配到的子串，args 中第二个元素 name 就是 (.+?) 匹配到的内容。 接下来我们我们可以简单模拟一下 Vue 中的模板解析功能： var data = &#123; name: 'haohaio'&#125;;var str = '&lt;div&gt;&#123;&#123; name &#125;&#125;&lt;/div&gt;';var regex = /\\&#123;\\&#123;\\s?(.+?)\\s?\\&#125;\\&#125;/str = str.replace(regex, (...args) =&gt; &#123; return data[args[1]]&#125;);console.log(str); // &lt;div&gt;haohaio&lt;/div&gt; replace() 方法参数中的正则如果使用了 g 标志，那么函数将会多次调用： var data = &#123; name: 'haohaio', age: 28&#125;;var str = '&lt;div&gt;&#123;&#123; name &#125;&#125; - &#123;&#123; age &#125;&#125;&lt;/div&gt;';var regex = /\\&#123;\\&#123;\\s*(.+?)\\s*\\&#125;\\&#125;/g;str = str.replace(regex, (...args) =&gt; &#123; return data[args[1]]&#125;);console.log(str); // &lt;div&gt;haohaio - 28&lt;/div&gt; 小结正则表达式在我们的开发过程中，还是很重要的。本篇文章介绍的 JavaScript 中的一些常用方法，一定要掌握哦 ~~","categories":[{"name":"前端","slug":"front-end","permalink":"https://haohaio.github.io/categories/front-end/"}],"tags":[{"name":"JavaScript","slug":"javascript","permalink":"https://haohaio.github.io/tags/javascript/"}]},{"title":"正则表达式","slug":"regex","date":"2020-04-17T02:58:08.000Z","updated":"2020-04-17T17:18:00.943Z","comments":true,"path":"front-end/regex.html","link":"","permalink":"https://haohaio.github.io/front-end/regex.html","excerpt":"","text":"我们在开发过程中经常会用到正则表达式，比如输入校验，比如字符串替换等。可能许多人包括我自己，需要正则表达式的时候都是到到网上去找一个满足我们要求的正则就行了，但真让我们自己写正则的话还是有些困难的。今天就来系统的学习一下正则表达式，今后当需要我们手写正则的时候，自己也能码出来~~ 正则表达式是一组由字母和符号组成的特殊文本，它可以用来从文本中找出满足你想要的格式的句子。 基本匹配例如：一个正则表达式 the，它表示一个规则：由字母 t 开始，接着是 h，再接着是 e。 在 JavaScript 中，我们可以使用字符串的 match 方法来查找要匹配字符串： var str = \"The fat cat sat on the mat.\";var regex = /the/;var res = str.match(regex);console.log(res); // [\"the\", index: 19, input: \"The fat cat sat on the mat.\", groups: undefined] 可以看到正则表达式是大小写敏感的，不会匹配到字符串开头的 The，而是匹配到后面的 the。 元字符正则表达式主要依赖于元字符。 元字符不代表他们本身的字面意思，他们都有特殊的含义。一些元字符写在方括号中的时候有一些特殊的意思。以下是一些元字符的介绍： 元字符 描述 . 匹配任意单个字符除了换行符。 [ ] 字符种类。匹配方括号内的任意字符。 [^ ] 否定的字符种类。匹配除了方括号里的任意字符 * 匹配&gt;=0 个重复的在*号之前的字符。 + 匹配&gt;=1 个重复的+号前的字符。 ? 标记?之前的字符为可选。 {n,m} 匹配 num 个大括号之前的字符或字符集 (n &lt;= num &lt;= m)。 (xyz) 字符集，匹配与 xyz 完全相等的字符串。 &#124; 或运算符，匹配符号前或后的字符。 &#92; 转义字符,用于匹配一些保留的字符 { } . * + ? ^ \\$ \\ &#124; ^ 从开始行开始匹配。 \\$ 从末端开始匹配。 点运算符 .. 匹配任意单个字符，但不匹配换行符。 例如，表达式 .at 匹配一个任意字符后面跟着是 a 和 t 的字符串。 var str = \"The car parked in the garage.\";var regex = /.ar/;var res = str.match(regex);console.log(res); // [\"car\", index: 4, input: \"The car parked in the garage.\", groups: undefined] 表达式不设置全部搜索, 即使用修饰符 g 时，匹配到第一个字符串后就会停止匹配。 字符集 []字符集也叫做字符类。 方括号用来指定一个字符集。在方括号中的字符集不关心顺序。 例如，表达式[Tt]he 匹配 the 和 The： var str = \"The car parked in the garage.\";var regex = /[Tt]he/g;var res = str.match(regex);console.log(res); // [\"The\", \"the\"] 在方括号中使用连字符来指定字符集的范围。 例如：[A-Za-z]he 匹配任意英文字母后接着是 h，再接着是 e。 var str = \"The car parked in the garage.\";var regex = /[A-Za-z]he/g;var res = str.match(regex);console.log(res); // [\"The\", \"the\"] 方括号中的 . 就表示 . 字符，ar[.] 就是单纯的匹配 ar. 字符串。 var str = \"A garage is a good place to park a car.\";var regex = /ar[.]/g;var res = str.match(regex);console.log(res); // [\"ar.\"] 否定字符集 [^ ]^ 用在方括号的开头时，它表示这个字符集是否定的。 例如，表达式 [^c]ar 匹配一个后面跟着 ar 的除了 c 的任意字符。 var str = \"The car parked in the garage.\";var regex = /[^c]ar/g;var res = str.match(regex);console.log(res); // [\"par\", \"gar\"] 举一个常见的栗子，使用字符串的 replace 方法，去除字符串中的非英文字符： var str = \"The car parked in the garage.@123\";var regex = /[^A-Za-z]/g;str = str.replace(regex, \"\");console.log(str); // Thecarparkedinthegarage 重复次数* 号* 号匹配 在 * 之前的字符出现 大于等于0 次。例如，表达式 a* 匹配 0 或更多个以 a 开头的字符。表达式[a-z]* 匹配一个行中所有以小写字母开头的字符串。 var str = \"The car parked in the garage.\";var regex = /[a-z]*/g;var res = str.match(regex);console.log(res); // [\"\", \"he\", \"\", \"car\", \"\", \"parked\", \"\", \"in\", \"\", \"the\", \"\", \"garage\", \"\", \"\"] * 字符和 . 字符搭配可以匹配所有的字符 .*。 * 和表示匹配空格的符号 \\s 连起来用，如表达式 \\s*cat\\s* 匹配 0 或更多个空格开头和 0 或更多个空格结尾的 cat 字符串。 var str = \"The fat cat sat on the concatenation.\";var regex = /\\s*cat\\s*/g;var res = str.match(regex);console.log(res); // [\" cat \", \"cat\"] + 号+号匹配+号之前的字符出现 &gt;=1 次。 例如表达式c.+t 匹配以首字母c开头以t结尾，中间跟着至少一个字符的字符串。 var str = \"The fat cat sat on the mat.\";var regex = /c.+t/g;var res = str.match(regex);console.log(res); // [\"cat sat on the mat\"] ? 号在正则表达式中元字符 ? 标记在符号前面的字符为可选，即出现 0 或 1 次。 例如，表达式 [T]?he 匹配字符串 he 和 The： var str = \"The fat cat sat on the mat.\";var regex = /[T]?he/g;var res = str.match(regex);console.log(res); // [\"The\", \"he\"] 可以看到 * 号是匹配 0 个或多个，? 号是匹配 0 个或 1 个。 {} 号在正则表达式中 {} 是一个量词，常用来限定一个或一组字符可以重复出现的次数。 例如， 表达式 [0-9]{2,3} 匹配最少 2 位最多 3 位 0~9 的数字： var str = \"The number was 9.9997 but we rounded it off to 10.0.\";var regex = /[0-9]&#123;2,3&#125;/g;var res = str.match(regex);console.log(res); // [\"999\", \"10\"] 我们可以省略第二个参数。 例如，[0-9]{2,} 匹配至少两位 0~9 的数字。 var str = \"The number was 9.9997 but we rounded it off to 10.0.\";var regex = /[0-9]&#123;2,&#125;/g;var res = str.match(regex);console.log(res); // [\"9997\", \"10\"] 如果逗号也省略掉则表示重复固定的次数。例如，[0-9]{2} 匹配 2 位数字： var str = \"The number was 9.9997 but we rounded it off to 10.0.\";var regex = /[0-9]&#123;2&#125;/g;var res = str.match(regex);console.log(res); // [\"99\", \"97\", \"10\"] (...) 特征标群(...) 小括号中包含的内容将会被看成一个整体。 例如, 表达式 (ab)* 匹配连续出现 0 或更多个 ab。如果没有使用 (...) ，那么表达式 ab* 将匹配 a 后面连续出现 0 或更多个 b： var str = \"ab abbb abab\";var regex = /(ab)*/g;var res = str.match(regex);console.log(res); // [\"ab\", \"\", \"ab\", \"\", \"\", \"\", \"abab\", \"\"]var str = \"ab abbb abab\";var regex = /ab*/g;var res = str.match(regex);console.log(res); // [\"ab\", \"abbb\", \"ab\", \"ab\"] 我们还可以在 () 中用或字符 | 表示或。例如，(c|g|p)ar 匹配 car 或 gar 或 par： var str = \"The car is parked in the garage.\";var regex = /(c|g|p)ar/g;var res = str.match(regex);console.log(res); // [\"car\", \"par\", \"gar\"] | 或运算符或运算符就表示或，用作判断条件。 例如 (T|t)he|car 匹配 (T|t)he 或 car： var str = \"The car is parked in the garage.\";var regex = /(T|t)he|car/g;var res = str.match(regex);console.log(res); // [\"The\", \"car\", \"the\"] 转码特殊字符反斜线 \\ 在表达式中用于转码紧跟其后的字符。用于指定 { } [ ] / \\ + * . $ ^ | ? 这些特殊字符。如果想要匹配这些特殊字符则要在其前面加上反斜线 \\。 例如 . 是用来匹配除换行符外的所有字符的。如果想要匹配句子中的 . 则要写成 \\.： var str = \"The fat cat sat on the mat.\";var regex = /(f|c|m)at\\.?/g;var res = str.match(regex);console.log(res); // [\"fat\", \"cat\", \"mat.\"] 锚点在正则表达式中，想要匹配指定开头或结尾的字符串就要使用到锚点。^ 指定开头，$ 指定结尾。 var str = \"The car is parked in the garage.\";var regex = /^(T|t)he/g;var res = str.match(regex);console.log(res); // [\"The\"]var str = \"The car is parked in the garage.\";var regex = /^the/g;var res = str.match(regex);console.log(res); // null var str = \"The fat cat. sat. on the mat.\";var regex = /(at\\.)$/g;var res = str.match(regex);console.log(res); // [\"at.\"] 简写字符集正则表达式提供一些常用的字符集简写。如下: 简写 描述 . 除换行符外的所有字符 \\w 匹配所有字母数字和下划线 _，等同于 [a-zA-Z0-9_] \\W 匹配所有非字母数字，即符号，等同于： [^\\w] \\d 匹配数字： [0-9] \\D 匹配非数字： [^\\d] \\s 匹配所有空格字符，等同于： [\\t\\n\\f\\r\\p{Z}] \\S 匹配所有非空格字符： [^\\s] \\f 匹配一个换页符 \\n 匹配一个换行符 \\r 匹配一个回车符 \\t 匹配一个制表符 \\v 匹配一个垂直制表符 \\p 匹配 CR/LF（等同于 \\r\\n），用来匹配 DOS 行终止符 \\w 会匹配到 _，一般我们匹配所有字母数字时，会使用[a-zA-Z0-9] var str = \"123_\";var regex = /\\w/g;var res = str.match(regex);console.log(res); // [\"at.\"] 零宽度断言（前后预查）?=... 正先行断言?=... 正先行断言，表示第一部分表达式之后必须跟着 ?=...定义的表达式。返回结果只包含满足匹配条件的第一部分表达式。定义一个正先行断言要使用 ()。在括号内部使用一个问号和等号： (?=...)。 举个栗子理解一下，(T|t)he(?=\\sfat) 表示匹配 The 和 the 后面紧跟着 (空格)fat： var str = \"The fat cat sat on the mat.\";var regex = /(T|t)he(?=\\sfat)/g;var res = str.match(regex);console.log(res); // [\"The\"] ?!... 负先行断言负先行断言 ?! 用于筛选所有匹配结果，筛选条件为 其后不跟随着断言中定义的格式。 举个栗子理解一下，(T|t)he(?!\\sfat) 表示匹配 The 和 the 后面不跟着 (空格)fat： var str = \"The fat cat sat on the mat.\";var regex = /(T|t)he(?!\\sfat)/g;var res = str.match(regex);console.log(res); // [\"the\"] ?&lt;= ... 正后发断言正后发断言 记作(?&lt;=...) 用于筛选所有匹配结果，筛选条件为其前跟随着断言中定义的格式。 举个栗子理解一下，表达式 (?&lt;=(T|t)he\\s)(fat|mat) 匹配 fat 和 mat，且其前跟着 The 或 the： var str = \"The fat cat sat on the mat.\";var regex = /(?&lt;=(T|t)he\\s)(fat|mat)/g;var res = str.match(regex);console.log(res); // [\"fat\", \"mat\"] ?&lt;!... 负后发断言负后发断言 记作 (?&lt;!...) 用于筛选所有匹配结果，筛选条件为 其前不跟随着断言中定义的格式。 var str = \"The cat sat on cat.\";var regex = /(?&lt;!(T|t)he\\s)(cat)/g;var res = str.match(regex);console.log(res); // [\"cat\"] 标志标志也叫模式修正符，因为它可以用来修改表达式的搜索结果。 这些标志可以任意的组合使用，它也是整个正则表达式的一部分。 标志 描述 i 忽略大小写。 g 全局搜索。 m 多行修饰符：锚点元字符 ^ $ 工作范围在每行的起始。 忽略大小写 ig 我们前面已经一直在用了，看下和 i 组合一起使用吧： var str = \"The fat cat sat on the mat.\";var regex = /The/gi;var res = str.match(regex);console.log(res); // [\"The\", \"the\"] 多行修饰符 m像之前介绍的 (^,$) 用于检查格式是否是在待检测字符串的开头或结尾。但我们如果想要它在每行的开头和结尾生效，我们需要用到多行修饰符 m。 var str = `The fat cat sat on the mat.`;var regex = /.at(.)?$/;var res = str.match(regex);console.log(res); // [\"mat.\"]var regex = /.at(.)?$/;var res = str.match(regex);console.log(res); // [\"fat\", \"sat\", \"mat.\"] 贪婪匹配与惰性匹配正则表达式默认采用贪婪匹配模式，在该模式下意味着会匹配尽可能长的子串。我们可以使用 ? 将贪婪匹配模式转化为惰性匹配模式。 var str = \"The fat cat sat on the mat.\";var regex = /(.*at)/g;var res = str.match(regex);console.log(res); // [\"The fat cat sat on the mat\"]var regex = /(.*?at)/g;var res = str.match(regex);console.log(res); // [\"The fat\", \" cat\", \" sat\", \" on the mat\"] 练习接下来我们来练习写一下我们经常会用到的正则吧。 正整数正整数的规则很简单，前面有 0 个或 1 个 + 号，因此我们可以用 ? 号 或 {0, 1} 进行校验；此外匹配 + 号时，需要使用 \\ 进行转义。后面至少有一个 0-9 的数字，因此我们可以用 [0-9]+ 或 \\d+ 来进行表示，接下来我们写一个校验是否是正整数的方法，方便进行测试： function isPositiveInteger(str) &#123; let regex = /^\\+?\\d+$/; return regex.test(str);&#125;isPositiveInteger(\"3\"); // trueisPositiveInteger(\"+3\"); // trueisPositiveInteger(\"+3a\"); // false 是不是 so easy ~~ 手机号现在的手机号都是以 1 开头，第二位可以是 3-9 的数字，后面是 9 位数字，接下来我们就自己码一下，写一个校验手机号的方法： function isMobile(str) &#123; let regex = /^1[3-9]\\d&#123;9&#125;$/; return regex.test(str);&#125;isMobile(\"18123456789\"); // trueisMobile(\"12123456789\"); // falseisMobile(\"181234567890\"); // false 没什么问题 ~~ 身份证号接下来我们在来写一下身份证号的正则，身份证一共 18 位，首位是 1-9 的数字，2-6 位是 0-9 的数字，7-14 位是出生日期，15-17 位是 0-9 的数字，末位是 0-9 的数字或 x。需要注意的是我们还需要校验一下出生日期格式。 这里我们只对出生日期做一下简单校验，就不做月份对应日期的相关校验了。具体规则为：出生日期年份为 18|19|20 开头，后两位为 0-9 的数字，正则可以写成 (18|19|20)\\d{2}。月份为 01-12，正则可以写成 (0[1-9])|(1[0-2])，日期为 0-31, 正则可以写成 (([0-2][1-9])|10|20|30|31) function isIdCard(str) &#123; let regex = /^[1-9]\\d&#123;5&#125;(18|19|20)\\d&#123;2&#125;(0[1-9])|(1[0-2])(([0-2][1-9])|10|20|30|31)\\d&#123;3&#125;[0-9Xx]$/; return regex.test(str);&#125;isIdCard(\"41112319921008111x\"); // trueisIdCard(\"41112319921032111x\"); // falseisIdCard(\"411123199210011111x\"); // false 验证一下，搞定 ~~","categories":[{"name":"前端","slug":"front-end","permalink":"https://haohaio.github.io/categories/front-end/"}],"tags":[{"name":"JavaScript","slug":"javascript","permalink":"https://haohaio.github.io/tags/javascript/"}]},{"title":"[JavaScript LeetCode]53. 最大子序和","slug":"leetcode-maximum-subarray","date":"2020-04-15T15:33:49.000Z","updated":"2020-06-22T01:05:10.302Z","comments":true,"path":"data-structure/leetcode-maximum-subarray.html","link":"","permalink":"https://haohaio.github.io/data-structure/leetcode-maximum-subarray.html","excerpt":"","text":"原题链接 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 示例： 输入: [-2,1,-3,4,-1,2,1,-5,4],输出: 6解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。 解法一暴力求解，直接列出所有情况的子数组和进行比较。 var maxSubArray = function (nums) &#123; let len = nums.length; let maxSum = -Infinity; for (let i = 0; i &lt; len; i++) &#123; for (let j = i; j &lt; len; j++) &#123; let thisSum = 0; for (let k = i; k &lt;= j; k++) &#123; thisSum += nums[k]; &#125; maxSum = Math.max(thisSum, maxSum); &#125; &#125; return maxSum;&#125;; 三层 for 循环，很明显时间复杂度为 O(n3)。这种解法在 leetcode 判断会超出时间限制。 解法二对解法一进行优化。在第三层 for 循环计算子数组和时，对于相同的 i, 不同的 j，只要在 j - 1 次循环的基础上累加一项即可。因此，可以将三层 for 循环去掉。时间复杂度为 O(n2) var maxSubArray = function (nums) &#123; let len = nums.length; let maxSum = nums[0]; for (let i = 1; i &lt; len; i++) &#123; let thisSum = maxSum; for (let j = i; j &lt; len; j++) &#123; thisSum += nums[j]; maxSum = Math.max(thisSum, maxSum); &#125; &#125; return maxSum;&#125;; 解法三这道题可以用动态规划的思路来解决： 首先对数组进行遍历，当前最大连续子序列和为 thisSum，结果为 maxSum 如果 thisSum &gt; 0，则说明 thisSum 对结果有增益效果(thisSum + num &gt; num)，则 thisSum 保留并加上当前遍历数字 如果 thisSum &lt;= 0，则说明 thisSum 对结果无增益效果(thisSum + num &lt;= num)，需要舍弃，则 thisSum 直接更新为当前遍历数字 每次比较 thisSum 和 maxSum 的大小，将最大值置为 maxSum，遍历结束返回结果 时间复杂度：O(n) var maxSubArray = function (nums) &#123; let maxSum = nums[0]; let thisSum = 0; for (const num of nums) &#123; if (thisSum &gt; 0) &#123; thisSum += num; &#125; else &#123; thisSum = num; &#125; maxSum = Math.max(sum, maxSum); &#125; return maxSum;&#125;; 解法四看下官方题解，用 Math.max() 方法简化了判断 sum 是否大于 0 的过程，看起来更简洁一些： var maxSubArray = function (nums) &#123; let len = nums.length; let maxSum = nums[0]; let pre = 0; nums.forEach(num =&gt; &#123; pre = Math.max(pre + num, num); maxSum = Math.max(pre, maxSum) &#125;) return maxSum;&#125;","categories":[{"name":"数据结构","slug":"data-structure","permalink":"https://haohaio.github.io/categories/data-structure/"}],"tags":[{"name":"LeetCode","slug":"leetcode","permalink":"https://haohaio.github.io/tags/leetcode/"}]},{"title":"ES6 之 Iterator","slug":"iterator","date":"2020-04-15T06:47:08.000Z","updated":"2020-04-15T15:20:48.170Z","comments":true,"path":"front-end/javascript-iterator.html","link":"","permalink":"https://haohaio.github.io/front-end/javascript-iterator.html","excerpt":"","text":"ES6 新增了一个数据类型：Symbol，我们可以用它定义一个独一无二的值。此外，ES6 还提供了 11 个内置的 Symbol 值，其中有一个值 Symbol.iterator， 它可以作为对象的属性来使用，我们可以在对象该属性上添加一个迭代器函数，对象就可以完成遍历操作了，今天我们就来详细了解一下。 先来简单看一下代码： const obj = &#123; data: [\"hello\", \"world\"], [Symbol.iterator]: function () &#123; const self = this; let index = 0; return &#123; next: function () &#123; if (index &lt; self.data.length) &#123; return &#123; value: self.data[index++], done: false, &#125;; &#125; else &#123; return &#123; value: undefined, done: true &#125;; &#125; &#125;, &#125;; &#125;,&#125;; 上面代码中，对象 obj 具有 Symbol.iterator 属性, 该属性对应的值，是一个函数，执行这个函数就会返回一个迭代器对象，该对象的根本特征就是具有 next 方法，每次调用 next 方法，都会返回返回一个对象，表示当前数据成员的信息。这个对象具有 value 和 done 两个属性，value 属性返回当前位置的成员，done 属性是一个布尔值，表示遍历是否结束，即是否还有必要再一次调用 next 方法。 ES6 新增了 for...of 方法来进行遍历，Iterator 主要就是为 for...of 服务的，我们可以用 for...of 遍历一下上面我们的定义的 obj 对象看一下： for (let item of obj) &#123; console.log(item);&#125;// hello// world 可以看到我们给 obj 对象定义了 Symbol.iterator 属性，并实现了迭代器函数后，它就可以进行遍历了。 done: false 和 value: undefined 属性都是可以省略的。 默认 Iterator 接口Iterator 可以说是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署 Iterator 接口，就可以完成遍历操作。 ES6 规定，默认的 Iterator 接口部署在数据结构的 Symbol.iterator 属性，或者说，一个数据结构只要具有 Symbol.iterator 属性，就可以认为是“可遍历的”。 ES6 的一些数据结构原生具备了 Iterator 接口：Array、Map、Set、String、TypedArray、函数的 arguments 对象、NodeList 对象。 我们可以看一下数组的 Symbol.iterator 属性 let arr = [\"a\", \"b\", \"c\"];let iter = arr[Symbol.iterator]();iter.next(); // &#123; value: 'a', done: false &#125;iter.next(); // &#123; value: 'b', done: false &#125;iter.next(); // &#123; value: 'c', done: false &#125;iter.next(); // &#123; value: undefined, done: true &#125; 基于此，我们可以给类似数组的对象的 Symbol.iterator 属性，赋值为数组的 Symbol.iterator，来让其可以遍历： let iterable = &#123; 0: \"a\", 1: \"b\", 2: \"c\", length: 3, [Symbol.iterator]: Array.prototype[Symbol.iterator],&#125;;for (let item of iterable) &#123; console.log(item);&#125;// a// b// c 但是，为普通对象部署数组的 Symbol.iterator 方法，并无效果： let iterable = &#123; a: \"a\", b: \"b\", c: \"c\", length: 3, [Symbol.iterator]: Array.prototype[Symbol.iterator],&#125;;for (let item of iterable) &#123; console.log(item);&#125;// undefined// undefined// undefined 调用 Iterator 接口的场合解构赋值let set = new Set([\"a\", \"b\", \"c\"]);let [x, y] = set; // // x='a'; y='b'let [first, ...rest] = set; // first='a'; rest=['b','c']; 扩展运算符let str = \"hello\";[...str]; // [\"h\", \"e\", \"l\", \"l\", \"o\"]let arr = [\"b\", \"c\"];[\"a\", ...arr, \"d\"]; // ['a', 'b', 'c', 'd'] yield*Generator 函数中的 yield* 后面跟的是一个可遍历的结构，它会调用该结构的迭代器接口。 let generator = function* () &#123; yield 1; yield* [2, 3]; yield 4;&#125;;let iterator = generator();iterator.next(); // &#123; value: 1, done: false &#125;iterator.next(); // &#123; value: 2, done: false &#125;iterator.next(); // &#123; value: 3, done: false &#125;iterator.next(); // &#123; value: 4, done: false &#125;iterator.next(); // &#123; value: undefined, done: true &#125; 其他场合由于数组的遍历会调用迭代器接口，所以任何接受数组作为参数的场合，其实都调用了迭代器接口。比如：for...of、Array.from()、Map()、Set()、Promise.all()、Promise.race() 等。 迭代器对象的 return()，throw()迭代器对象除了具有 next 方法，还可以具有 return 方法和 throw 方法。我们自己写迭代器对象生成函数时，那么 next 方法是必须部署的， return 方法和 throw 方法是否部署是可选的。 return 方法的使用场合是，如果 for...of 循环提前退出（通常是因为出错，或者有 break 语句），就会调用 return 方法。 function readLinesSync(file) &#123; return &#123; [Symbol.iterator]() &#123; return &#123; next() &#123; return &#123; done: false &#125;; &#125;, return() &#123; file.close(); return &#123; done: true &#125;; &#125;, &#125;; &#125;, &#125;;&#125;// 情况一for (let line of readLinesSync(fileName)) &#123; console.log(line); break;&#125;// 情况二for (let line of readLinesSync(fileName)) &#123; console.log(line); throw new Error();&#125; throw 方法主要是配合 Generator 函数使用。 for…of 循环ES6 新增了 for...of 方法来进行遍历，for...of 循环内部调用的是数据结构的 Symbol.iterator 方法。 数组数组原生具备 iterator 接口（即默认部署了 Symbol.iterator 属性），for…of 循环本质上就是调用这个接口产生的迭代器，可以用下面的代码证明： const arr = [\"red\", \"green\", \"blue\"];for (let v of arr) &#123; console.log(v); // red green blue&#125;const obj = &#123;&#125;;obj[Symbol.iterator] = arr[Symbol.iterator].bind(arr);for (let v of obj) &#123; console.log(v); // red green blue&#125; 上面代码中，空对象 obj 部署了数组 arr 的 Symbol.iterator 属性，结果 obj 的 for...of 循环，产生了与 arr 完全一样的结果。 for…in &amp; for…offor...in 循环读取键名，for...of 循环读取键值。 const arr = [\"a\", \"b\", \"c\", \"d\"];for (let a in arr) &#123; console.log(a); // 0 1 2 3&#125;for (let a of arr) &#123; console.log(a); // a b c d&#125; 如果要通过 for...of 循环，获取数组的索引，可以借助数组实例的 entries 方法和 keys 方法 const arr = [\"a\", \"b\"];for (let index of arr.keys()) &#123; console.log(index);&#125;// 0// 1for (let [index, elem] of arr.entries()) &#123; console.log(index, elem);&#125;// 0 \"a\"// 1 \"b\" Set 和 MapSet 和 Map 结构也原生具有 Iterator 接口，可以直接使用for...of循环。 var engines = new Set([\"Gecko\", \"Trident\", \"Webkit\", \"Webkit\"]);for (var e of engines) &#123; console.log(e);&#125;// Gecko// Trident// Webkitvar es6 = new Map();es6.set(\"edition\", 6);es6.set(\"committee\", \"TC39\");es6.set(\"standard\", \"ECMA-262\");for (var [name, value] of es6) &#123; console.log(name + \": \" + value);&#125;// edition: 6// committee: TC39// standard: ECMA-262 可以看到，Set 结构遍历时，返回的是一个值，Map 结构遍历时，返回的是一个数组。 计算生成的数据结构ES6 的数组、Set、Map 都部署了 keys、values 和 entries 方法，此外对象可以使用 Object.keys()、Object.values() 和 Object.entries() 来进行遍历。 let arr = [\"a\", \"b\", \"c\"];for (let pair of arr.entries()) &#123; console.log(pair);&#125;// [0, 'a']// [1, 'b']// [2, 'c']let obj = &#123; a: \"hello\", b: \"world\",&#125;;for (let [key, value] of Object.entries(obj)) &#123; console.log(key + \": \" + value);&#125;// a: hello// b: world 类似数组的对象类似数组的对象包括好几类。下面是 for...of 循环用于字符串、DOM NodeList 对象、arguments 对象的例子。 // 字符串let str = \"hello\";for (let s of str) &#123; console.log(s); // h e l l o&#125;// DOM NodeList对象let paras = document.querySelectorAll(\"p\");for (let p of paras) &#123; p.classList.add(\"test\");&#125;// arguments对象function printArgs() &#123; for (let x of arguments) &#123; console.log(x); &#125;&#125;printArgs(\"a\", \"b\");// 'a'// 'b' 并不是所有类似数组的对象都具有 Iterator 接口，一个简便的解决方法，就是使用 Array.from 方法将其转为数组。 let arrayLike = &#123; length: 2, 0: \"a\", 1: \"b\" &#125;;// 报错for (let x of arrayLike) &#123; console.log(x);&#125;// 正确for (let x of Array.from(arrayLike)) &#123; console.log(x);&#125; Iterator &amp; GeneratorSymbol.iterator 方法的最简单实现就是使用 Generator 函数： let myIterable = &#123; [Symbol.iterator]: function* () &#123; yield 1; yield 2; yield 3; &#125;,&#125;;[...myIterable]; // [1, 2, 3]// 或者采用下面的简洁写法let obj = &#123; *[Symbol.iterator]() &#123; yield \"hello\"; yield \"world\"; &#125;,&#125;;for (let x of obj) &#123; console.log(x);&#125;// \"hello\"// \"world\" 我们可以对 Generator 函数这样简单理解：其是一个分段执行的函数，yield 表达式是暂停执行的标记，而 next 方法可以恢复执行。return 表达式表示结束执行，如果没有 return 语句，就执行到函数结束。 执行 Generator 函数就会返回一个迭代器对象。我们可以通过代码再详细看一下： function* helloWorldGenerator() &#123; yield \"hello\"; yield \"world\"; return \"ending\";&#125;var hw = helloWorldGenerator();hw.next(); // &#123; value: 'hello', done: false &#125;hw.next(); // &#123; value: 'world', done: false &#125;hw.next(); // &#123; value: 'ending', done: true &#125;hw.next(); // &#123; value: undefined, done: true &#125; 此外，还有一个有趣的地方可以了解一下，Generator 函数执行后，返回一个迭代器对象。该对象本身也具有 Symbol.iterator 属性，执行后返回自身。 function* gen() &#123; yield \"hello\"; yield \"world\";&#125;let g = gen();g[Symbol.iterator]() === g; // true 所以，Generator 函数执行后，返回的迭代器对象，是可以直接遍历的： function* foo() &#123; yield 1; yield 2; yield 3; return 4; yield 5; yield 6;&#125;for (let v of foo()) &#123; console.log(v); // 1 2 3&#125; ES6 还提供了 yield* 表达式，在之前提到会调用迭代器接口的场景时，就提到了这个表达式。其作用就是用来在一个 Generator 函数里面执行另一个 Generator 函数。 function* foo() &#123; yield \"a\"; yield \"b\";&#125;function* bar() &#123; yield \"x\"; yield* foo(); yield \"y\";&#125;// 等同于function* bar() &#123; yield \"x\"; yield \"a\"; yield \"b\"; yield \"y\";&#125; 参考ECMAScript 6 入门 - Iterator 和 for…of 循环","categories":[{"name":"前端","slug":"front-end","permalink":"https://haohaio.github.io/categories/front-end/"}],"tags":[{"name":"JavaScript","slug":"javascript","permalink":"https://haohaio.github.io/tags/javascript/"}]},{"title":"常见手写函数实现","slug":"handwriting-function","date":"2020-04-13T00:57:07.000Z","updated":"2020-04-13T05:53:41.886Z","comments":true,"path":"front-end/handwriting-function.html","link":"","permalink":"https://haohaio.github.io/front-end/handwriting-function.html","excerpt":"","text":"applyFunction.prototype._apply = function (context = window, args = []) &#123; const fnKey = \"tmp_\" + Date.now(); context[fnKey] = this; const res = context[fnKey](...args); Reflect.deleteProperty(context, fnKey); return res;&#125;; callFunction.prototype._call = function (context = window, ...args) &#123; const fnKey = \"tmp_\" + Date.now(); context[fnKey] = this; const res = context[fnKey](...args); Reflect.deleteProperty(context, fnKey); return res;&#125;; bindFunction.prototype._bind = function (context = window, ...args) &#123; const self = this; return function () &#123; return self.apply(context, args); &#125;;&#125;; newfunction _new(fn, ...args) &#123; let obj = &#123;&#125;; obj.__proto__ = fn.prototype; let ret = fn.apply(obj, args); return ret instanceof Object ? ret : obj;&#125; 防抖function debounce(fn, delay) &#123; let timer = null; return function () &#123; timer &amp;&amp; clearTimeout(timer); timer = setTimeout(() =&gt; &#123; fn.apply(this, arguments); &#125;, delay); &#125;;&#125; 节流function throttle(fn, delay) &#123; let canRun = true; return function () &#123; if (!canRun) return; canRun = false; setTimeout(() =&gt; &#123; fn.apply(this, arguments); canRun = true; &#125;, delay); &#125;;&#125; 数值千分位let num = 2333333333333;num.toLocaleString(); // \"2,333,333,333,333\" let num = 2333333333333;num .toString() .split(\"\") .reverse() .reduce((acc, cur, idx) =&gt; &#123; return (idx % 3 ? cur : cur + \",\") + acc; &#125;); // \"2,333,333,333,333\" url 参数获取function getQuery() &#123; let searchParams = new URLSearchParams(location.search); let query = Object.fromEntries(searchParams); return query;&#125; function getQuery() &#123; const searchStr = location.search; if (!searchStr.startsWith(\"?\")) return null; let query = &#123;&#125;; searchStr .substring(1) .split(\"&amp;\") .forEach((item) =&gt; &#123; let queryItem = item.split(\"=\"); query[queryItem[0]] = queryItem[1]; &#125;); return query;&#125; flatfunction _flat(arr) &#123; while (arr.some((item) =&gt; Array.isArray(item))) &#123; arr = [].concat(...arr); &#125; return arr;&#125; function _flat(arr) &#123; return arr.reduce((acc, cur) =&gt; &#123; return Array.isArray(cur) ? [...acc, ..._flat(cur)] : [...acc, cur]; &#125;, []);&#125; function _flat(arr) &#123; return arr .join(\",\") .split(\",\") .map((item) =&gt; Number(item));&#125; 事件代理function delegate(ele, selector, type, fn) &#123; function callback(e) &#123; e = e || window.event; const target = e.target || e.srcElement; let selectors = ele.querySelectorAll(selector); selectors = [].slice.call(selectors); if (selectors.includes(target)) &#123; fn.call(target, e); &#125; &#125; ele.addEventListener(type, callback, false);&#125;delegate(document.querySelector(\"body\"), \"li\", \"click\", function () &#123; console.log(\"li 点击事件\");&#125;);","categories":[{"name":"前端","slug":"front-end","permalink":"https://haohaio.github.io/categories/front-end/"}],"tags":[{"name":"JavaScript","slug":"javascript","permalink":"https://haohaio.github.io/tags/javascript/"}]},{"title":"Promise 简单实现","slug":"promise","date":"2020-04-10T05:14:04.000Z","updated":"2020-04-10T16:10:26.679Z","comments":true,"path":"front-end/promise.html","link":"","permalink":"https://haohaio.github.io/front-end/promise.html","excerpt":"","text":"Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了 Promise 对象。 基本结构话不多说，我们先实现 Promise 的基本结构，我们需要注意以下几点： 构造函数 Promise 接受一个函数作为参数，该函数包含 resolve 和 reject 两个参数，它们是两个函数。 Promise 对象有三种状态：Pending(进行中)、Fulfilled(已成功)、Rejected(已失败)。状态只能由 Pending 变为 Fulfilled 或由 Pending 变为 Rejected ，且状态改变之后不会在发生变化，会一直保持这个状态。 resolve 方法将 Promise 对象的状态从 Pending 变为 Fulfilled。 reject 方法将 Promise 对象的状态从 Pending 变为 Rejected。 resolve 和 reject 都可以传入任意类型的值作为实参，表示 Promise 对象成功（Fulfilled）和失败（Rejected）的值 基于以上几点，我们实现代码如下： const isFunction = (variable) =&gt; typeof variable === \"function\";// 定义Promise的三种状态常量const PENDING = Symbol(\"PENDING\");const FULFILLED = Symbol(\"FULFILLED\");const REJECTED = Symbol(\"REJECTED\");class MyPromise &#123; constructor(handle) &#123; if (!isFunction(handle)) &#123; throw new Error(\"MyPromise must accept a function as a parameter\"); &#125; this._status = PENDING; this._value = undefined; // 执行handle try &#123; handle(this._resolve.bind(this), this._reject.bind(this)); &#125; catch (err) &#123; this._reject(err); &#125; &#125; // 添加 resolve 时执行的函数 _resolve(val) &#123; if (this._status !== PENDING) return; this._status = FULFILLED; this._value = val; &#125; // 添加reject时执行的函数 _reject(err) &#123; if (this._status !== PENDING) return; this._status = REJECTED; this._value = err; &#125;&#125; Promise 的 then 方法Promise 的核心就是 then 方法。接下来，基于以下几点我们来实现一下 then 函数 Promise 对象的 then 方法接收两个参数：onFulfilled（状态变为成功后的回调函数）、onRejected（状态变为失败后的回调函数），两个参数都是可选的。当状态为 Pending 时，会等待状态变化后再执行相应回调函数，当状态已经变化时，会立即执行相应回调函数。 then 方法可以被调用多次，当状态变化后，会按照 then 的调用顺序，依次执行其相应回调。 then 方法会返回一个新的 Promise 对象，以支持链式调用。 then 方法的回调函数参数的返回值时 Promise 对象时，需要等它的状态变化后，再去执行下一个 then 的回调函数；返回值不是 Promise 对象时，直接执行下一个 then 的回调函数。 class MyPromise &#123; constructor(handle) &#123; if (!isFunction(handle)) &#123; throw new Error(\"MyPromise must accept a function as a parameter\"); &#125; this._status = PENDING; this._value = undefined; // 由于 then 方法可以多次调用，我们需要维护两个数组，将 then 方法中的 onFulfilled 和 onRejected 添加到对应数组，等待执行 this._fulfilledQueues = []; this._rejectedQueues = []; // 执行handle try &#123; handle(this._resolve.bind(this), this._reject.bind(this)); &#125; catch (err) &#123; this._reject(err); &#125; &#125; // 添加 resolve 时执行的函数，需要考虑 val 是 Promise 对象的情况 _resolve(val) &#123; if (this._status !== PENDING) return; // 依次执行成功队列中的函数，并清空队列 const runFulfilled = (value) =&gt; &#123; let cb; while ((cb = this._fulfilledQueues.shift())) &#123; cb(value); &#125; &#125;; // 依次执行失败队列中的函数，并清空队列 const runRejected = (error) =&gt; &#123; let cb; while ((cb = this._rejectedQueues.shift())) &#123; cb(error); &#125; &#125;; if (val instanceof MyPromise) &#123; val.then( (value) =&gt; &#123; this._value = value; this._status = FULFILLED; runFulfilled(value); &#125;, (err) =&gt; &#123; this._value = err; this._status = REJECTED; runRejected(err); &#125; ); &#125; else &#123; this._value = val; this._status = FULFILLED; runFulfilled(val); &#125; &#125; // 添加reject时执行的函数 _reject(err) &#123; if (this._status !== PENDING) return; this._status = REJECTED; this._value = err; let cb; while ((cb = this._rejectedQueues.shift())) &#123; cb(err); &#125; &#125; then(onFulfilled, onRejected) &#123; const &#123; _value, _status &#125; = this; // 返回一个新的Promise对象 return new MyPromise((onFulfilledNext, onRejectedNext) =&gt; &#123; // 封装一个成功时执行的函数 let fulfilled = (value) =&gt; &#123; try &#123; // 如果 then 函数传入的成功回调参数不是一个函数，直接执行新 Promise 对象的 resolve 函数 if (!isFunction(onFulfilled)) &#123; onFulfilledNext(value); &#125; else &#123; let res = onFulfilled(value); // 如果当前回调函数返回的是 Promise 对象，调用它自己的 then 函数，必须等待其状态改变后再执行下一个 then 的回调函数 if (res instanceof MyPromise) &#123; res.then(onFulfilledNext, onRejectedNext); &#125; else &#123; // 否则会将返回结果直接作为参数，传入下一个then的回调函数，并立即执行下一个 then 的回调函数 onFulfilledNext(res); &#125; &#125; &#125; catch (err) &#123; // 如果函数执行出错，新的Promise对象的状态为失败 onRejectedNext(err); &#125; &#125;; // 封装一个失败时执行的函数 let rejected = (error) =&gt; &#123; try &#123; if (!isFunction(onRejected)) &#123; onRejectedNext(error); &#125; else &#123; let res = onRejected(error); if (res instanceof MyPromise) &#123; // 如果当前回调函数返回MyPromise对象，必须等待其状态改变后在执行下一个回调 res.then(onFulfilledNext, onRejectedNext); &#125; else &#123; //否则会将返回结果直接作为参数，传入下一个then的回调函数，并立即执行下一个then的回调函数 onFulfilledNext(res); &#125; &#125; &#125; catch (err) &#123; // 如果函数执行出错，新的Promise对象的状态为失败 onRejectedNext(err); &#125; &#125;; switch (_status) &#123; // 当状态为 Pending 时，将 then 方法回调函数加入执行队列等待执行 case PENDING: this._fulfilledQueues.push(fulfilled); this._rejectedQueues.push(rejected); break; // 当状态已经改变时，立即执行对应的回调函数 case FULFILLED: fulfilled(_value); break; case REJECTED: rejected(_value); break; &#125; &#125;); &#125;&#125; 下面我们用两个栗子来测试一下实现的 then 函数： var promise = new MyPromise(resolve =&gt; &#123; console.log('Done'); resolve('同步 Promise');&#125;).then((data) =&gt; &#123; console.log(data); return '同步 then 1'&#125;).then((data) =&gt; &#123; console.log(data);&#125;)// Done// 同步 Promise// 同步 then 1 var promise = new MyPromise(resolve =&gt; &#123; setTimeout(() =&gt; &#123; console.log('Done'); resolve('2秒'); &#125;, 2000);&#125;).then((data) =&gt; &#123; console.log(data); return new MyPromise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve('第一个 then 返回一个Promise') &#125;, 2000) &#125;)&#125;).then((data) =&gt; &#123; console.log(data);&#125;)// Done// 2秒// 第一个 then 返回一个Promise 没什么问题~~ 扩展接下来我们添加一些 Promise 常用的方法 catch相当于调用 then 方法, 但只传入 Rejected 状态的回调函数 catch (onRejected) &#123; return this.then(undefined, onRejected)&#125; 静态 all 方法static all (list) &#123; return new MyPromise((resolve, reject) =&gt; &#123; let values = [] let count = 0 for (let [i, p] of list.entries()) &#123; this.resolve(p).then(res =&gt; &#123; values[i] = res count++ // 所有子 Promise 状态都变成 fulfilled 时，返回的 Promise 状态就变成 fulfilled if (count === list.length) resolve(values) &#125;, err =&gt; &#123; // 有一个子 Promise 状态被 rejected 时, 返回的 Promise 状态就变成 rejected reject(err) &#125;) &#125; &#125;)&#125; 静态 race 方法static race (list) &#123; return new MyPromise((resolve, reject) =&gt; &#123; for (let p of list) &#123; // 只要有一个子 Promise 先改变状态，返回的 Promise 的状态就跟着改变 this.resolve(p).then(res =&gt; &#123; resolve(res) &#125;, err =&gt; &#123; reject(err) &#125;) &#125; &#125;)&#125; 这样，Promise 的基本功能算是实现了~~ 参考Promise实现原理","categories":[{"name":"前端","slug":"front-end","permalink":"https://haohaio.github.io/categories/front-end/"}],"tags":[{"name":"JavaScript","slug":"javascript","permalink":"https://haohaio.github.io/tags/javascript/"}]},{"title":"浏览器的缓存机制","slug":"web-cache","date":"2020-04-09T07:16:02.000Z","updated":"2020-04-09T08:05:53.823Z","comments":true,"path":"front-end/web-cache.html","link":"","permalink":"https://haohaio.github.io/front-end/web-cache.html","excerpt":"","text":"浏览器缓存机制简单来说，就是第一次访问页面时，会把页面相关资源缓存下来，在之后访问页面的时候，通过页面的缓存策略判断，是否请求新的资源还是使用已经缓存的资源。接下来我们就来具体了解一下。 缓存位置从缓存位置上来说分为四种，并且各自有优先级，依次查找缓存且都没有命中的时候，才会去请求网络。 Service Worker Memory Cache Disk Cache Push Cache Service WorkerService Worker 是运行在浏览器背后的独立线程，一般可以用来实现缓存功能。使用 Service Worker的话，传输协议必须为 HTTPS。因为 Service Worker 中涉及到请求拦截，所以必须使用 HTTPS 协议来保障安全。 Service Worker 的缓存与浏览器其他内建的缓存机制不同，它可以让我们自由控制缓存哪些文件、如何匹配缓存、如何读取缓存，并且缓存是持续性的。 Service Worker 实现缓存功能一般分为三个步骤: 首先需要先注册 Service Worker 然后监听到 install 事件以后就可以缓存需要的文件 那么在下次用户访问的时候就可以通过拦截请求的方式查询是否存在缓存，存在缓存的话就可以直接读取缓存文件，否则就去请求数据。 当 Service Worker 没有命中缓存的时候，我们需要去调用 fetch 函数获取数据。也就是说，如果我们没有在 Service Worker 命中缓存的话，会根据缓存查找优先级去查找数据。但是不管我们是从 Memory Cache 中还是从网络请求中获取的数据，浏览器都会显示我们是从 Service Worker 中获取的内容。 Memory CacheMemory Cache 也就是内存中的缓存，主要包含的是当前中页面中已经抓取到的资源,例如页面上已经下载的样式、脚本、图片等。读取内存中的数据肯定比磁盘快,内存缓存虽然读取高效，可是缓存持续性很短，会随着进程的释放而释放。 一旦我们关闭 Tab 页面，内存中的缓存也就被释放了。 计算机中的内存一定比硬盘容量小得多，操作系统需要精打细算内存的使用，所以能让我们使用的内存必然不多，不会将数据都存放在内存。 内存缓存在缓存资源时并不关心返回资源的HTTP缓存头Cache-Control是什么值，同时资源的匹配也并非仅仅是对URL做匹配，还可能会对Content-Type，CORS等其他特征做校验。 Disk CacheDisk Cache 也就是存储在硬盘中的缓存，读取速度慢点，但是什么都能存储到磁盘中，比之 Memory Cache 胜在容量和存储时效性上。 在所有浏览器缓存中，Disk Cache 覆盖面基本是最大的。它会根据 HTTP Herder 中的字段判断哪些资源需要缓存，哪些资源可以不请求直接使用，哪些资源已经过期需要重新请求。并且即使在跨站点的情况下，相同地址的资源一旦被硬盘缓存下来，就不会再次去请求数据。绝大部分的缓存都来自 Disk Cache。 浏览器会把哪些文件丢进内存中？哪些丢进硬盘中？ 对于大文件来说，大概率是不存储在内存中的，反之优先 当前系统内存使用率高的话，文件优先存储进硬盘 Push CachePush Cache（推送缓存）是 HTTP/2 中的内容，当以上三种缓存都没有命中时，它才会被使用。它只在会话（Session）中存在，一旦会话结束就被释放，并且缓存时间也很短暂，在Chrome浏览器中只有5分钟左右，同时它也并非严格执行HTTP头中的缓存指令。 缓存过程分析 浏览器每次发起请求，都会先在浏览器缓存中查找该请求的结果以及缓存标识。 浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入浏览器缓存中 强缓存不会向服务器发送请求，直接从缓存中读取资源。 请求返回200的状态码，并且Size显示from disk cache或from memory cache 强缓存可以通过设置两种 HTTP Header 实现：Expires 和 Cache-Control。 Expires缓存过期时间，用来指定资源到期的时间，是服务器端的具体的时间点。 HTTP/1 的产物，受限于本地时间，如果修改了本地时间，可能会造成缓存失效。 Expires: Wed, 22 Oct 2018 08:41:00 GMT 表示资源会在 Wed, 22 Oct 2018 08:41:00 GMT 后过期，需要再次请求。 Cache-ControlHTTP/1.1 的产物 Cache-Control:max-age=300时，表示在这个请求正确返回时间（浏览器也会记录下来）的5分钟内再次加载资源，就会命中强缓存。 public：所有内容都将被缓存（客户端和代理服务器都可缓存）。 private：所有内容只有客户端可以缓存（默认值） no-cache：客户端缓存内容，是否使用缓存则需要经过协商缓存来验证决定。 no-store：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存 max-age：max-age=xxx (xxx is numeric)表示缓存内容将在xxx秒后失效 max-age: 0 和 no-cache 在响应报文中意思相同，但在请求报文中，no-cache 时请求报文不会携带协商缓存标识，max-age:0仍会携带。 Expires &amp; Cache-ControlExpires 是http1.0的产物，Cache-Control是http1.1的产物。两者同时存在的话，Cache-Control 优先级高于 Expires。 协商缓存协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程，主要有以下两种情况 协商缓存生效，返回304和Not Modified Last-Modified 和 If-Modified-Since浏览器在第一次访问资源时，服务器返回资源的同时，在response header中添加 Last-Modified 的header，值是这个资源在服务器上的最后修改时间，浏览器在下一次加载资源向服务器发送请求时，会将上一次返回的 Last-Modified 值放到 request header 里的 If-Modified-Since 里，服务器只需要比较客户端传来的 If-Modified-Since 跟自己服务器上该资源的最后修改时间对比，就能很好地判断是否使用缓存了。 弊端 如果打开缓存文件，即使没有对文件进行修改，但还是会造成 Last-Modified 被修改，服务端不能命中缓存导致发送相同的资源 因为 Last-Modified 只能以秒计时，如果在不可感知的时间内修改完成文件，那么服务端会认为资源还是命中缓存了，不会返回正确的资源 ETag 和 If-None-MatchETag 是服务器响应请求时，返回当前资源文件的一个唯一标识(由服务器生成)，只要资源有变化，ETag 就会重新生成。浏览器在下一次加载资源向服务器发送请求时，会将上一次返回的 ETag 值放到 request header 里的 If-None-Match 里，服务器只需要比较客户端传来的 If-None-Match 跟自己服务器上该资源的 ETag 是否一致，就能很好地判断资源相对客户端而言是否被修改过了。 两者之间对比 首先在精确度上，ETag 要优于 Last-Modified。（Last-Modified的时间单位是秒，ETag 每次都会改变） 性能上，ETag 要逊于 Last-Modified，毕竟 Last-Modified 只需要记录时间，而 ETag 需要服务器通过算法来计算出一个 hash 值。 优先级上，服务器校验优先考虑 ETag。 缓存策略频繁变动的资源对于频繁变动的资源，我们可以设置不使用强缓存 Cache-Control: no-cache，然后配合 配合 ETag 的缓存策略。 不常变化的资源对于不经常变化的资源，我们可以主要使用强缓存的策略，设置一个很长的缓存失效时间 Cache-Control: max-age=31536000。而为了解决更新的问题，就需要在文件名(或者路径)中添加 hash， 版本号等动态字符。","categories":[{"name":"前端","slug":"front-end","permalink":"https://haohaio.github.io/categories/front-end/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://haohaio.github.io/tags/Web/"}]},{"title":"前端异常监控","slug":"exception-monitor","date":"2020-04-08T08:46:55.000Z","updated":"2020-04-22T06:34:24.154Z","comments":true,"path":"front-end/exception-monitor.html","link":"","permalink":"https://haohaio.github.io/front-end/exception-monitor.html","excerpt":"","text":"对于前端应用来说， 对异常的监控是很有必要的。异常也有很多种，比如 js 运行时异常，加载静态资源异常，接口请求异常等等。今天就来大概了解一下如何进行异常监控。 JavaScript 运行时异常try…catch一般我们写代码时，会使用 try...catch 来捕获异常： try &#123; throw \"出错了！\";&#125; catch (e) &#123; console.log(e); // \"出错了！\"&#125; 在 try 代码块中，我们可以通过 throw 手动抛出异常，异常我们可以自定义，catch 代码块的参数是就是我们抛出来的异常。 当我们代码运行时发生错误时，会自动抛出来一个异常，这个异常是一个 Error 对象，会带有 name 和 message 两个标准属性。 现在大部分浏览器都支持了 stack 属性，包含错误的完整信息，包括了 name 、 message 和发生错误的文件和行号等。 try &#123; console.log(a); const a = 123;&#125; catch (e) &#123; console.log(e.name); // 'ReferenceError' console.log(e.message); // 'Cannot access 'a' before initialization' console.log(e.stack); // ReferenceError: Cannot access 'a' before initialization at test.html:23&#125; 但是我们并不能使用 try...catch 来做整个 Web 应用的异常监控，因为我们不可能给所有的 js 代码都加上 try...catch。 window.onerror 当 JavaScript 运行时错误（包括语法错误）发生时，window 会触发一个 ErrorEvent 接口的 error 事件，并执行 window.onerror()。 因此我们可以使用 window.onerror 来监控运行时的代码异常： /** * message: 错误信息 * source: 出错文件： * lineno: 出错行号 * colno: 出错列号： * error: 错误详情 */window.onerror = function (message, source, lineno, colno, error) &#123; // Todo: 异常上报 return true; // 函数返回true，阻止执行默认事件处理函数，即浏览器控制台不会再打印错误信息&#125;; 需要注意的是，当加载自不同域的脚本中发生语法错误时，为避免信息泄露，语法错误的细节将不会报告，而代之简单的”Script error.”。onerror 捕获的错误信息为： message: &quot;Script error.&quot;source: &quot;&quot;lineno: 0colno: 0error: null 如果需要解决这个问题的话，我们需要做两件事： 引用跨域 js 文件时加上 crossorigin 属性 &lt;script type=\"text/javascript\" src=\"http://b.com/b.js\" crossorigin&gt;&lt;/script&gt; 服务器发送相关跨域 js 文件时需要发送适当的 CORS HTTP 响应头(Access-Control-Allow-Origin) 静态资源异常 当一项资源（如 &lt;img&gt; 或 &lt;script&gt;）加载失败，加载资源的元素会触发一个 Event 接口的 error 事件，并执行该元素上的 onerror() 处理函数。这些 error 事件不会向上冒泡到 window，不过能被单一的 window.addEventListener 捕获。 因此只用 window.onerror 来监测前端项目异常的话，功能还不够完善。但我们可以使用 window.addEventListener(&#39;error&#39;, function(event) {}, true) 来捕获静态资源异常 window.addEventListener( \"error\", function (event) &#123; console.log(event); &#125;, true); 由于 window.addEventListener(&#39;error&#39;, function(event) {}, true) 也能捕获 js 运行时异常，因此我们使用了 window.onerror 后，为了避免重复上报，在监听静态资源异常时，需要做一些处理： window.addEventListener( \"error\", function (event) &#123; let target = event.target || event.srcElement; // 判断是否是静态资源 let isElementTarget = target instanceof HTMLScriptElement || target instanceof HTMLLinkElement || target instanceof HTMLImageElement; // 过滤非静态资源异常 if (!isElementTarget) return; // 需要上报的资源文件 url let url = target.src || target.href; // Todo: 异常上报 &#125;, true); 未处理的 promise 异常 当 Promise 被 reject 且没有 reject 处理器的时候，会触发 unhandledrejection 事件。 也就是说当 promise 被 reject 但是没有进行 catch 处理时，会抛出异常。 但是这个异常不会被 window.onerror 和 window.addEventListener(&#39;error&#39;, function(event) {}, true) 捕获。 function foo() &#123; Promise.reject(\"出错了！\");&#125;foo(); // 控制台会打印 \"Uncaught (in promise) 出错了！\" 我们可以通过监听 unhandledrejection 事件来捕获未处理的 promise 异常： window.addEventListener(\"unhandledrejection\", (event) =&gt; &#123; console.log(event.reason); // \"出错了！\" // Todo: 异常上报&#125;); 网络请求异常XMLHttpRequest一般情况下，我们都是基于 XMLHttpRequest 发送网络请求的： let xhr = new XMLHttpRequest();xhr.open(\"GET\", \"/test\");xhr.send();xhr.onreadystatechange = function () &#123; if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) &#123; console.log(xhr.responseText); &#125; else &#123; console.log(xhr.status); // 404 console.log(xhr.statusText); // Not Found &#125;&#125;; 我们可以通过劫持 XMLHttpRequest 的 open 和 send 方法来进行异常上报： (function handleXMLHttpRequestException() &#123; if (window.location.protocol === \"file:\") return; if (!window.XMLHttpRequest) return; const xmlHttp = window.XMLHttpRequest; // 当请求完全无法执行的时候（比如无法跨域请求），XMLHttpRequest 会收到 status=0 和 statusText=\"\" 的返回，此时 responseURL 也为 \"\"，因此我们可以通过劫持 open 方法，把请求地址加到 XMLHttpRequest 对象上。 let oldOpen = xmlHttp.prototype.open; xmlHttp.prototype.open = function (method, url) &#123; this.ajaxUrl = url; oldOpen.apply(this, arguments); &#125;; // 保存原生 send 方法 let oldSend = xmlHttp.prototype.send; let handleExceptionEvent = function (event) &#123; if (event &amp;&amp; event.currentTarget &amp;&amp; event.currentTarget.status !== 200) &#123; console.log(event.type); // load console.log( event.currentTarget.responseURL || event.currentTarget.ajaxUrl ); console.log(event.currentTarget.status); // 404 console.log(event.currentTarget.statusText); // Not Found // Todo: 异常上报 &#125; &#125;; // 劫持原生 send 方法，进行异常上报 xmlHttp.prototype.send = function () &#123; this.addEventListener(\"error\", handleExceptionEvent); this.addEventListener(\"load\", handleExceptionEvent); // 404 时会触发 load 事件 return oldSend.apply(this, arguments); &#125;;&#125;)();let xhr = new XMLHttpRequest();xhr.onreadystatechange = function () &#123; if (xhr.readyState === 4) &#123; if (xhr.status === 200) &#123; // success &#125; else &#123; // error &#125; &#125;&#125;;xhr.open(\"GET\", \"http://www.baidu.com\");xhr.send(); fetch当我们使用 fetch 发送网络请求时，可以这样做： (function handleFetchException() &#123; if (!window.fetch) return; let oldFetch = window.fetch; window.fetch = function () &#123; return ( oldFetch .apply(this, arguments) .then((res) =&gt; &#123; if (!res.ok) &#123; // Todo: 异常上报 &#125; return res; &#125;) // 当fetch方法错误时上报 .catch((error) =&gt; &#123; // error.message, // error.stack // Todo: 异常上报 throw error; &#125;) ); &#125;;&#125;)()fetch('http://url') Vue 内部发生的错误Vue 内部发生的错误会被 Vue 拦截，官方提供了一个处理函数，我们可以在这个函数内部进行异常上报： Vue.config.errorHandler = function (err, vm, info) &#123; // handle error // `info` 是 Vue 特定的错误信息，比如错误所在的生命周期钩子 // 只在 2.2.0+ 可用&#125; React 内部发生的错误我们可以通过 React16+ 中的 Error Boundaries 特性来处理组件内部的错误： class ErrorBoundary extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; hasError: false &#125;; &#125; componentDidCatch(error, info) &#123; // Display fallback UI this.setState(&#123; hasError: true &#125;); // Todo: 异常上报 &#125; render() &#123; if (this.state.hasError) &#123; // You can render any custom fallback UI return &lt;h1&gt;Something went wrong.&lt;/h1&gt;; &#125; return this.props.children; &#125;&#125; Error Boundaries 即错误边界，其可以拦截子组件生命周期内的错误，我们可以使用它来保证页面可以正常渲染UI，而不是一片空白。我们可以使用ErrorBoundary 包裹我们的子组件，在 componentDidCatch 函数中进行异常上报。 上报异常当我们上报异常时，为了更准确的分析定位，我们需要不仅仅要上报捕获到的异常基本信息，还需要上报用户信息、环境信息（操作系统信息、浏览器信息、网络环境、应用版本等）等。 上报异常时我们还需要考虑上报的量和频率问题。有需要的情况下，我们可以先把异常信息存储到 IndexedDB 中，在 Web Worker 线程中控制异常上报。 上报异常时，Ajax 请求本身也有可能会发生异常，一般情况下更推荐使用动态创建 img 标签的形式进行上报。 现在前端代码大部分情况都是经过压缩后发布的，上报的 stack 信息需要还原为源码信息，才能快速定位源码进行修改。因此我们可以发部署时，将 sourcemap 文件上传到监控系统，在监控系统中展示 stack 信息时，利用 sourcemap 文件对 stack 信息进行解码，得到源码中的具体信息。 小结现在我们算是基本了解了如何进行异常监控，但要实现完整的异常监控功能，还任重而道远。Sentry 是一项非常出色的服务，可以帮助我们进行异常监控，并且是开源的。后面会研究下，如何使用 Sentry 进行异常监控。","categories":[{"name":"前端","slug":"front-end","permalink":"https://haohaio.github.io/categories/front-end/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://haohaio.github.io/tags/Web/"}]},{"title":"排序之快速排序","slug":"sort-quick","date":"2019-10-30T08:55:28.000Z","updated":"2020-04-09T07:21:45.769Z","comments":true,"path":"data-structure/quick-sort.html","link":"","permalink":"https://haohaio.github.io/data-structure/quick-sort.html","excerpt":"","text":"希尔排序相当于直接插入排序的升级，同属于插入排序类，堆排序相当于简单选择排序的升级，同属于选择排序类。快速排序是最慢的冒泡排序的升级，属于交换排序类。它是通过不断比较和移动交换来实现排序的，只不过它的实现增大了记录的比较和移动的距离，将关键字较大的记录从前面直接移动到后面，关键字较小的记录从后面直接移动到前面，减少了总的比较次数和移动交换次数。 快速排序算法快速排序（Quick Sort）的基本思想是：通过一趟排序将待排记录分割成独立的两部分，其中一部分记录的关键字均比另一部分记录的关键字小，分别对这两部分记录继续排序，达到整个序列有序。 来直接看下代码： import java.util.Arrays;public class QuickSort &#123; public static void main(String[] args) &#123; int[] arr = &#123;50, 10, 90, 30, 70, 40, 80, 60, 20&#125;; quickSort(arr, 0, arr.length - 1); System.out.println(\"排序后：\" + Arrays.toString(arr)); &#125; public static int partition(int[] arr, int low, int high) &#123; // 将数组中第一个元素作为枢轴 int pivotKey = arr[low]; // 从数组两端交替向中间扫描 while (low &lt; high) &#123; // 从高端开始，若 arr[high]值大于枢轴值，则向低端循环扫描 while (pivotKey &lt;= arr[high] &amp;&amp; low &lt; high) &#123; high--; &#125; // while 循环结束后，若 low &lt; height ，此时 arr[high] 小于枢轴值，则将 arr[high] 赋值给低端 if (low &lt; high) &#123; arr[low] = arr[high]; low++; &#125; // 进行交替，若 arr[low] 小于枢轴值，则向高端循环扫描 while (pivotKey &gt;= arr[low] &amp;&amp; low &lt; high) &#123; low++; &#125; // while 循环结束后，若 low &lt; height ，此时 arr[low] 大于枢轴值，则将 arr[low] 赋值给高端 if (low &lt; high) &#123; arr[high] = arr[low]; high--; &#125; &#125; // 当 low = high 时，结束循环，此时将枢轴值赋值给该下标，完成本次交换 arr[low] = pivotKey; // 返回枢轴值所在下标 return low; &#125; public static void quickSort(int[] arr, int left, int right) &#123; if (arr == null || left &gt;= right || arr.length &lt;= 1) &#123; return; &#125; int pivot = partition(arr, left, right); quickSort(arr, left, pivot - 1); quickSort(arr, pivot + 1, right); &#125;&#125; 代码的核心是“int pivot = partition(arr, left, right);”,执行它之前，arr 的数值为 {50,10,90,30,70,40,80,60,20}，partition 函数要做的是先选取当中的一个关键字，如 50，想办法将它放到一个位置，使得左边的值都比它小，右边的值比它大，这样的关键字称为枢轴（pivot）。 经过 partition(arr, 0, 8)的执行之后，数组变成 {20,10,40,30,50,70,80,60,90}，并返回值 4 给 pivot，数字 4 表明 50 放置在数组下标为 4 的位置。计算机把原来的数组变成了两个位于 50 左和右小数组 {20,10,40,30} 和 {70,80,60,90}，而后的递归调用“partition(arr, 0, 4);”和“partition(arr, 5, 8);”，对 {20,10,40,30} 和 {70,80,60,90} 分别进行同样的 partition 操作，直到顺序全部正确为止。 接下来看下关键的 partition 函数执行过程： public static int partition(int[] arr, int low, int high) &#123; // 将数组中第一个元素作为枢轴 int pivotKey = arr[low]; // 从数组两端交替向中间扫描 while (low &lt; high) &#123; // 从高端开始，若 arr[high]值大于枢轴值，则向低端循环扫描 while (pivotKey &lt;= arr[high] &amp;&amp; low &lt; high) &#123; high--; &#125; // while 循环结束后，若 low &lt; height ，此时 arr[high] 小于枢轴值，则将 arr[high] 赋值给低端 if (low &lt; high) &#123; arr[low] = arr[high]; low++; &#125; // 进行交替，若 arr[low] 小于枢轴值，则向高端循环扫描 while (pivotKey &gt;= arr[low] &amp;&amp; low &lt; high) &#123; low++; &#125; // while 循环结束后，若 low &lt; height ，此时 arr[low] 大于枢轴值，则将 arr[low] 赋值给高端 if (low &lt; high) &#123; arr[high] = arr[low]; high--; &#125; &#125; // 当 low = high 时，结束循环，此时将枢轴值赋值给该下标，完成本次交换 arr[low] = pivotKey; // 返回枢轴值所在下标 return low;&#125; 当 low = 0，high = arr.length - 1 = 8。pivotKey = 50，先从高端向低端进行扫描，发现 arr[8] &lt; pivotKey，故将 arr[8] 的值赋值给 arr[0]，然后交替从低端向高端进行扫描，发现 arr[2] &gt; pivotKey，故将 arr[2] 的值赋给 arr[high]，即 arr[8] = arr[2] = 90。此时 low = 2，high = 8，序列为 {20, 10, 90, 30, 70, 40, 80, 60, 90}。 继续交替从高端向低端进行扫描，发现 arr[5] &lt; pivotKey，故将 arr[5] 的值赋值给 arr[2]，然后交替从低端向高端进行扫描，发现 arr[4] &gt; pivotKey，故将 arr[4] 的值赋给 arr[high]，即 arr[5] = arr[4] = 70。此时 low = 4，high = 5，序列为 {20, 10, 40, 30, 70, 70, 80, 60, 90}。 继续交替从高端向低端进行扫描，high– 到 high = low = 4，此时结束所有循环，arr[4] = pivotKey = 50。此时序列为 {20, 10, 40, 30, 50, 70, 80, 60, 90}，枢轴前的元素全部小于它，枢轴后的元素全部大于它。最后返回枢轴的下标。 之后进行递归调用 “quickSort(arr, 0, 3)” 和 “quickSort(arr, 5, 8)”，对 {20, 10, 40, 30} 和 {70, 80, 60, 90} 分别进行同样的 partition 操作，直到顺序全部正确为止。 快速排序复杂度分析快速排序的时间性能取决于快速排序递归的深度，在最优情况下，即 partition 每次都划分的很均匀，如果排序个关键字，其递归树的深度为 [logn] + 1，即仅需递归 [logn] 次。在最优的情况下，快速排序算法的时间复杂度为 O(nlogn)。在最坏的情况下，待排序的序列为正序或者逆序，每次划分只得到一个比上一次划分少一个记录的子序列，另一个为空。此时时间复杂度为 O(n2)。 由于关键字的比较和交换是跳跃执行的，因此，快速排序是一种不稳定的排序方法。 快速排序优化优化选取枢轴 三数取中（median-of-three）法：取三个关键字先进行排序，将中间数作为枢轴，一般是取左端、右端和中间三个数，也可以随机选取。这样至少这个中间数一定不会是最小或者最大的数。 九数取中（me-dian-of-nine）：先从数组中分三次取样，每次取三个数，三个样品各取出中数，然后从这三个中数当中再取出一个中数作为枢轴。更加保证了取到的 pivotkey 是比较接近中间值的关键字。 优化小数组时的排序方案如果数组非常小，其实快读排序反而不如直接插入排序来得更好（直接插入排序时简单排序中性能最好的）。因此我们可以增加一个判断，当 high - low 小于等于常数时用直接插入排序。","categories":[{"name":"数据结构","slug":"data-structure","permalink":"https://haohaio.github.io/categories/data-structure/"}],"tags":[{"name":"排序","slug":"排序","permalink":"https://haohaio.github.io/tags/排序/"}]},{"title":"排序之归并排序","slug":"sort-merge","date":"2019-10-29T10:17:47.000Z","updated":"2020-04-09T07:21:45.770Z","comments":true,"path":"data-structure/merge-sort.html","link":"","permalink":"https://haohaio.github.io/data-structure/merge-sort.html","excerpt":"","text":"归并，在数据结构中，是指将两个或两个以上的有序表组合成一个新的有序表 归并排序（Merging Sort）就是利用归并的思想实现的排序方法。它的原始是假设初始序列含有 n 个记录，则可以看成是 n 个有序的子序列，每个子序列的长度为 1，然后两两归并，得到 n / 2（|x|表示不小于 x 的最小整数）个长度为 2 或 1 的有序子序列；再两两归并，如此重复，直至得到一个长度为 n 的有序序列为止，这种排序方法称为 2 路归并排序 来看下代码： public class MergeSort &#123; public static void main(String[] args) &#123; int[] arr = &#123;50, 10, 90, 30, 70, 40, 80, 60, 20&#125;; mergeSort(arr, 0, arr.length - 1); for (int i = 0; i &lt; arr.length; i++) &#123; System.out.println(arr[i]); &#125; &#125; public static void mergeSort(int[] a, int start, int end) &#123; // 当子序列中只有一个元素时结束递归 if (start == end) &#123; return; &#125; // 划分子序列 int mid = (start + end) / 2; // 对左侧子序列进行递归排序 mergeSort(a, start, mid); // 对右侧子序列进行递归排序 mergeSort(a, mid + 1, end); //合并 merge(a, start, mid, end); &#125; // 两路归并算法，两个排好序的子序列合并为一个子序列 &#123;50, 10&#125; , 0, 0, 1 public static void merge(int[] a, int left, int mid, int right) &#123; int[] tmp = new int[a.length]; // p1、p2是检测指针，k是存放指针 int p1 = left, p2 = mid + 1, k = left; while (p1 &lt;= mid &amp;&amp; p2 &lt;= right) &#123; if (a[p1] &lt;= a[p2]) &#123; tmp[k++] = a[p1++]; &#125; else &#123; tmp[k++] = a[p2++]; &#125; &#125; // 如果第一个序列未检测完，直接将后面所有元素加到合并的序列中 while (p1 &lt;= mid) &#123; tmp[k++] = a[p1++]; &#125; //同上 while (p2 &lt;= right) &#123; tmp[k++] = a[p2++]; &#125; //复制回原素组 for (int i = left; i &lt;= right; i++) &#123; a[i] = tmp[i]; &#125; &#125;&#125; 来直接看下整个数据变换示意图： 归并排序复杂度分析无论在什么情况下，归并排序的时间复杂度都是 O(nlogn)。 归并排序是一种比较占用内存，但却效率高且稳定的算法。","categories":[{"name":"数据结构","slug":"data-structure","permalink":"https://haohaio.github.io/categories/data-structure/"}],"tags":[{"name":"排序","slug":"排序","permalink":"https://haohaio.github.io/tags/排序/"}]},{"title":"排序之堆排序","slug":"sort-heap","date":"2019-10-22T14:13:47.000Z","updated":"2020-04-09T07:21:45.889Z","comments":true,"path":"data-structure/sort-htap.html","link":"","permalink":"https://haohaio.github.io/data-structure/sort-htap.html","excerpt":"","text":"堆是具有下列性质的完全二叉树：每个节点的值都大于或等于其左右孩子节点的值，称为大顶堆；或者每个节点的值都小于或等于其左右孩子节点的值，称为小顶堆，如下图所示： 按照层序遍历的方式给节点从 1 开始编号，节点之间满足如下关系： 将大顶推和小顶堆用层序遍历存入数组： 堆排序（Heap Sort）就是利用堆（假设利用大顶堆）进行排序的算法。它的基本思想是：将待排序的序列构造成一个大顶堆。此时，整个序列的最大值就是堆顶的根节点。将它移走（其实就是将其与堆数组的末尾元素进行交换，此时末尾元素就是最大值），然后将剩余的 n - 1 个序列重新构成一个堆，这样就会得到 n 个元素中的次大值。如此反复执行，便能得到一个有序序列了。具体如下图所示： 实现需要解决两个问题： 如何由一个无序序列构建成一个堆 如何在输出堆顶元素后，调整剩余元素成为一个新的堆 假设要排序的序列是 {50,10,90,30,70,40,80,60,20}，构成一个完全二叉树如下图所示： 将待排序的序列构建成为一个大顶堆，就是从下往上、从右到左（即按照图中4→3→2→1 的顺序），将每个非终端结点（非叶结点）当作根结点，将其和其子树调整成大顶堆。 来看看 Java 中的实现： /** * 堆调整函数 * * @param arr 待排序数组 &#123;50,10,90,30,70,40,80,60,20&#125; * @param i 根节点下标 &#123;3, 2, 1, 0&#125; * @param length 数组长度 9 */void heapAdjust(int[] arr, int i, int length) &#123; // 先取出当前元素 i int temp = arr[i]; // 从i结点的左子结点开始，也就是2i+1处开始 for (int k = i * 2 + 1; k &lt; length; k = k * 2 + 1) &#123; // 如果左子结点小于右子结点，k指向右子结点 if (k + 1 &lt; length &amp;&amp; arr[k] &lt; arr[k + 1]) &#123; k++; &#125; // 如果子结点大于父节点，将子结点值赋给父节点（不用进行交换） if (arr[k] &gt; temp) &#123; arr[i] = arr[k]; i = k; &#125; else &#123; break; &#125; &#125; //将temp值放到最终的位置 arr[i] = temp;&#125; 可以看到按照从下往上、从右到左，第一个根节点的下标为 3（arr.length / 2 - 1），值为 temp = 30；进入 for 循环，k = 7，该左子结点的下标为 7（i * 2 + 1），值为 60；大于右子结点的值（20），则将其值赋给根结点，arr[3] = arr[7] = 60，i = 7。k = 15，跳出循环。arr[7] = temp = 30。完成了 arr[3] 与 arr[7] 的交换，即完成了根结点与其左子结点的交换。如下图所示： 下个根结点下标为 2，值为 temp = 90；进入 for 循环，该左子结点的下标为 k = 5，其值小于右子结点，右子结点为 arr[6] = 80 &lt; temp，因此跳出循环。 下个根结点下标为 1，值为 temp = 10；进入 for 循环，该左子结点的下标为 k = 3，其值小于右子结点，右子结点为 arr[4] = 70 &gt; temp，因此将其值赋给根结点，arr[1] = arr[4] = 70。最终本次调用使得 10 与 70 进行了互换。如下图所示： 下个根结点下标为 0，值为 temp = 50；进入 for 循环，该左子结点的下标为 k = 1，其值小于右子结点，右子结点为 arr[2] = 90 &gt; temp，因此将其值赋给根结点，arr[0] = arr[2] = 90。i = 2,该左子结点的下标为 k = 5，再次进入循环，其值小于右子结点，右子结点为 arr[6] = 80 &gt; temp，将其值赋给根结点，arr[2] = arr[6] = 80。最后结束循环。此时已经构成了大顶堆，如下图所示： 接下来来看下完整代码实现： import java.util.Arrays;public class HeapSort &#123; public static void main(String[] args) &#123; int[] arr = &#123;50, 10, 90, 30, 70, 40, 80, 60, 20&#125;; System.out.println(\"排序前：\" + Arrays.toString(arr)); heapSort(arr); System.out.println(\"排序前：\" + Arrays.toString(arr)); &#125; static void heapSort(int[] arr) &#123; // 1.构建大顶堆 for (int i = arr.length / 2 - 1; i &gt;= 0; i--) &#123; //从第一个非叶子结点从下至上，从右至左调整结构 heapAdjust(arr, i, arr.length); &#125; // 2.调整堆结构 + 交换堆顶元素与末尾元素 for (int j = arr.length - 1; j &gt; 0; j--) &#123; // 将堆顶元素与末尾元素进行交换 swap(arr, 0, j); // 重新对堆进行调整 heapAdjust(arr, 0, j); &#125; &#125; static void heapAdjust(int[] arr, int i, int length) &#123; // 先取出当前元素i int temp = arr[i]; // 从i结点的左子结点开始，也就是2i+1处开始 for (int k = i * 2 + 1; k &lt; length; k = k * 2 + 1) &#123; // 如果左子结点小于右子结点，k指向右子结点 if (k + 1 &lt; length &amp;&amp; arr[k] &lt; arr[k + 1]) &#123; k++; &#125; // 如果子节点大于父节点，将子节点值赋给父节点（不用进行交换） if (arr[k] &gt; temp) &#123; arr[i] = arr[k]; i = k; &#125; else &#123; break; &#125; &#125; //将temp值放到最终的位置 arr[i] = temp; &#125; static void swap(int[] arr, int a, int b) &#123; int temp = arr[a]; arr[a] = arr[b]; arr[b] = temp; &#125;&#125; 来看一下构建大顶推之后的排序过程： j = 8，arr[0] 与 arr[8] 进行了交换，之后重新构建大顶堆，如下图所示： j = 7，arr[0] 与 arr[7] 进行了交换，之后重新构建大顶堆，如下图所示： 后面的变化： 堆排序复杂度分析推排序的运行时间主要是消耗在初始构建堆和在重建堆时的反复筛选上。 在构建推的过程中，因为是完全二叉树从最下层最右边的非终端结点开始构建，将它与其孩子进行比较和若有必要的互换，对于每个非终端结点，最多进行两次比较和互换操作，时间复杂度为 O(n)。 正式排序：第 i 次取堆顶记录重建堆需要用 O(log i)的时间（完全二叉树的某个结点到根结点的距离为[log i] + 1，并且需要取 n-1 次堆顶记录，因此重建堆的时间复杂度为 O(nlogn)。 总体堆排序的时间复杂度为 O(nlogn)。 空间复杂度上只有一个用来交换的暂存单元，也非常的不错。不过由于记录的比较与交换是跳跃式进行，堆排序也是一种不稳定的排序方法。由于初始构建堆所需的比较次数较多，不适合待排序序列个数较少的情况。","categories":[{"name":"数据结构","slug":"data-structure","permalink":"https://haohaio.github.io/categories/data-structure/"}],"tags":[{"name":"排序","slug":"排序","permalink":"https://haohaio.github.io/tags/排序/"}]},{"title":"排序之希尔排序","slug":"sort-shell","date":"2019-10-16T11:24:36.000Z","updated":"2020-04-09T07:21:45.770Z","comments":true,"path":"data-structure/shell-sort.html","link":"","permalink":"https://haohaio.github.io/data-structure/shell-sort.html","excerpt":"","text":"希尔排序（Shell Sort）是 D.L.Shell 与 1959 年提出来的一种排序算法，在这之前排序算法的时间复杂度基本都是 O(n2)的，希尔排序算法是突破这个时间复杂度的第一批算法之一。 来直接看下算法： import java.util.Arrays;public class ShellSort &#123; public static void main(String[] args) &#123; int[] arr = &#123;9, 1, 5, 8, 3, 7, 4, 6, 2&#125;; shellSort(arr); for (int i = 0; i &lt; arr.length; i++) &#123; System.out.println(arr[i]); &#125; &#125; static void shellSort(int[] arr) &#123; // 当前正在比较的数字 int current; // 初始增量（希尔增量） int increment = arr.length / 2; // increment = 1 的时候，数组已经有序 while (increment &gt; 0) &#123; for (int i = increment; i &lt; arr.length; i++) &#123; current = arr[i]; // 与 current 同组的前一个值 int preIndex = i - increment; // 找到同组内比 current 小的值 while (preIndex &gt;= 0 &amp;&amp; current &lt; arr[preIndex]) &#123; // 将小于 current 的值向前移动 increment 个位置 arr[preIndex + increment] = arr[preIndex]; preIndex = preIndex - increment; &#125; // 将 current 插入到到相应的位置 arr[preIndex + increment] = current; &#125; // 缩小增量 increment = increment / 2; &#125; &#125;&#125; 来看下完整的排序过程： do…while 第 1 次循环，increment = 4，for 循环第 1 次, i = 4，current = arr[4] = 3, preIndex = 0，current &lt; arr[0] = 9，进入内层 while 循环，arr[4] = arr[0] = 9，preIndex = -4 &lt; 0，跳出循环。arr[0] = current = 3。此时序列为 {3, 1, 5, 8, 9, 7, 4, 6, 2}。 for 循环第 2 次，i = 5，current = arr[5] = 7，preIndex = 1，current &gt; arr[1] = 1，不进入内层 while 循环。此时序列仍为 {3, 1, 5, 8, 9, 7, 4, 6, 2}。 for 循环第 3 次，i = 6，current = arr[6] = 4，preIndex = 2，current &lt; arr[2] = 5，进入内层 while 循环，arr[6] = arr[2] = 5，preIndex = -2，跳出循环。arr[2] = current = 4。此时序列仍为 {3, 1, 4, 8, 9, 7, 5, 6, 2}。 for 循环第 4 次，i = 7，current = arr[7] = 6，preIndex = 3，current &lt; arr[3] = 8，进入内层 while 循环，arr[7] = arr[3] = 8，preIndex = -1，跳出循环。arr[3] = current = 6。此时序列仍为 {3, 1, 4, 6, 9, 7, 5, 8, 2}。 for 循环第 5 次，i = 8，current = arr[8] = 2，preIndex = 4，current &lt; arr[4] = 9，进入内层 while 循环，arr[8] = arr[4] = 9，preIndex = 0，current &lt; arr[0] = 3，再次进入 while 循环，arr[4] = arr[0] = 3，preIndex = -4，跳出循环。arr[0] = current = 2。此时序列仍为 {2, 1, 4, 6, 3, 7, 5, 8, 9}。一轮循环结束。 do…while 第 2 次循环，increment = 2，for 循环第 1 次, i = 2，current = arr[2] = 4, preIndex = 0，current &gt; arr[0] = 2，不进入内层 while 循环。此时序列仍为 {2, 1, 4, 6, 3, 7, 5, 8, 9}。 for 循环第 2 次, i = 3，current = arr[3] = 6, preIndex = 1，current &gt; arr[1] = 1，不进入内层 while 循环。此时序列仍为 {2, 1, 4, 6, 3, 7, 5, 8, 9}。 for 循环第 3 次, i = 4，current = arr[4] = 3, preIndex = 2，current &lt; arr[2] = 4，进入内层 while 循环，arr[4] = arr[2] = 4，preIndex = 0，current &gt; arr[0] = 2，跳出循环。arr[2] = current = 3。此时序列为 {2, 1, 3, 6, 4, 7, 5, 8, 9}。 for 循环第 4 次, i = 5，current = arr[5] = 7, preIndex = 3，current &gt; arr[3] = 6，不进入内层 while 循环。此时序列仍为 {2, 1, 3, 6, 4, 7, 5, 8, 9}。 for 循环第 5 次, i = 6，current = arr[6] = 5, preIndex = 4，current &gt; arr[4] = 3，不进入内层 while 循环。此时序列仍为 {2, 1, 3, 6, 4, 7, 5, 8, 9}。 for 循环第 6 次, i = 7，current = arr[7] = 8, preIndex = 5，current &gt; arr[5] = 7，不进入内层 while 循环。此时序列仍为 {2, 1, 3, 6, 4, 7, 5, 8, 9}。 for 循环第 7 次, i = 8，current = arr[8] = 9, preIndex = 6，current &gt; arr[6] = 5，不进入内层 while 循环。此时序列仍为 {2, 1, 3, 6, 4, 7, 5, 8, 9}。一轮循环结束。 do…while 第 3 次循环，increment = 3，for 循环第 1 次, i = 1，current = arr[1] = 1, preIndex = 0，current &gt; arr[0] = 2，进入内层 while 循环，arr[1] = arr[0] = 2，preIndex = -1 &lt; 0，跳出循环。arr[0] = current = 1。此时序列仍为 {1, 2, 3, 6, 4, 7, 5, 8, 9}。 for 循环第 2 次, 此时序列为 {1, 2, 3, 6, 4, 7, 5, 8, 9}。 for 循环第 3 次, 此时序列为 {1, 2, 3, 6, 4, 7, 5, 8, 9}。 for 循环第 4 次, 此时序列为 {1, 2, 3, 4, 6, 7, 5, 8, 9}。 for 循环第 5 次, 此时序列为 {1, 2, 3, 4, 6, 7, 5, 8, 9}。 for 循环第 6 次, 此时序列为 {1, 2, 3, 4, 5, 6, 7, 8, 9}。 for 循环第 7 次, 此时序列为 {1, 2, 3, 4, 5, 6, 7, 8, 9}。 for 循环第 8 次, 此时序列为 {1, 2, 3, 4, 5, 6, 7, 8, 9}。最后一轮循环结束，完成排序。 可以看到希尔排序是将关键字较小的记录不是一步一步地往前挪动，而是跳跃式的往前移，从而使得每次完成一轮循环后，整个序列就朝着有序坚实地迈进一步。这就是希尔排序的关键所在。 希尔排序复杂度分析希尔排序的关键并不是随便分组后各自排序，而是将相隔某个“增量”的记录组成一个子序列，实现跳跃式的移动，使得排序的效率提高。 这里“增量”的选取就十分关键了。可究竟应该选取什么样的增量才是最好，目前还是一个数学难题，迄今为止还没有人找到一种最好的增量序列。不过大量研究表明，其时间复杂度要好于直接排序的 O(n2)。 需要注意的是，增量序列的最后一个值必须等于 1 才行。另外由于记录是跳跃式的移动，希尔排序并不是一种稳定的排序。","categories":[{"name":"数据结构","slug":"data-structure","permalink":"https://haohaio.github.io/categories/data-structure/"}],"tags":[{"name":"排序","slug":"排序","permalink":"https://haohaio.github.io/tags/排序/"}]},{"title":"排序之直接插入排序","slug":"sort-insert","date":"2019-10-15T08:14:34.000Z","updated":"2020-04-09T07:21:45.770Z","comments":true,"path":"data-structure/insert-sort.html","link":"","permalink":"https://haohaio.github.io/data-structure/insert-sort.html","excerpt":"","text":"先来看下直接插入排序的基本思想： 直接插入排序（Straight Insertion Sort）的基本操作就是将 n 个待排序的元素看成一个有序表和一个无序表，开始的时候有序表只有 1 个元素，无序表中有 n-1 个元素。每次从无序表中取出第一个元素，将它插入到有序表中，使之成为新的有序表，重复 n-1 次完成整个排序过程。 接下来看下代码： import java.util.Arrays;public class InsertSort &#123; public static void main(String[] args) &#123; int[] arr = &#123;5, 3, 4, 6, 2&#125;; insertSort(arr); for (int i = 0; i &lt; arr.length; i++) &#123; System.out.println(arr[i]); &#125; &#125; static void insertSort(int[] arr) &#123; int j = 0; int temp = 0; // 从第二个数开始比较 for (int i = 1; i &lt; arr.length; i++) &#123; // 将当前数插入到已经有序的数组中 temp = arr[i]; // 对下标为 i 的之前的元素进行遍历 for (j = i - 1; j &gt;= 0; j--) &#123; // 如果前面的数大于当前数，将他后移 if (arr[j] &gt; temp) &#123; arr[j + 1] = arr[j]; &#125; else &#123; break; &#125; &#125; // 将当前轮数的数放到应该在的位置 arr[j + 1] = temp; System.out.println(\"j === \" + j); System.out.println(\"temp === \" + temp); System.out.println(Arrays.toString(arr)); &#125; &#125;&#125; 具体排序过程如下： 当 i = 1 时，temp = arr[1] = 3，即有序表为{3}, 无序表为 {1, 5, 6, 2}, 然后遍历 arr[1] 之前的元素，即 {5}，只有一个元素 arr[0]，并且比 temp 大，则将该元素向后移，即 arr[1] = arr[0] = 5，遍历结束后，j = -1，arr[-1 + 1] = temp = 3。此时序列为 {3, 5, 4, 6, 2}，有序表为{3, 5}，无序表为 {4, 6, 2}。 当 i = 2 时，temp = arr[2] = 4，然后遍历 arr[2] 之前的元素，即 {3, 5}，发现 arr[1] 比 temp 大，则将该元素向后移，即，arr[2] = arr[1] = 5，遍历结束后，j = 0，arr[0 + 1] = temp = 4。此时序列为 {3, 4, 5, 6, 2}，有序表为{3, 4, 5}，无序表为 {6, 2}。 当 i = 3 时，temp = arr[3] = 6，然后遍历 arr[3] 之前的元素，即 {3, 4, 5}，发现没有元素比 temp 大，遍历结束后，j = 2，arr[2 + 1] = temp = 6。此时序列为 {3, 4, 5, 6, 2}，有序表为{3, 4, 5, 6}，无序表为 {2}。 当 i = 4 时，temp = arr[4] = 2，然后遍历 arr[4] 之前的元素，即 {3, 4, 5, 6}，发现所有元素都比 temp 大，则将所有元素都向后移，遍历结束后，j = -1，arr[-1 + 1] = temp = 2。此时序列为 {2，3, 4, 5, 6}，排序完成。 直接插入排序复杂度分析在最好的情况下，排序的表本身有序，比较次数为 n - 1 次，时间复杂度为 O(n)。当最坏的情况下，即待排序表时逆序的情况，比如 {6, 5, 4, 3, 2}，此时需要比较 2 + 3 + … + n = (n + 2)(n - 1) / 2 次。时间复杂度还是 O(n2)。 显然，直接插入排序在记录本身就是基本有序的时候相对冒泡和简单选择排序而言是非常高效的，此时我们只需要少量的插入操作，就可以完成整个排序操作。","categories":[{"name":"数据结构","slug":"data-structure","permalink":"https://haohaio.github.io/categories/data-structure/"}],"tags":[{"name":"排序","slug":"排序","permalink":"https://haohaio.github.io/tags/排序/"}]},{"title":"排序之简单选择排序","slug":"sort-select","date":"2019-10-15T01:27:26.000Z","updated":"2020-04-09T07:21:45.769Z","comments":true,"path":"data-structure/select-sort.html","link":"","permalink":"https://haohaio.github.io/data-structure/select-sort.html","excerpt":"","text":"先来看下简单选择排序的基本思想： 简单选择排序法（Simple Selection Sort）就是在要排序的一组记录中，选出关键字最小（或者最大）的一个数与第 1 个位置的数交换；然后在剩下的数中再找最小（或者最大）的与第 2 个位置的数交换，以此类推，直到第 n-1 个元素（倒数第二个数）和第 n 个元素（最后一个数）比较为止。 接下来看下代码： public class SelectSort &#123; public static void main(String[] args) &#123; int[] arr = &#123;9, 1, 5, 8, 3, 7, 4, 6, 2&#125;; selectSort(arr); for (int i = 0; i &lt; arr.length; i++) &#123; System.out.println(arr[i]); &#125; &#125; static void selectSort(int[] arr) &#123; int min; for (int i = 0; i &lt; arr.length; i++) &#123; min = i; for (int j = i + 1; j &lt; arr.length; j++) &#123; if (arr[min] &gt; arr[j]) &#123; min = j; &#125; &#125; if (i != min) &#123; int temp = arr[i]; arr[i] = arr[min]; arr[min] = temp; &#125; &#125; &#125;&#125; 可以看到代码并不难理解，针对关键字序列 {9, 1, 5, 8, 3, 7, 4, 6, 2}，当 i = 0 时，我们进行了 8 次计较，但只进行了一次交换。当 i = 2 时，进行 7 次比较，一次交换，之后比较和交换完全雷同，最多完成 8 次交换，就可完成排序工作。 简单选择排序复杂度分析可以看到无论在什么情况下，其比较次数都是一样的多，需要比较 (n - 1) + … + 3 + 2 + 1 = n * (n - 1) / 2 次，因此总的时间复杂度为 O(n2)。而对于交换次数而言，在最优的情况下，交换 0 次，在最差的情况下，交换 n - 1 次。 尽管时间复杂度与冒泡排序相同，但在最差情况下，交换次数是明显少于冒泡排序的，因此，简单选择排序的性能还是略优于冒泡排序的。","categories":[{"name":"数据结构","slug":"data-structure","permalink":"https://haohaio.github.io/categories/data-structure/"}],"tags":[{"name":"排序","slug":"排序","permalink":"https://haohaio.github.io/tags/排序/"}]},{"title":"排序之冒泡排序","slug":"sort-bubble","date":"2019-10-13T03:56:56.000Z","updated":"2020-04-09T07:21:45.770Z","comments":true,"path":"data-structure/bubble-sort.html","link":"","permalink":"https://haohaio.github.io/data-structure/bubble-sort.html","excerpt":"","text":"先来看一下冒泡排序的基本思想： 冒泡排序（Bubble Sort）是一种交换排序，它的基本思想是：两两比较相邻记录的关键字，如果反序则交换，这倒没有反序的记录为止。 最简单排序实现接下来看下最简单的排序代码： public class BubbleSort &#123; public static void main(String[] args) &#123; int[] ary = &#123;9, 1, 5, 8, 3, 7, 4, 6, 2&#125;; bubleSort(ary); for (int i = 0; i &lt; ary.length; i++) &#123; System.out.println(ary[i]); &#125; &#125; static void bubleSort(int[] list) &#123; int len = list.length; for (int i = 0; i &lt; len; i++) &#123; for (int j = i + 1; j &lt; len; j++) &#123; if (list[i] &gt; list[j]) &#123; int temp = list[i]; list[i] = list[j]; list[j] = temp; &#125; &#125; &#125; &#125;&#125; 但这段代码，严格意义上来上并不算是标准的冒泡排序，因为它不满足“两两比较相邻记录”的冒泡排序思想，它应该是最最简单的交换排序而已。它的思路就是让每一个关键字，都与他后面的每一个关键字比较，如果大则交换，这样第一位置的关键字在依次循环后一定变成最小值。假设我们待排序的关键字序列为{9, 1, 5, 8, 3, 7, 4, 6, 2}，排序过程如下图所示： 但是这种排序是有缺陷的。在排序好 1 和 2 的位置后，对其余关键字的排序并没有什么帮助（数字 3 反而还被换到了最后一位）。也就是说，这个算法的效率是非常低的。 冒泡排序算法让我们看看正宗的排序算法 public class BubbleSort &#123; public static void main(String[] args) &#123; int[] arr = &#123;9, 1, 5, 8, 3, 7, 4, 6, 2&#125;; bubleSort(arr); for (int i = 0; i &lt; arr.length; i++) &#123; System.out.println(arr[i]); &#125; &#125; static void bubleSort(int[] list) &#123; int len = list.length; for (int i = 0; i &lt; len; i++) &#123; // 注意 j 是从后往前循环 for (int j = len - 2; j &gt;= i; j--) &#123; if (list[j] &gt; list[j + 1]) &#123; int temp = list[j]; list[j] = list[j + 1]; list[j + 1] = temp; &#125; &#125; &#125; &#125;&#125; 依然假设我们待排序的关键字为{9, 1, 5, 8, 3, 7, 4, 6, 2}，当 i = 1 时，排序过程如下： 在第一次循环中，我们还将关键字 2 从第 9 排到了第 3 的位置，显然这种算法比前面的算法要有进步。图中较小的数字如同气泡般慢慢浮到上面，因此就将此算法命名为冒泡算法。 我们也可以让 j 从前往后遍历，前后两两比较时，仍然是较小数字向上冒泡，只不过在第一次循环后，最大的数字 9 排在了最后面，代码如下（回想起来，笔者第一次学习冒泡排序就是这个样子的）： public class BubbleSort &#123; public static void main(String[] args) &#123; int[] arr = &#123;9, 1, 5, 8, 3, 7, 4, 6, 2&#125;; bubleSort(arr); for (int i = 0; i &lt; arr.length; i++) &#123; System.out.println(arr[i]); &#125; &#125; static void bubleSort(int[] list) &#123; int len = list.length; for (int i = 0; i &lt; len; i++) &#123; // 注意 j 是从后往前循环 for (int j = 0; j &lt; len - 1 - i; j++) &#123; if (list[j] &gt; list[j + 1]) &#123; int temp = list[j]; list[j] = list[j + 1]; list[j + 1] = temp; &#125; &#125; &#125; &#125;&#125; 冒泡排序优化这样的冒泡排序是否还可以优化呢？答案是肯定的。假设待排序的序列为 {2, 1, 3, 4, 5, 6, 7, 8, 9}，也就是说，除了第一和第二位的关键字需要交换外，别的都已经是正常的顺序。当 i = 1 时，交换了 2 和 1，此时序列已经有序，但是算法扔不依不饶地将 i = 2 到 9 以及 j 中循环都执行了一遍，尽管没有进行交换，但之后的比较还是多余了。 当 i = 2 时，我们已经可以发现没有数据需要交换，这是就说明序列已经有序，不需要进行后续的判断了。因此我们可以这样改进： public class BubbleSort &#123; public static void main(String[] args) &#123; int[] arr = &#123;2, 1, 3, 4, 5, 6, 7, 8, 9&#125;; bubleSort(arr); for (int i = 0; i &lt; arr.length; i++) &#123; System.out.println(arr[i]); &#125; &#125; static void bubleSort(int[] list) &#123; boolean flag = true; int len = list.length; for (int i = 0; i &lt; len &amp;&amp; flag; i++) &#123; flag = false; // 注意 j 是从后往前循环 for (int j = len - 2; j &gt;= i; j--) &#123; if (list[j] &gt; list[j + 1]) &#123; flag = true; // 如果有数据交换，则 flag 为 true int temp = list[j]; list[j] = list[j + 1]; list[j + 1] = temp; &#125; &#125; &#125; &#125;&#125; 代码改动的关键就在 i 的 for 循环中，增加了对 flag 是否为 true 的判断。经过这样的改进，冒泡排序在性能上就有了一定的提升，可以避免在已经有序的情况下的无意义循环判断。 冒泡排序复杂度分析在改进后的代码情况下，在最好的情况下，也就是要排序的表本身就是有序的，那么我们只需进行 n - 1 次比较，时间复杂度为 O(n)。在最坏的情况下，即待排序表为逆序的情况，此时需要比较 (n - 1) + … + 3 + 2 + 1 = n * (n - 1) / 2 次，因此总的时间复杂度为 O(n2)。 参考《大话数据结构》","categories":[{"name":"数据结构","slug":"data-structure","permalink":"https://haohaio.github.io/categories/data-structure/"}],"tags":[{"name":"排序","slug":"排序","permalink":"https://haohaio.github.io/tags/排序/"}]},{"title":"TypeScript 之 Enum","slug":"typescript-enum","date":"2019-07-31T03:23:48.000Z","updated":"2020-04-09T07:21:45.889Z","comments":true,"path":"front-end/typescript-enum.html","link":"","permalink":"https://haohaio.github.io/front-end/typescript-enum.html","excerpt":"","text":"TypeScript支持基于数字和字符串的枚举。 数字枚举// Direction.Up的值为 0, 其余的成员会从 0 开始递增enum Direction &#123; Up, Down, Left, Right&#125;// 从 1 开始递增enum Direction &#123; Up = 1, Down, Left, Right&#125; 枚举的使用我们可以通过枚举的属性来访问枚举成员 enum Result &#123; No, Yes&#125;function respond(recipient: string, message: Result): void &#123; // ...&#125;respond(\"Princess Caroline\", Result.Yes) 字符串枚举相对于数字枚举而言，字符串枚举的可读性更强，但字符串枚举没有自增长的行为。 enum Direction &#123; Up = \"UP\", Down = \"DOWN\", Left = \"LEFT\", Right = \"RIGHT\",&#125; 异构枚举（Heterogeneous enums）从技术的角度来说，枚举可以混合字符串和数字成员，但是一般也不会这么做。 enum BooleanLikeHeterogeneousEnum &#123; No = 0, Yes = \"YES\",&#125; 常量成员和计算成员常量成员枚举成员使用 常量枚举表达式 初始化。常数枚举表达式是 TypeScript 表达式的子集，它可以在编译阶段求值。 当一个表达式满足下面条件之一时，它就是一个常量枚举表达式： 一个枚举表达式字面量（主要是字符串字面量或数字字面量） 一个对之前定义的常量枚举成员的引用（可以是在不同的枚举类型中定义的） 带括号的常量枚举表达式 一元运算符 +, -, ~其中之一应用在了常量枚举表达式 常量枚举表达式做为二元运算符 +, -, *, /, %, &lt;&lt;, &gt;&gt;, &gt;&gt;&gt;, &amp;, |, ^的操作对象。 若常数枚举表达式求值后为 NaN 或 Infinity，则会在编译阶段报错。 计算成员所有非常量成员情况的枚举成员被当作是计算成员。 enum FileAccess &#123; // 常量成员 None, Read = 1 &lt;&lt; 1, Write = 1 &lt;&lt; 2, ReadWrite = Read | Write, // 计算成员 G = \"123\".length&#125; const 枚举为了避免在额外生成的代码上的开销和额外的非直接的对枚举成员的访问，我们可以使用 const枚举。 const enum Directions &#123; Up, Down, Left, Right&#125;let directions = [Directions.Up, Directions.Down, Directions.Left, Directions.Right] 常量枚举在编辑阶段会被删除，在使用的地方会被内联进来，之所以可以这么做是因为，常量枚举不允许包含计算成员。可以看到编译后的代码是这样的： var directions = [0 /* Up */, 1 /* Down */, 2 /* Left */, 3 /* Right */]; 常量枚举内包含计算成员时，会报错： const enum FileAccess &#123; None, Read = 1 &lt;&lt; 1, Write = 1 &lt;&lt; 2, ReadWrite = Read | Write, G = \"123\".length // Error: const enum member initializers can only contain literal values and other computed enum values.&#125; 再看下非 const 枚举编译后的代码： var Directions;(function (Directions) &#123; Directions[Directions[\"Up\"] = 0] = \"Up\"; Directions[Directions[\"Down\"] = 1] = \"Down\"; Directions[Directions[\"Left\"] = 2] = \"Left\"; Directions[Directions[\"Right\"] = 3] = \"Right\";&#125;)(Directions || (Directions = &#123;&#125;));var directions = [Directions.Up, Directions.Down, Directions.Left, Directions.Right];","categories":[{"name":"前端","slug":"front-end","permalink":"https://haohaio.github.io/categories/front-end/"}],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"https://haohaio.github.io/tags/TypeScript/"}]},{"title":"TypeScript 之 Generics","slug":"typescript-generics","date":"2019-07-31T02:35:53.000Z","updated":"2020-04-09T07:21:45.770Z","comments":true,"path":"front-end/typescript-generics.html","link":"","permalink":"https://haohaio.github.io/front-end/typescript-generics.html","excerpt":"","text":"泛型变量我们可以在不知道函数参数类型的情况下，使用泛型来保证返回值的类型与传入参数的类型相同： // 为函数添加类型变量 T。T 帮助我们捕获用户传入的类型（比如：number），之后我们再次使用了 T 当做返回值类型。function identity&lt;T&gt;(arg: T): T &#123; return arg;&#125; 我们使用泛型创建了泛型函数后，可以这样调用： // 传入所有的参数，包括类型参数。明确的指定了 T 是 string 类型let output = identity&lt;string&gt;(\"myString\"); 或者： // 利用了类型推论，编译器会根据传入的参数自动地帮助我们确定 T 的类型let output = identity(\"myString\"); 我们还可以把我们把泛型变量 T 当做类型的一部分使用： function loggingIdentity&lt;T&gt;(arg: Array&lt;T&gt;): Array&lt;T&gt; &#123; console.log(arg.length); // Array has a .length return arg;&#125; function loggingIdentity&lt;T&gt;(arg: T[]): T[] &#123; console.log(arg.length); // Array has a .length return arg;&#125; 泛型接口我们可以使用接口来定义函数类型： interface GenericIdentityFn &#123; &lt;T&gt;(arg: T): T;&#125;function identity&lt;T&gt;(arg: T): T &#123; return arg;&#125;let myIdentity: GenericIdentityFn = identity; 我们还可以把泛型参数当作整个接口的一个参数，这样我们就能清楚的知道使用的具体是哪个泛型类型： interface GenericIdentityFn&lt;T&gt; &#123; (arg: T): T;&#125;function identity&lt;T&gt;(arg: T): T &#123; return arg;&#125;let myIdentity: GenericIdentityFn&lt;number&gt; = identity;myIdentity(123); // OKmyIdentity(\"123\"); // Error: 类型“\"123\"”的参数不能赋给类型“number”的参数 泛型类泛型类看上去与泛型接口差不多。 泛型类使用（ &lt;&gt;）括起泛型类型，跟在类名后面。 class GenericNumber&lt;T&gt; &#123; zeroValue: T; add: (x: T, y: T) =&gt; T;&#125;let myGenericNumber = new GenericNumber&lt;number&gt;();myGenericNumber.zeroValue = 0;myGenericNumber.add = function (x, y) &#123; return x + y; &#125;; 可以看到，类中只能使用同一种类型。 泛型约束可以看到下面这个例子中：我们想访问 arg 的 length 属性，但是编译器并不能证明每种类型都有 length 属性，所以就报错了。 function loggingIdentity&lt;T&gt;(arg: T): T &#123; console.log(arg.length); // Error: T doesn't have .length return arg;&#125; 当我们想要限制函数去处理任意带有.length属性的所有类型。 我们需对传入的类型进行约束，要求传出的属性至少包含 length 这一属性。我们可以使用接口和 extends 关键字来实现约束： interface Lengthwise &#123; length: number;&#125;function loggingIdentity&lt;T extends Lengthwise&gt;(arg: T): T &#123; console.log(arg.length); // OK return arg;&#125;loggingIdentity(&#123; length: 3, value: \"123\" &#125;); // OK 使用类型参数进行约束声明一个类型参数，且它被另一个类型参数所约束： // 约束 K 是 T 的 keyfunction getProperty&lt;T, K extends keyof T&gt;(obj: T, key: K) &#123; return obj[key];&#125;let x = &#123; a: 1, b: 2, c: 3, d: 4 &#125;;getProperty(x, \"a\"); // OKgetProperty(x, \"m\"); // Error: Argument of type 'm' isn't assignable to 'a' | 'b' | 'c' | 'd'.","categories":[{"name":"前端","slug":"front-end","permalink":"https://haohaio.github.io/categories/front-end/"}],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"https://haohaio.github.io/tags/TypeScript/"}]},{"title":"TypeScript 之 Function","slug":"typescript-function","date":"2019-07-26T02:45:26.000Z","updated":"2020-04-09T07:21:45.770Z","comments":true,"path":"front-end/typescript-function.html","link":"","permalink":"https://haohaio.github.io/front-end/typescript-function.html","excerpt":"","text":"函数类型和 JavaScript 中的函数一样，我们可以用函数声明和函数表达式两种方式来定义函数。在 TypeScript 中，我们可以为函数定义类型（参数类型和返回值类型）。 function add(x: number, y: number): number &#123; return x + y;&#125;let myAdd = function(x: number, y: number): number &#123; return x + y; &#125;; 在使用函数表达式来定义函数时，我们还可以写出函数的完整类型： let myAdd: (x: number, y: number) =&gt; number = function (x: number, y: number): number &#123; return x + y; &#125;; 推断类型如果你在赋值语句的一边指定了类型但是另一边没有类型的话， TypeScript 编译器会自动识别出类型： // The parameters x and y have the type numberlet myAdd: (baseValue: number, increment: number) =&gt; number = function (x, y) &#123; return x + y; &#125;; 这叫做“按上下文归类”，是类型推论的一种。 它帮助我们更好地为程序指定类型。 函数参数在正常情况下，TypeScript 里的每个函数参数都是必须的。 这不是指不能传递 null 或 undefined 作为参数，而是说编译器检查用户是否为每个参数都传入了值。function buildName(firstName: string, lastName: string) &#123; return firstName + \" \" + lastName;&#125;let result1 = buildName(\"Bob\"); // Error: An argument for 'lastName' was not provided.let result2 = buildName(\"Bob\", \"Adams\", \"Sr.\"); // Error: 应有 2 个参数，但获得 3 个。let result3 = buildName(\"Bob\", \"Adams\"); // OK 可选参数JavaScript 里，每个参数都是可选的，可传可不传。 没传参的时候，它的值就是 undefined。 在 TypeScript 里我们可以在参数名旁使用 ? 实现可选参数的功能。 function buildName(firstName: string, lastName?: string) &#123; if (lastName) &#123; return firstName + \" \" + lastName; &#125; else &#123; return firstName; &#125;&#125;let result1 = buildName(\"Bob\"); // OKlet result2 = buildName(\"Bob\", \"Adams\", \"Sr.\"); // Error: 应有 1-2 个参数，但获得 3 个。let result3 = buildName(\"Bob\", \"Adams\"); // OK 可选参数必须跟在必须参数后面。 如果上例我们只想让 firstName 是可选的，那么就必须调整它们的位置，把 firstName 放在后面。 默认参数在 TypeScript 里，我们也可以为参数提供一个默认值，当用户没有传递这个参数或传递的值是 undefined 时，这个参数的值就为默认值。它们叫做有默认初始化值的参数。 function buildName(firstName: string, lastName = \"Smith\") &#123; return firstName + \" \" + lastName;&#125;let result1 = buildName(\"Bob\"); // OK, returns \"Bob Smith\"let result2 = buildName(\"Bob\", undefined); // OK, also returns \"Bob Smith\"let result3 = buildName(\"Bob\", \"Adams\", \"Sr.\"); // Error: 应有 1-2 个参数，但获得 3 个。let result4 = buildName(\"Bob\", \"Adams\"); // OK 剩余参数在JavaScript里，我们可以使用 arguments来访问所有传入的参数。在TypeScript里，当我们想同时操作多个参数，或者并不知道会有多少参数传递进来时，我们可以把所有参数收集到一个变量里： function buildName(firstName: string, ...restOfName: string[]) &#123; return firstName + \" \" + restOfName.join(\" \");&#125;let employeeName = buildName(\"Joseph\", \"Samuel\", \"Lucas\", \"MacKinzie\"); 剩余参数会被当做个数不限的可选参数，可以一个都没有，同样也可以有任意个。 this在 JavaScript 里，this 的值在函数被调用的时候才会指定。在 TypeScript 中也一样。具体可参考 JavaScript 之 This 关于 –noImplicitThis，等之后涉及了在后续补充。 重载如下所示：重载的 pickCard 函数在调用的时候会进行正确的类型检查。查找重载列表时，JavaScript里的处理流程一样，是从上到下查找的，因此，在定义重载的时候，一定要把最精确的定义放在最前面。 function pickCard(x): any 并不是重载列表的一部分，因此这里只有两个重载：一个是接收对象另一个接收数字。 以其它参数调用 pickCard会产生错误。 let suits = [\"hearts\", \"spades\", \"clubs\", \"diamonds\"];function pickCard(x: &#123; suit: string; card: number; &#125;[]): number;function pickCard(x: number): &#123; suit: string; card: number; &#125;;function pickCard(x): any &#123; // Check to see if we're working with an object/array // if so, they gave us the deck and we'll pick the card if (typeof x == \"object\") &#123; let pickedCard = Math.floor(Math.random() * x.length); return pickedCard; &#125; // Otherwise just let them pick the card else if (typeof x == \"number\") &#123; let pickedSuit = Math.floor(x / 13); return &#123; suit: suits[pickedSuit], card: x % 13 &#125;; &#125;&#125;let myDeck = [&#123; suit: \"diamonds\", card: 2 &#125;, &#123; suit: \"spades\", card: 10 &#125;, &#123; suit: \"hearts\", card: 4 &#125;];let pickedCard1 = myDeck[pickCard(myDeck)];alert(\"card: \" + pickedCard1.card + \" of \" + pickedCard1.suit);let pickedCard2 = pickCard(15);alert(\"card: \" + pickedCard2.card + \" of \" + pickedCard2.suit);let pickedCard3 = pickCard(\"123\"); // Error: 类型“\"123\"”的参数不能赋给类型“number”的参数。","categories":[{"name":"前端","slug":"front-end","permalink":"https://haohaio.github.io/categories/front-end/"}],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"https://haohaio.github.io/tags/TypeScript/"}]},{"title":"JavaScript 之 This","slug":"javascript-this","date":"2019-07-26T01:18:49.000Z","updated":"2020-04-09T07:21:45.770Z","comments":true,"path":"front-end/javascript-this.html","link":"","permalink":"https://haohaio.github.io/front-end/javascript-this.html","excerpt":"","text":"JavaScript 的 this 总是指向一个对象，而具体指向那个对象是在运行时基于函数的执行环境动态绑定的，而非函数被声明时的环境。 this 的指向大致可以分为以下4种： 作为对象的方法调用当函数作为对象的方法被调用时，this 指向该对象 var obj = &#123; a: 1, getA: function() &#123; console.log(this === obj); // 输出：true console.log(this.a); // 输出：1 &#125;&#125;obj.getA(); 作为普通函数调用当函数不作为对象的属性被调用时，即普通函数方式，this 总是指向全局对象。在浏览器的 JavaScript 里，这个全局对象是 window 对象。但需要注意的时，在严格模式下， this 为 undefined 而不是 window。 window.name = 'globalName';var getName = function() &#123; return this.name;&#125;console.log(getName()); // 输出：globalName 构造器调用通常情况下，构造器里的 this 就指向返回的这个对象。但当 new 调用构造器时，如果构造器显式地返回了一个object类型的对象，那么运行结果最终会返回这个对象，而不是我们之前期待的this。 var myClass = function() &#123; this.name = 'sven'; return &#123; name: 'anne' &#125;&#125;var obj = new myClass();console.log(obj.name); // 输出：anne Function.prototype.call 或 Function.prototype.apply 调用var obj1 = &#123; name: 'sven', getName: function() &#123; return this.name; &#125;&#125;var obj2 = &#123; name: 'anne'&#125;console.log(obj1.getName()); // 输出：svenconsole.log(obj1.getName.call(obj2)); // 输出：anne 丢失的 thiswindow.name = 'globalName';var myObject = &#123; name: 'sven', getName: function() &#123; return this.name; &#125;&#125;// 对象方法调用console.log(myObject.getName()); // 输出：sven// 定义了一个 getName 的函数，此时为普通函数调用，this 指向了 windowvar getName = myObject.getName;console.log(getName()); // 输出：globalName","categories":[{"name":"前端","slug":"front-end","permalink":"https://haohaio.github.io/categories/front-end/"}],"tags":[{"name":"JavaScript","slug":"javascript","permalink":"https://haohaio.github.io/tags/javascript/"}]},{"title":"TypeScript 之 Class","slug":"typescript-class","date":"2019-07-25T11:52:56.000Z","updated":"2020-04-09T07:21:45.889Z","comments":true,"path":"front-end/typescript-class.html","link":"","permalink":"https://haohaio.github.io/front-end/typescript-class.html","excerpt":"","text":"我们可以像在 Java 里一样，声明一个 Greeter 类，然后使用 new 来构造一个 Greeter 类的实例： class Greeter &#123; greeting: string; constructor(message: string) &#123; this.greeting = message; &#125; greet() &#123; return \"Hello, \" + this.greeting; &#125;&#125;let greeter = new Greeter(\"world\"); 继承和 Java 中一样，类之间是可以继承的。 class Animal &#123; move(distanceInMeters: number = 0) &#123; console.log(`Animal moved $&#123;distanceInMeters&#125;m.`); &#125;&#125;class Dog extends Animal &#123; bark() &#123; console.log('Woof! Woof!'); &#125;&#125;const dog = new Dog();dog.bark();dog.move(10); 在 TypeScript 中，若派生类包含了一个构造函数，它必须调用 super()，它会执行基类的构造函数。而且，在构造函数里访问 this的属性之前，一定要调用 super()。 class Animal &#123; name: string; constructor(theName: string) &#123; this.name = theName; &#125; move(distanceInMeters: number = 0) &#123; console.log(`$&#123;this.name&#125; moved $&#123;distanceInMeters&#125;m.`); &#125;&#125;class Snake extends Animal &#123; constructor(name: string) &#123; super(name); &#125; move(distanceInMeters = 5) &#123; console.log(\"Slithering...\"); super.move(distanceInMeters); &#125;&#125;class Horse extends Animal &#123; constructor(name: string) &#123; super(name); &#125; move(distanceInMeters = 45) &#123; console.log(\"Galloping...\"); super.move(distanceInMeters); &#125;&#125;let sam = new Snake(\"Sammy the Python\");let tom: Animal = new Horse(\"Tommy the Palomino\");sam.move();tom.move(34); 修饰符在TypeScript里，成员都默认为 public。 private当成员被标记成 private时，它就不能在声明它的类的外部访问。比如： class Animal &#123; private name: string; constructor(theName: string) &#123; this.name = theName; &#125;&#125;new Animal(\"Cat\").name; // Error: 属性“name”为私有属性，只能在类“Animal”中访问。 protectedprotected 修饰符与 private 修饰符的行为很相似，但有一点不同，protected 成员在派生类中仍然可以访问。例如： class Person &#123; protected name: string; constructor(name: string) &#123; this.name = name; &#125;&#125;class Employee extends Person &#123; private department: string; constructor(name: string, department: string) &#123; super(name) this.department = department; &#125; public getElevatorPitch() &#123; return `Hello, my name is $&#123;this.name&#125; and I work in $&#123;this.department&#125;.`; &#125;&#125;let howard = new Employee(\"Howard\", \"Sales\");console.log(howard.getElevatorPitch());console.log(howard.name); // Error readonlyclass Octopus &#123; readonly name: string; readonly numberOfLegs: number = 8; constructor(theName: string) &#123; this.name = theName; &#125;&#125;let dad = new Octopus(\"Man with the 8 strong legs\");dad.name = \"Man with the 3-piece suit\"; // Error: Cannot assign to 'name' because it is a read-only property. 参数属性参数属性可以方便地让我们在一个地方定义并初始化一个成员。 参数属性通过给构造函数参数前面添加一个访问限定符来声明。public、private、protected、readonly 都可以。 // 调用构造器方法时候，会定义并初始化一个 readonly 的 name 属性class Octopus &#123; readonly numberOfLegs: number = 8; constructor(readonly name: string) &#123; &#125;&#125; 存取器TypeScript支持通过getters/setters来截取对对象成员的访问。但与 Java 不同的是，添加了 getters/setters 方法后，我们还是使用 . 来存取这个属性 let passcode = \"secret passcode\";class Employee &#123; private _fullName: string; get fullName(): string &#123; return this._fullName; &#125; set fullName(newName: string) &#123; if (passcode &amp;&amp; passcode == \"secret passcode\") &#123; this._fullName = newName; &#125; else &#123; console.log(\"Error: Unauthorized update of employee!\"); &#125; &#125;&#125;let employee = new Employee();employee.fullName = \"Bob Smith\";if (employee.fullName) &#123; alert(employee.fullName);&#125; 静态属性class Grid &#123; static origin = &#123; x: 0, y: 0 &#125;; calculateDistanceFromOrigin(point: &#123; x: number; y: number; &#125;) &#123; let xDist = (point.x - Grid.origin.x); let yDist = (point.y - Grid.origin.y); return Math.sqrt(xDist * xDist + yDist * yDist) / this.scale; &#125; constructor(public scale: number) &#123; &#125;&#125;let grid1 = new Grid(1.0); // 1x scalelet grid2 = new Grid(5.0); // 5x scaleconsole.log(grid1.calculateDistanceFromOrigin(&#123; x: 10, y: 10 &#125;));console.log(grid2.calculateDistanceFromOrigin(&#123; x: 10, y: 10 &#125;)); 抽象类abstract class Department &#123; constructor(public name: string) &#123; &#125; printName(): void &#123; console.log('Department name: ' + this.name); &#125; abstract printMeeting(): void; // 必须在派生类中实现&#125;class AccountingDepartment extends Department &#123; constructor() &#123; super('Accounting and Auditing'); // 在派生类的构造函数中必须调用 super() &#125; printMeeting(): void &#123; console.log('The Accounting Department meets each Monday at 10am.'); &#125; generateReports(): void &#123; console.log('Generating accounting reports...'); &#125;&#125;let department: Department; // 允许创建一个对抽象类型的引用department = new Department(); // Error: 不能创建一个抽象类的实例department = new AccountingDepartment(); // 允许对一个抽象子类进行实例化和赋值department.printName();department.printMeeting();department.generateReports(); // Error: 方法在声明的抽象类中不存在 Tipsclass Greeter &#123; static standardGreeting = \"Hello, there\"; greeting: string; greet() &#123; if (this.greeting) &#123; return \"Hello, \" + this.greeting; &#125; else &#123; return Greeter.standardGreeting; &#125; &#125;&#125;let greeter1: Greeter;greeter1 = new Greeter();console.log(greeter1.greet());// typeof Greeter，意思是取Greeter类的类型，而不是实例的类型。// greeterMaker 包含了 Greeter 类的所有静态成员和构造函数。 let greeterMaker: typeof Greeter = Greeter;greeterMaker.standardGreeting = \"Hey there!\";let greeter2: Greeter = new greeterMaker();console.log(greeter2.greet());","categories":[{"name":"前端","slug":"front-end","permalink":"https://haohaio.github.io/categories/front-end/"}],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"https://haohaio.github.io/tags/TypeScript/"}]},{"title":"TypeScript 之 Interface","slug":"typescript-interface","date":"2019-07-25T02:34:11.000Z","updated":"2020-04-09T07:21:45.890Z","comments":true,"path":"front-end/typescript-interface.html","link":"","permalink":"https://haohaio.github.io/front-end/typescript-interface.html","excerpt":"","text":"TypeScript 的核心原则之一是对值所具有的结构进行类型检查。 在 TypeScript 里，接口的作用就是为这些类型命名和以及定义校验规则。 // 使用接口来描述一个拥有 firstName 和 lastName 字段的对象 (firstName 和 lastName 两个字段是必须的)interface Person &#123; firstName: string; lastName: string;&#125;function greeter(person: Person) &#123; return \"Hello, \" + person.firstName + \" \" + person.lastName;&#125;// 只要保证包含了接口要求的结构就可以（还可有其它字段），顺序也没有要求，也不必明确地使用 implements 语句let user = &#123; firstName: \"Jane\", lastName: \"User\" &#125;;document.body.innerHTML = greeter(user); 可选属性接口里的属性不全都是必需的。 当使用了可选属性时，不能引用接口内不存在的属性 interface SquareConfig &#123; color?: string; width?: number;&#125;function createSquare(config: SquareConfig): &#123; color: string; area: number &#125; &#123; let newSquare = &#123; color: \"white\", area: 100 &#125;; if (config.clor) &#123; // Error：属性“clor”在类型“SquareConfig”上不存在 newSquare.color = config.clor; &#125; if (config.color) &#123; newSquare.color = config.color; &#125; if (config.width) &#123; newSquare.area = config.width * config.width; &#125; return newSquare;&#125;let mySquare = createSquare(&#123; color: \"black\" &#125;);// Error：类型“&#123; color: string; type: string; &#125;”的参数不能赋给类型“SquareConfig”的参数let mySquare = createSquare(&#123; color: \"black\" &#125;); 只读属性interface Point &#123; readonly x: number; readonly y: number;&#125;let p1: Point = &#123; x: 10, y: 20 &#125;;p1.x = 5; // Error TypeScript 具有 ReadonlyArray&lt;T&gt; 类型，它与 Array&lt;T&gt; 相似，只是把所有可变方法去掉了，因此可以确保数组创建后再也不能被修改 let a: number[] = [1, 2, 3, 4];let ro: ReadonlyArray&lt;number&gt; = a;ro[0] = 12; // Error: 类型“readonly number[]”中的索引签名仅允许读取ro.push(5); // Error: 类型“readonly number[]”上不存在属性“push”ro.length = 100; // Error: Cannot assign to 'length' because it is a read-only property.a = ro; // Error: The type 'readonly number[]' is 'readonly' and cannot be assigned to the mutable type 额外的属性检查先来看个栗子： interface SquareConfig &#123; color?: string; width?: number;&#125;function createSquare(config: SquareConfig): &#123; color: string; area: number &#125; &#123; let newSquare = &#123; color: \"white\", area: 100 &#125;; if (config.color) &#123; newSquare.color = config.color; &#125; if (config.width) &#123; newSquare.area = config.width * config.width; &#125; return newSquare;&#125;// Error：类型“&#123; color: string; type: string; &#125;”的参数不能赋给类型“SquareConfig”的参数let mySquare = createSquare(&#123; color: \"black\", type: \"simple\" &#125;); 可以看到，传入 createSquare 的参数内，有 color 和 type 两个属性，type 属性不在 SquareConfig 定义的范围内，此时 TypeScript 会认为这段代码可能存在bug。 这是因为对象字面量会被特殊对待而且会经过额外属性检查，当将它们赋值给变量或作为参数传递的时候。 如果一个对象字面量存在任何“目标类型”不包含的属性时，你会得到一个错误。 我们可以通过类型断言来绕开检查： let mySquare = createSquare(&#123; color: \"black\", type: \"simple\" &#125; as SquareConfig); 然而，最佳的方式是能够添加一个字符串索引签名（前提是我们能够确定这个对象可能具有某些做为特殊用途使用的额外属性） ： interface SquareConfig &#123; color?: string; width?: number; [propName: string]: any;&#125; 还有一种方式可绕开这些检查： let squareOptions = &#123; colour: \"red\", width: 100 &#125;;let mySquare = createSquare(squareOptions); 看上去有些奇怪，我们只是将这个对象赋值给一个另一个变，但由于变量不会经过额外属性检查，所以编译器不会报错。 但我们可能不应该绕开这些检查，而是去审查一下接口，看是否需要对其进行修改。 函数类型我们还可以使用接口来描述函数类型。 interface SearchFunc &#123; (source: string, subString: string): boolean;&#125;let mySearch: SearchFunc;mySearch = function(source: string, subString: string): boolean &#123; let result = source.search(subString); return result &gt; -1;&#125; 对于函数类型的类型检查来说，函数的参数名不需要与接口里定义的名字相匹配。参数类型和返回值类型也可以省略，TypeScript的类型系统会自行推断。 let mySearch: SearchFunc;mySearch = function (src, sub) &#123; let result = src.search(sub); return result &gt; -1;&#125; 可索引的类型我们还可以用接口描述那些能够“通过索引得到”的类型，比如a[10]或ageMap[“daniel”]。 interface StringArray &#123; [index: number]: string;&#125;let myArray: StringArray;myArray = [\"Bob\", \"Fred\"];let myStr: string = myArray[0]; TypeScript支持两种索引签名：字符串和数字。 可以同时使用两种类型的索引，但是数字索引的返回值必须是字符串索引返回值同类型或其子类型。 这是因为当使用 number来索引时，JavaScript会将它转换成string然后再去索引对象。 也就是说用 100（一个number）去索引等同于使用”100”（一个string）去索引，因此两者需要保持一致。 class Animal &#123; name: string;&#125;class Dog extends Animal &#123; breed: string;&#125;// Error：数字索引类型“Animal”不能赋给字符串索引类型“Dog”。interface NotOkay &#123; [x: number]: Animal; [x: string]: Dog;&#125;// OKinterface NotOkay &#123; [x: number]: Dog; [x: string]: Animal;&#125; 类静态部分与实例部分的区别类是具有两个类型的：静态部分的类型和实例的类型。当一个类实现了一个接口时，只对其实例部分进行类型检查。 constructor存在于类的静态部分，所以不在检查的范围内。所以我们不能直接在接口内定义构造器方法，然后让类去实现。 interface ClockConstructor &#123; new(hour: number, minute: number);&#125;// Errorclass Clock implements ClockConstructor &#123; currentTime: Date; constructor(h: number, m: number) &#123; &#125;&#125; 类类型和 Java 里接口的基本作用一样，TypeScript 也能明确的强制一个类去符合某种契约。 interface ClockInterface &#123; currentTime: Date; setTime(d: Date);&#125;class Clock implements ClockInterface &#123; currentTime: Date; setTime(d: Date) &#123; this.currentTime = d; &#125; constructor(h: number, m: number) &#123; &#125;&#125; 继承接口和类一样，接口也可以相互继承。 interface Shape &#123; color: string;&#125;interface PenStroke &#123; penWidth: number;&#125;interface Square extends Shape, PenStroke &#123; sideLength: number;&#125;let square = &lt;Square&gt;&#123;&#125;;square.color = \"blue\";square.sideLength = 10;square.penWidth = 5.0; 混合类型直接看个栗子：一个对象可以同时做为函数和对象使用，并带有额外的属性 interface Counter &#123; (start: number): string; interval: number; reset(): void;&#125;function getCounter(): Counter &#123; let counter = &lt;Counter&gt;function (start: number) &#123; &#125;; counter.interval = 123; counter.reset = function () &#123; &#125;; return counter;&#125;let c = getCounter();c(10);c.reset();c.interval = 5.0; 接口继承类当接口继承了一个类类型时，它会继承类的成员但不包括其实现。 接口同样会继承到类的private和protected成员。 class Control &#123; private state: any;&#125;interface SelectableControl extends Control &#123; select(): void;&#125;class Button extends Control implements SelectableControl &#123; select() &#123; &#125;&#125;class TextBox extends Control &#123; select() &#123; &#125;&#125;// 错误：“Image”类型缺少“state”属性。class Image implements SelectableControl &#123; select() &#123; &#125;&#125;","categories":[{"name":"前端","slug":"front-end","permalink":"https://haohaio.github.io/categories/front-end/"}],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"https://haohaio.github.io/tags/TypeScript/"}]},{"title":"TypeScript 之 类型","slug":"typescript-type","date":"2019-07-24T07:09:28.000Z","updated":"2020-04-09T07:21:45.769Z","comments":true,"path":"front-end/typescript-type.html","link":"","permalink":"https://haohaio.github.io/front-end/typescript-type.html","excerpt":"","text":"基础类型booleanlet isDone: boolean = false; numberlet count: number = 6; stringlet name: string = \"bob\"; 数组有两种方式可以定义数组 // 在元素类型后面接上 []let list: number[] = [1, 2, 3];// 使用数组泛型，Array&lt;元素类型&gt;let list: Array&lt;number&gt; = [1, 2, 3]; Tuple（元组）表示一个已知元素数量和类型的数组，各元素的类型不必相同 // Declare a tuple typelet x: [string, number];x = ['hello', 10]; // OKx = [10, 'hello']; // Error// 当访问一个已知索引的元素，会得到正确的类型：console.log(x[0].substr(1)); // OKconsole.log(x[1].substr(1)); // Error, 'number' does not have 'substr'// 当访问一个越界的元素，会使用联合类型替代：x[3] = 'world'; // OK, 字符串可以赋值给(string | number)类型console.log(x[5].toString()); // OK, 'string' 和 'number' 都有 toStringx[6] = true; // Error, 布尔不是(string | number)类型 enumenum Color &#123;Red, Green, Blue&#125;// 默认情况下，从0开始为元素编号，也可以手动的指定成员的数值。enum Color &#123;Red = 1, Green, Blue&#125;// 或者全部手动指定成员的数值enum Color &#123;Red = 1, Green = 2, Blue = 4&#125;// 我们可以由枚举值得到它的名字enum Color &#123;Red = 1, Green, Blue&#125;let colorName: string = Color[2];console.log(colorName); // 显示'Green'因为上面代码里它的值是2 anylet notSure: any = 4;notSure = \"maybe a string instead\";notSure = false;let list: any[] = [1, true, \"free\"]; void表示没有任何类型。 // 当一个函数没有返回值时，其返回值类型是 void。function warnUser(): void &#123; console.log(\"This is my warning message\");&#125;// 声明一个void类型的变量没有什么大用，因为你只能为它赋予undefined和nulllet unusable: void = undefined; undefined 和 null默认情况下 null 和 undefined 是所有类型的子类型，即可以将它们赋值为其它的类型。其本身的类型用处不是很大。 let u: undefined = undefined;let n: null = null;// 但当指定了--strictNullChecks 标记，null 和 undefined 只能赋值给 void 和它们各自let count: number = undefined; never表示的是那些永不存在的值的类型。 // 返回 never 的函数必须存在无法达到的终点function error(message: string): never &#123; throw new Error(message);&#125;// 推断的返回值类型为 neverfunction fail() &#123; return error(\"Something failed\");&#125;// 返回 never 的函数必须存在无法达到的终点function infiniteLoop(): never &#123; while (true) &#123; &#125;&#125; object表示非原始类型，也就是除number，string，boolean，symbol，null或undefined之外的类型。 declare function create(o: object | null): void;create(&#123; prop: 0 &#125;); // OKcreate(null); // OKcreate(42); // Errorcreate(\"string\"); // Errorcreate(false); // Errorcreate(undefined); // Error 高级类型交叉类型交叉类型是将多个类型合并为一个类型： function extend&lt;T, U&gt;(first: T, second: U): T &amp; U &#123; let result = &lt;T &amp; U&gt;&#123;&#125;; for (let id in first) &#123; (&lt;any&gt;result)[id] = (&lt;any&gt;first)[id]; &#125; for (let id in second) &#123; if (!result.hasOwnProperty(id)) &#123; (&lt;any&gt;result)[id] = (&lt;any&gt;second)[id]; &#125; &#125; return result;&#125;class Person &#123; constructor(public name: string) &#123; &#125;&#125;interface Loggable &#123; log(): void;&#125;class ConsoleLogger implements Loggable &#123; log() &#123; // ... &#125;&#125;var jim = extend(new Person(\"Jim\"), new ConsoleLogger());var n = jim.name;jim.log(); 联合类型（Union Types）function padLeft(value: string, padding: string | number) &#123; // ...&#125;let indentedString = padLeft(\"Hello world\", true); // Error: 类型“true”的参数不能赋给类型“string | number”的参数 类型断言类型断言好比其它语言里的类型转换，但是不进行特殊的数据检查和解构。 它没有运行时的影响，只是在编译阶段起作用。 TypeScript会假设你已经进行了必须的检查。 类型断言有两种形式： let someValue: any = \"this is a string\";let strLength: number = (&lt;string&gt;someValue).length;// 在JSX中，只能使用 as 语法断言。let someValue: any = \"this is a string\";let strLength: number = (someValue as string).length;let someValue: number = 123;let strLength: number = (someValue as string).length; // Error: Conversion of type 'number' to type 'string' may be a mistakelet someValue: any = 123;let strLength: number = (someValue as string).length; // OKlet someValue: any = [1, 2, 3];let strLength: number = (someValue as string).length; // OK 类型推论TypeScript 里，在有些没有明确指出类型的地方，类型推论会帮助提供类型。 最佳通用类型最终的通用类型取自候选类型，计算通用类型算法会考虑所有的候选类型，并给出一个兼容所有候选类型的类型。 let x = 3; // x: numberlet x = [0, 1, null]; // x: number[]let x = [0, 1, \"hello\"]; // x: (string | number)[] 当候选类型共享相同的通用类型，但类型推论并不能帮我们推论出这个通用类型，此时我们可以手动指出这个通用类型 // Rhino、Elephant、Snake 均继承自 Animallet zoo = [new Rhino(), new Elephant(), new Snake()]; // (Rhino | Elephant | Snake)[]// 指出通用类型let zoo: Animal[] = [new Rhino(), new Elephant(), new Snake()]; 上下文类型TypeScript类型推论也可能按照相反的方向进行。 这被叫做“按上下文归类”: // mouseEvent 会被推断为 MouseEvent 类型window.onmousedown = function (mouseEvent) &#123; console.log(mouseEvent.number); // Error: 类型 MouseEvent 上不存在属性 number&#125;; // 当上下文类型表达式包含了明确的类型信息，上下文的类型被忽略window.onmousedown = function (mouseEvent: any) &#123; console.log(mouseEvent.number); // OK&#125;;","categories":[{"name":"前端","slug":"front-end","permalink":"https://haohaio.github.io/categories/front-end/"}],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"https://haohaio.github.io/tags/TypeScript/"}]},{"title":"设计模式之 Factory","slug":"design-patterns-factory","date":"2019-06-26T14:05:50.000Z","updated":"2020-04-09T07:21:45.770Z","comments":true,"path":"front-end/design-patterns-factory.html","link":"","permalink":"https://haohaio.github.io/front-end/design-patterns-factory.html","excerpt":"","text":"简单工厂模式简单工厂其实并不算是一种设计模式，反而比较像是一种编程习惯。让我们先来看一下它的概念： 定义一个工厂类，根据传入的参数不同返回不同的实例，被创建的实例具有共同的父类或接口。 直接来个栗子说明一下，下面是两个汽车类，都实现了 Car 的接口： public interface Car &#123; public void run();&#125;public class AudiCar implements Car &#123; @Override public void run() &#123; System.out.println(\"奥迪\"); &#125;&#125;public class BenzCar implements Car &#123; @Override public void run() &#123; System.out.println(\"奔驰\"); &#125;&#125; 下面是工厂类的具体实现： public class CarFactory &#123; public static Car createCar(String carType) &#123; Car car = null; if (carType.equals(\"Audi\")) &#123; car = new CarAudi(); &#125; else if (carType.equals(\"Benz\")) &#123; car = new CarBenz(); &#125; return car; &#125;&#125; 在这个工厂类中通过传入不同的 carType 可以 new 出不同的 Car，结果返回 Car 类型。我们可以这样进行使用： // 创建一辆奥迪类汽车Car audi = CarFactory.createCar(\"Audi\");audi.run();// 创建一辆奔驰类汽车Car benz = CarFactory.createCar(\"Benz\");benz.run(); 简单工厂模式的最大优点在于工厂类中包含了必要的逻辑判断，根据客户端的选择条件动态实例化相关的类，对于客户端来说，去除了与具体产品的依赖。 这就是简单工厂模式了，是不是 so easy ~~ 但是当我们需要扩展的时候，例如我们需要创建宝马类的汽车时，不仅需要新增一个 BMWCar 类，还需要对 CarFactory 内部的 createCar 方法，很明显这是违背了开放-封闭原则的。这就引出了工厂方法模式~~ 工厂方法模式 (Factory Method) 定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。 还是直接来个栗子： public interface CarFactory &#123; public Car createCar();&#125;public class AudiCarFactory implements CarFactory &#123; @Override public Car createCar() &#123; return new AudiCar(); &#125;&#125;public class BenzCarFactory implements CarFactory &#123; @Override public Car createCar() &#123; return new BenzCar(); &#125;&#125; CarFactory carFactory;carFactory = new AudiCarFactory();Car audi = carFactory.createCar();audi.run();carFactory = new BenzCarFactory(); // 只需要替换工厂类，就可以创建其它种类的汽车了Car benz = carFactory.createCar();benz.run(); 此时当我们需要创建宝马类的汽车时，我们只需要新增一个 BMWCar 类和一个 BMWCarFactory 类就行了，不会再对原有的代码进行修改了。 简单工厂模式和工厂方法模式都是集中封装的对象的，使得创建时要更换对象时，不需要做大的改动就可实现，降低了客户端与具体产品的耦合。工厂方法模式是简单工厂模式的进一步抽象和推广。工厂方法模式保持了简单工厂模式的优点，而且克服了简单工厂模式违背开放-封闭原则的缺点。但缺点是由于每增加一个产品，就需要加一个产品工厂的类，增加了额外的开发量。 抽象工厂模式 (Abstract Factory) 提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。 当我们的汽车工厂不仅仅生产汽车，还需要生产各种汽车配件时。按照工厂方法模式来设计的话，当我们要生产各个品牌的发动机时，就新增一个 EngineFactory 以及相关类，当我们需要生成各个品牌的轮胎时，就新增一个 TyreFactory 以及相关类… 很明显这又违背了我们的依赖倒置原则。依赖倒置原则是说抽象不应该依赖于细节，细节应当依赖于抽象。换言之，要针对抽象（接口）编程，而不是针对实现细节编程。 从用户的角度来看就是, 通过尽量少的接口变化, 来尽量多地满足需求变化。因为用户只关心调用创建对象的接口, 而不关心对象是如何创建出来的。这时候就引出来抽象工厂模式了，还是举个栗子说明一下： // 新增 Engine 接口、AudiEngine 类、BenzEngine 类以及 Tyre 接口、AudiTyre 类、BenzTyre 类 public interface CarFactory &#123; public Car createCar(); // 创建发动机接口 public Engine createEngine(); // 创建轮胎接口 public Tyre createTyre();&#125; // AudiCarFactory 类、BenzCarFactory 类实现 createEngine 和 createTyre 接口 CarFactory carFactory;carFactory = new AudiCarFactory();Car audi = carFactory.createCar();Engine audiEngine = carFactory.createEngine();Tyre audiTyre = carFactory.createTyre();carFactory = new BenzCarFactory();Car audi = carFactory.createCar();Engine benzEngine = carFactory.createEngine();Tyre benzTyre = carFactory.createTyre(); 可以看到，抽象工厂模式是就是对工厂方法模式的进一步优化。简单来讲，工厂方法只提供了一个方法用来创建一个产品，而抽象工厂提供了一组接口可用来创建一组相关的产品。 但是不知道大家注意了没有，当我们需要扩展的时候，比如我们要生产一种其它的汽车配件时，就会发现我们需要对原有的代码进行修改，这又违背了开放-封闭原则。。。","categories":[{"name":"前端","slug":"front-end","permalink":"https://haohaio.github.io/categories/front-end/"}],"tags":[{"name":"DesignPatterns","slug":"DesignPatterns","permalink":"https://haohaio.github.io/tags/DesignPatterns/"}]},{"title":"设计模式之 Singleton","slug":"design-patterns-singleton","date":"2019-06-24T09:29:34.000Z","updated":"2020-04-09T07:21:45.770Z","comments":true,"path":"front-end/design-patterns-singleton.html","link":"","permalink":"https://haohaio.github.io/front-end/design-patterns-singleton.html","excerpt":"","text":"Singleton 可以说是设计模式中最简单的一个模式了，但是我们要想用好它的话，也不简单~~ 我们先来看一下单例模式的概念： 保证一个类仅有一个实例，并提供一个访问它的全局访问点。 Java 中的单例下面我们先来看在 Java 中如何实现单例模式： 懒汉式（需要的时候才会去实例化），教科书版本class Singleton &#123; private static Singleton instance = null; private Singleton() &#123; &#125; public static Singleton getInstance() &#123; if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125;&#125; 但是很明显，这样实现单例会有线程安全的问题，当有多个线程并行调用 getInstance() 方法的时候，就会创建多个 instance 实例。 懒汉式，同步方法为了解决上面的问题，最简单的方法是将整个 getInstance() 方法设为同步（synchronized）。 class Singleton &#123; private static Singleton instance = null; private Singleton() &#123; &#125; public static synchronized Singleton getInstance() &#123; if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125;&#125; 虽然做到了线程安全，并且解决了多实例的问题，但是它并不高效。因为在任何时候只能有一个线程调用 getInstance() 方法，该线程调用结束后才能被其他的线程调用。 懒汉式，同步代码块上面的同步方法 synchronized 的范围是整个方法, 而同步代码块方法将 synchronized 的范围缩小为 Block class Singleton &#123; private static Singleton instance = null; private Singleton() &#123; &#125; public static Singleton getInstance() &#123; if (instance == null) &#123; synchronized(Singleton.class) &#123; instance = new Singleton(); &#125; &#125; return instance; &#125;&#125; 看起来我们进行了改进，现在多个线程可同时调用 getInstance() 方法，但是又造成了线程不安全的问题。当同步代码块结束后立即被其它线程抢占了，也可以执行同步代码块内的代码，这就会和教科书版本一样创建了多个 instance 实例。 懒汉式，双重检验锁双重检验锁模式（double checked locking pattern），之所以称其为双重检查锁，是因为会有两次检查 instance == null，一次是在同步块外，一次是在同步块内。 class Singleton &#123; private volatile static Singleton instance; private Singleton() &#123; &#125; public static Singleton getInstance() &#123; if (instance == null) &#123; synchronized (Singleton.class) &#123; if (instance == null) &#123; instance = new Singleton(); &#125; &#125; &#125; return instance; &#125;&#125; 现在看起来已经线程安全了，但是还是有问题的。因为 instance = new Singleton() 这句，这并非是一个原子操作。事实上在 JVM 中这句话大概做了下面 3 件事情： 给 instance 分配内存 调用 Singleton 的构造函数来初始化成员变量 将instance对象指向分配的内存空间（执行完这步 instance 就为非 null 了） 但是在 JVM 的即时编译器中存在指令重排序(Re-Order)的优化。也就是说上面的第二步和第三步的顺序是不能保证的，最终的执行顺序可能是 1-2-3 也可能是 1-3-2。 如果是后者，则在 3 执行完毕、2 未执行之前，被其它线程抢占了，这时 instance 已经是非 null 了（但却没有初始化），所以其它线程会直接返回 instance，但是得到的instance是还没有完全构造的对象，然后就会顺理成章地报错。 懒汉式，双重检验锁 + volatile在 JDK5 以后，我们可以使用 volatile 关键字来解决这个问题，将变量声明成 volatile 以禁止 JVM 指令重排序(Re-Order)优化。 public class Singleton &#123; // 声明成 volatile private volatile static Singleton instance; private Singleton ()&#123; &#125; public static Singleton getSingleton() &#123; if (instance == null) &#123; synchronized (Singleton.class) &#123; if (instance == null) &#123; instance = new Singleton(); &#125; &#125; &#125; return instance; &#125;&#125; 这样终于是和同步方法版本一样可靠了~~ 饿汉式 (当 class 文件被加载的时候，初始化单例)class Singleton &#123; private static final Singleton instance = new Singleton(); private Singleton() &#123; &#125; public static Singleton getInstance() &#123; return instance; &#125;&#125; 看起来非常简单，并且天生是线程安全的。如果不考虑 Lazy Loading 带来的这些微小的内存消耗和优化的话，看起来这是一个很不错的选择。 iOS 中的单例再让我们看一下 iOS 中是怎么实现单例模式的： 这里就不考虑 使用 new、alloc] init]、copy 等方法可以创造出不同对象的问题了。 + (instancetype)getInstance &#123; static Singleton *instance = nil; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; instance = [[self alloc] init]; &#125;); return instance;&#125; 可以看到，与 Java 中的懒汉式版本是基本一样的，线程安全是使用 GCD 里的 dispatch_once (保证在多个线程同时调用的时候，dispatch_once 只会执行一次) 来保证的。 JavaScript 中的单例模拟传统面向对象语言实现的单例var Singleton = function(name) &#123; this.name = name; this.instance = null;&#125;Singleton.prototype.getName = function() &#123; return this.name;&#125;Singleton.getInstance = function(name) &#123; if(!this.instance) &#123; this.instance = new Singleton(name); &#125; return this.instance;&#125; 全局变量全局变量不是单例模式，但是一个全局变量确实是独一无二的。 然而全局变量存在很多问题，它很容易造成命名空间污染。我们有必要尽量的减少全局变量的使用，即使需要，也要把它的污染将至最低。 使用命名空间var MyApp = &#123; event: &#123;&#125;, dom: &#123; style: &#123;&#125; &#125;,&#125; 适当的使用命名空间，并不会杜绝全局变量，但可以减少全局变量的数量。 使用闭包封装私有变量将变量封装在闭包的内部，只暴露一些接口与外界通讯。 var user = (function()&#123; var _name = 'xiaoming'; var _age = 26; return &#123; getUserName: function() &#123; return _name; &#125;, getUserAge: function() &#123; return _age; &#125; &#125;&#125;)() 实际情况中的单例举个栗子，我们在写弹窗的时候，一般都要写一个遮罩层，很明显我们可以把这个遮罩层设计成在页面里是唯一的。我们可以设计成这个样子： var createMask = (function() &#123; var mask; return function() &#123; if(!mask) &#123; mask = document.createElement('div'); mask.style.display = 'none'; document.body.appendChild(mask); &#125; return mask; &#125;&#125;)() 但是上面代码还是有一些问题的，很明显它是违背了单一职责原则的，创建对象和管理单例的逻辑都放在 createMask 对象内部了。下面我们优化一下： var getSingleton = function(fn) &#123; var result; return function() &#123; return result || (result = fn.apply(this, arguments)); &#125;&#125;var createMask = function()&#123; var mask = document.createElement('div'); mask.style.display = 'none'; document.body.appendChild(mask); return mask;&#125;var createSingleMask = getSingleton(createMask); 这样看起来还不错，getSingleton 方法还可以用来通用的创建其它单例哟~~ 小结单例模式看起来非常简单，但是用起来的时候还是有很多要注意的地方。因为 JavaScript 与传统面向对象语言之间的差异性，还会有其它更适合在方法在 JavaScript 中创建单例。 参考设计模式 之 Singleton(Java实现)Java 单例真的写对了么?JS 单例模式","categories":[{"name":"前端","slug":"front-end","permalink":"https://haohaio.github.io/categories/front-end/"}],"tags":[{"name":"DesignPatterns","slug":"DesignPatterns","permalink":"https://haohaio.github.io/tags/DesignPatterns/"}]},{"title":"Java内存模型简介","slug":"java-memory-model","date":"2019-06-24T07:36:52.000Z","updated":"2020-04-09T07:21:45.770Z","comments":true,"path":"back-end/java-memory-model.html","link":"","permalink":"https://haohaio.github.io/back-end/java-memory-model.html","excerpt":"","text":"简介 可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。 Java 线程之间的通信由 Java 内存模型（本文简称为 JMM）控制，JMM 决定一个线程对共享变量的写入何时对另一个线程可见。从抽象的角度来看，JMM 定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以读 / 写共享变量的副本。本地内存是 JMM 的一个抽象概念，并不真实存在。它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。 Java 内存模型的抽象示意图如下： 从上图来看，线程 A 与线程 B 之间如要通信的话，必须要经历下面 2 个步骤： 线程 A 把本地内存 A 中更新过的共享变量刷新到主内存中去。 然后，线程 B 到主内存中去读取线程 A 之前已更新过的共享变量。 从整体来看，这两个步骤实质上是线程 A 在向线程 B 发送消息，而且这个通信过程必须要经过主内存。JMM 通过控制主内存与每个线程的本地内存之间的交互，来为 java 程序员提供内存可见性保证。 重排序在执行程序时为了提高性能，编译器和处理器常常会对指令做重排序。但是这也会带来一些线程安全问题。 在进行重排序后，处理器对内存的读/写操作的执行顺序，不一定与内存实际发生的读/写操作顺序一致。例如： 初始状态：a = b = 0Processor A: Processor B:a = 1; // A1 b = 2; // B1x = b; // A2 y = a; // B2处理器允许执行后得到结果：x = y = 0 具体原因如下图所示： 由于写缓冲区仅对自己的处理器可见，它会导致处理器执行内存操作的顺序可能会与内存实际的操作执行顺序不一致。由于现代的处理器都会使用写缓冲区，因此现代的处理器都会允许对读/写操作重排序。 如上所示，当多个线程同时访问一个数据的时候，可能本地内存的修改没有及时刷新到主内存，所以就会发生线程安全问题。 happens-before从 JDK5 开始，java 使用新的 JSR -133 内存模型。JSR-133 提出了 happens-before 的概念，通过这个概念来阐述操作之间的内存可见性。如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须存在 happens-before 关系。与程序员密切相关的 happens-before 规则如下： 程序顺序规则：一个线程中的每个操作，happens- before 于该线程中的任意后续操作。 监视器锁规则：对一个监视器锁的解锁，happens- before 于随后对这个监视器锁的加锁。 volatile 变量规则：对一个 volatile 域的写，happens- before 于任意后续对这个 volatile 域的读。 传递性：如果 A happens- before B，且 B happens- before C，那么 A happens- before C。 基于 volatile 变量规则，可以在 Java 中可以使用 volatile 关键字来修饰多线程间共享变量，使该变量在多线程之间可见。 参考深入理解 Java 内存模型（一）——基础","categories":[{"name":"后端","slug":"back-end","permalink":"https://haohaio.github.io/categories/back-end/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://haohaio.github.io/tags/Java/"}]},{"title":"Flutter 布局组件简介","slug":"flutter-layout-widgets","date":"2019-05-28T02:43:11.000Z","updated":"2020-04-09T07:21:45.890Z","comments":true,"path":"front-end/flutter-layout-widgets.html","link":"","permalink":"https://haohaio.github.io/front-end/flutter-layout-widgets.html","excerpt":"","text":"Flutter 是使用 Layout Widgets 来进行布局的，今天我们就来了解一下相关的布局组件。 Single-child layout widgetsContainer A convenience widget that combines common painting, positioning, and sizing widgets. 属性 key：container 唯一标识符，用于查找更新。 alignment：控制 child 的对齐方式，如果 container 或者 container 父节点尺寸大于 child 的尺寸，这个属性设置会起作用，有很多种对齐方式。 padding：内边距。 color：用来设置 container 背景色。 decoration：绘制在child后面的装饰，设置了decoration的话，就不能设置color属性，否则会报错，此时应该在 decoration 中进行颜色的设置。 foregroundDecoration：绘制在child前面的装饰。 width：container 的宽度，设置为 double.infinity 可以强制在宽度上撑满。不设置，则根据 child 和父节点两者一起布局。 height：container 的高度，设置为 double.infinity 可以强制在高度上撑满。 constraints：添加到 child 上额外的约束条件。 margin：外边距。 transform：设置 container 的变换矩阵，类型为 Matrix4。 child：container 中的内容 widget。 我们可以用 Container 来设置间隔、背景、边框、圆角、对齐等。 Padding A widget that insets its child by the given padding. 我们可以用 Padding 来设置间隔。（Container 中 的 margin 以及 padding 属性都是利用 Padding 控件去实现的。） Align属性 key alignment：对齐方式 widthFactor：child 的宽度倍数 heightFactor：child 的高度倍数 child A widget that aligns its child within itself and optionally sizes itself based on the child’s size. 我们可以用 Align 来设置对齐。若不设 widthFactor 和 heightFactor, Align 会尽量的扩展自己的尺寸。 Center A widget that centers its child within itself. Center 继承自 Align，只不过是将 alignment 设置为 Alignment.center，其他属性例如 widthFactor、heightFactor，布局行为，都与 Align 完全一样。 FittedBox Scales and positions its child within itself according to fit. 我们可以用FittedBox来处理缩放。FittedBox 如果外部有约束的话，按照外部约束调整自身尺寸。如果没有外部约束条件，则跟 child 尺寸一致，指定的缩放以及位置属性将不起作用。 AspectRatio A widget that attempts to size the child to a specific aspect ratio. AspectRatio 的作用是调整 child 到设置的宽高比。AspectRatio首先会在布局限制条件允许的范围内尽可能的扩展，widget的高度是由宽度和比率决定的，类似于BoxFit中的contain，按照固定比率去尽量占满区域。如果在满足所有限制条件过后无法找到一个可行的尺寸，AspectRatio最终将会去优先适应布局限制条件，而忽略所设置的比率。 ConstrainedBox A widget that imposes additional constraints on its child. ConstrainedBox 的 作用就是给 child 添加约束（constraints）。 Baseline A widget that positions its child according to the child’s baseline. 我们可以用 Baseline 来处理字符对齐。 FractionallySizedBox A widget that sizes its child to a fraction of the total available space. For more details about the layout algorithm, see RenderFractionallySizedOverflowBox. child 可以通过 FractionallySizedBox 在其可用区域里取百分比尺寸。 IntrinsicHeight A widget that sizes its child to the child’s intrinsic height. IntrinsicHeight 的作用是调整 child 到固定的高度。 IntrinsicWidth A widget that sizes its child to the child’s intrinsic width. IntrinsicWidth 的作用是调整 child 到固定的宽度。 LimitedBox A box that limits its size only when it’s unconstrained. LimitedBox 的作用是对 child 的最大宽高进行限制。 Offstage A widget that lays the child out as if it was in the tree, but without painting anything, without making the child available for hit testing, and without taking any room in the parent. Offstage 的作用是通过一个参数，来控制 child 是否显示。 OverflowBox A widget that imposes different constraints on its child than it gets from its parent, possibly allowing the child to overflow the parent. OverflowBox 的作用是允许 child 超出 parent 的范围显示。 SizedBox A box with a specified size. SizedBox 的作用就是设置具体的宽高。 SizedOverflowBox A widget that is a specific size but passes its original constraints through to its child, which will probably overflow. SizedOverflowBox 是 SizedBox 与 OverflowBox 的结合体。 Transform A widget that applies a transformation before painting its child. Transform 就是对 child 做矩阵变换的，即平移、旋转、缩放等操作。 CustomSingleChildLayout A widget that defers the layout of its single child to a delegate. CustomSingleChildLayout提供了一个控制child布局的delegate，我们可以通过这个控件去封装一些基础的控件（尺寸），供他人使用。 Multi-child layout widgetsRow &amp; Column A widget that displays its children in a horizontal array. 类似于 CSS3 中的 Flex 布局。可结合 Expanded 使用，设置 children 中各 widget 的 flex 值。 Stack A widget that positions its children relative to the edges of its box. 我们可以用 Stack 来做需要叠加显示的布局。 IndexedStack A Stack that shows a single child from a list of children. IndexedStack 继承自 Stack，它的作用是显示第 index 个 child，其他 child 都是不可见的。所以 IndexedStack 的尺寸永远是跟最大的子节点尺寸一致。 GridView A scrollable, 2D array of widgets. GridView 就是一个滚动的多列列表。 Flow A widget that implements the flow layout algorithm. Flow 可以用来在定制化流式布局，但是写起来比较复杂，但胜在灵活性以及其高效。 Table A widget that uses the table layout algorithm for its children. Table 可以用来做表格展示。 Wrap A widget that displays its children in multiple horizontal or vertical runs. Wrap 可以用来处理自动换行的布局。Flow 可以很轻易的实现 Wrap 的效果，从效率上讲，Flow 肯定会比 Wrap 高，但是 Wrap 使用起来会方便一些。 ListBody A widget that arranges its children sequentially along a given axis. ListBody 的作用是按给定的轴方向，按照顺序排列子节点。不常直接使用，一般都会配合 ListView 或者 Column 等控件使用 CustomMultiChildLayout A widget that uses a delegate to size and position multiple children. CustomMultiChildLayout 的作用是通过 delegate 实现 多节点的自定义布局（尺寸、位置）。 LayoutBuilder Builds a widget tree that can depend on the parent widget’s size. ListView A scrollable, linear list of widgets. ListView 可以用来做列表展示。 Expanded A widget that expands a child of a Row, Column, or Flex. 配合 Row &amp; Column 使用，设置 child 的 flex 值。","categories":[{"name":"前端","slug":"front-end","permalink":"https://haohaio.github.io/categories/front-end/"}],"tags":[{"name":"Flutter","slug":"Flutter","permalink":"https://haohaio.github.io/tags/Flutter/"}]},{"title":"Flutter 入门","slug":"flutter-quick-start","date":"2019-04-03T01:28:47.000Z","updated":"2020-04-09T07:21:45.769Z","comments":true,"path":"front-end/flutter-quick-start.html","link":"","permalink":"https://haohaio.github.io/front-end/flutter-quick-start.html","excerpt":"","text":"简介Flutter allows you to build beautiful native apps on iOS and Android from a single codebase. Flutter 是 Google 推出并开源的移动应用开发框架，采用 Dart 语言进行开发，使用自绘引擎渲染视图，主打跨平台、高保真、高性能。 开发环境安装 Flutter 使用镜像 # Flutter官方为中国开发者搭建的临时镜像export PUB_HOSTED_URL=https://pub.flutter-io.cnexport FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn 以 Mac 环境为例进行安装，其它环境请看 Windows、Linux 下载 SDK，然后解压到相应目录中，并添加 flutter 相关工具到 path 中： # 将 SDK 解压到了 ~/Flutter/sdk/ 目录下$ export PATH=~/Flutter/sdk/flutter/bin:$PATH 运行 flutter doctor # 通过 flutter 提供的命令检查当前环境并在终端窗口中显示报告$ flutter doctor 根据提示直接复制命令继续执行即可 安装 Xcode 和 Android StudioXcode 和 Android Studio 是进行原生开发的 IDE，安装后也会便于进行 Flutter 开发。具体安装自行了解一下，可看 参考链接 IDE Visual Studio Code (VS Code)安装 Flutter 插件即可 Android Studio安装 Flutter 和 Dart 插件即可 工程新建项目（VS Code） 打开命令面板（Command + shift + P），输入 “flutter”, 然后选择 “Flutter: New Project” action 输入 Project 名称 (如myapp), 然后按回车键确认 指定放置项目的位置，然后按蓝色的确定按钮 等待项目创建继续，并显示main.dart文件 运行项目（VS Code） 在 VS Code 的右下角选择目标设备 按 F5 键进行调试 打包Android 创建 keystore (若已有keystore，跳至下一步) # 通过 Java JDK 的 keytool 在根目录下创建一个 key.jks 文件$ keytool -genkey -v -keystore ~/key.jks -keyalg RSA -keysize 2048 -validity 10000 -alias key 引用keystore 创建一个名为 &lt;app dir&gt;/android/key.properties 的文件，其中包含对密钥库的引用： storePassword=&lt;password from previous step&gt;keyPassword=&lt;password from previous step&gt;keyAlias=keystoreFile=&lt;location of the key store file, e.g. /Users/&lt;user name&gt;/key.jks&gt; 在 gradle 中配置签名 替换: android &#123; 为： def keystorePropertiesFile = rootProject.file(\"key.properties\")def keystoreProperties = new Properties()keystoreProperties.load(new FileInputStream(keystorePropertiesFile))android &#123; 替换: buildTypes &#123; release &#123; // TODO: Add your own signing config for the release build. // Signing with the debug keys for now, so `flutter run --release` works. signingConfig signingConfigs.debug &#125;&#125; 为： signingConfigs &#123; release &#123; keyAlias keystoreProperties['keyAlias'] keyPassword keystoreProperties['keyPassword'] storeFile file(keystoreProperties['storeFile']) storePassword keystoreProperties['storePassword'] &#125;&#125;buildTypes &#123; release &#123; signingConfig signingConfigs.release &#125;&#125; 执行命令打包 # 在 &lt;app dir&gt; 下执行命令（非 android/ 目录下）$ flutter build apk (flutter build 默认会包含 --release选项) 打包好的APK位于 &lt;app dir&gt;/build/app/outputs/apk/ iOS和正常的iOS项目一样打包，具体可查看 详细介绍 热补丁目前 Flutter 是默认不支持热补丁的，暂时也未发现靠谱的热补丁方法。 架构DartDart 是由 Google 开发并开源的应用编程语言。我们需要用其进行 Flutter 开发。 简单介绍一些语法： 变量声明 var t;t=\"hi world\";t=1000; // errordynamic t;Object x;t = \"hi world\";x = 'Hello Object';t = 1000; // okx = 1000; // ok// dynamic 声明的对象编译器会提供所有可能的组合, 而 Object 声明的对象只能使用 Object 的属性与方法dynamic a;Object b;main() &#123; a = \"\"; b = \"\"; printLengths();&#125;printLengths() &#123; print(a.length); // ok print(b.length); // error: The getter 'length' is not defined for the class 'Object'&#125; 异步处理 Future.delayed(new Duration(seconds: 2),()&#123; //return \"hello world!\"; throw AssertionError(\"Error\");&#125;).then((data)&#123; //执行成功会走到这里 print(data);&#125;).catchError((e)&#123; //执行失败会走到这里 print(e);&#125;).whenComplete(()&#123; //无论成功或失败都会走到这里&#125;);// 多个异步任务Future.wait([ // 2秒后返回结果 Future.delayed(new Duration(seconds: 2), () &#123; return \"hello\"; &#125;), // 4秒后返回结果 Future.delayed(new Duration(seconds: 4), () &#123; return \" world\"; &#125;)]).then((results)&#123; print(results[0]+results[1]);&#125;).catchError((e)&#123; print(e);&#125;);// 使用 Future 消除 callback helllogin(\"alice\",\"******\").then((id)&#123; return getUserInfo(id);&#125;).then((userInfo)&#123; return saveUserInfo(userInfo);&#125;).then((e)&#123; // 执行接下来的操作&#125;).catchError((e)&#123; // 错误处理 print(e);&#125;); 布局Flutter 有一套自己的布局机制。其核心就是 Widget。在Flutter中，几乎所有的对象都是一个 Widget。 简单介绍一下： new Text('Hello World', style: new TextStyle(fontSize: 32.0));new Icon(Icons.star, color: Colors.red[500]);new Center( child: new Text('Hello World', style: new TextStyle(fontSize: 32.0)); Widget与原生开发中“控件”不同的是，Flutter 中的 Widget 的概念更广泛，它不仅可以表示UI元素，也可以表示一些功能性的组件如：用于手势检测的 GestureDetector Widget、用于应用主题数据传递的 Theme 等等。 其实在 Flutter 中，Widget 的功能是“描述一个UI元素的配置数据”，Flutter 中真正代表屏幕上显示元素的类是 Element，也就是说 Widget 只是描述 Element 的一个配置。不过，由于 Element 是通过 Widget 生成，所以它们之间有对应关系，所以在大多数场景，我们可以宽泛地认为 Widget 树就是指UI控件树或UI渲染树。 @immutable// DiagnosticableTree 即“诊断树”，主要作用是提供调试信息。abstract class Widget extends DiagnosticableTree &#123; const Widget(&#123; this.key &#125;); // key属性类似于 React/Vue 中的 key，主要的作用是决定是否在下一次 build 时复用旧的widget，决定的条件在 canUpdate()方法中。 final Key key; @protected // 由 Flutter Framework 隐式调用，来生成对应的 Element 对象，构建 UI 树。 Element createElement(); @override String toStringShort() &#123; return key == null ? '$runtimeType' : '$runtimeType-$key'; &#125; @override void debugFillProperties(DiagnosticPropertiesBuilder properties) &#123; super.debugFillProperties(properties); properties.defaultDiagnosticsTreeStyle = DiagnosticsTreeStyle.dense; &#125; // 判断是否用新的 Widget 对象去更新旧UI树上所对应的 Element 对象的配置。 static bool canUpdate(Widget oldWidget, Widget newWidget) &#123; return oldWidget.runtimeType == newWidget.runtimeType &amp;&amp; oldWidget.key == newWidget.key; &#125;&#125; 在Flutter开发中，我们一般都不用直接继承 Widget 类来实现 Widget，相反，我们通常会通过继承 StatelessWidget 和 StatefulWidget 来间接继承 Widget类来实现，而 StatelessWidget 和 StatefulWidget 都是直接继承自 Widget 类。 资源Flutter 官网Flutter 中文网Awesome FlutterFlutter 掘金社区 小结 技术类型 UI渲染方式 性能 开发效率 动态化 框架代表 H5 + 原生 WebView渲染 一般 高 支持 Cordova、Ionic JavaScript + 原生渲染 原生控件渲染 好 高 支持 RN、Weex 自绘UI + 原生渲染 调用系统API渲染 好 Flutter高，QT低 默认不支持 QT、Flutter","categories":[{"name":"前端","slug":"front-end","permalink":"https://haohaio.github.io/categories/front-end/"}],"tags":[{"name":"Flutter","slug":"Flutter","permalink":"https://haohaio.github.io/tags/Flutter/"}]},{"title":"使用 Hexo 搭建属于你自己的博客","slug":"hexo-blog","date":"2019-03-08T01:40:16.000Z","updated":"2020-04-09T07:21:45.890Z","comments":true,"path":"others/hexo-blog.html","link":"","permalink":"https://haohaio.github.io/others/hexo-blog.html","excerpt":"","text":"为什么要搭建个人博客博客，我个人觉得更多是写给自己看的，主要是把自己学到的东西给记录下来，进行总结，从而让自己有一定的提升。其次也能将自己学来的知识与他人进行分享，帮助他人解决问题，在分享的过程中他人和自己都能获得一定的提升。 至于为什么要个人建站，是因为本人是做 Web 开发的，所以想要定制一个自己喜欢的个人博客（其实就是从网上众多的主题中挑选一个自己顺眼的，自己再小小修改一下），想怎么来就怎么来~~ 今天就来介绍一下如何使用 Hexo 来搭建自己的个人博客。 HexoHexo 是一个基于 Node.js, 支持 Markdown 的快速、简洁且高效的博客框架。 安装 Hexo需先安装 Node.js 和 Git npm install -g hexo-cli 创建博客执行命令 # 生成博客目录并安装依赖$ hexo init blog &amp;&amp; cd blog &amp;&amp; npm install 生成的主要文件目录如下： ├── /scaffolds/ # 模版文件夹：新建文章时的模板├── /sources/ # 资源文件夹│ ├── /_posts/ # 文章文件夹├── /themes/ # 主题文件夹：Hexo 根据主题来生成静态页面├── _config.yml # 网站配置信息├── package.json # 应用程序信息 建议将自己的博客用 Git 管理起来哦~~ 启动服务执行命令 # 会在本地启动一个 http server，用来访问我们的个人博客$ hexo server (hexo s) 启动服务后即可在 本地 访问自己刚刚搭建的博客。 写作执行命令 # hexo new [layout] &lt;title&gt; 创建一篇新文章，layout 默认为 post（scaffolds/post）$ hexo n 我的第一篇博客 推荐一份 Markdown 语法指南 部署我们可以将我们的个人博客部署在服务器上，并代理到我们自己的域名，但这些都是需要 ￥￥ 的。所以推荐一些免费的服务来用来部署我们的博客，比如 GitHub、Coding 和 码云 等，这些平台提供了免费的 Pages 服务，可以用来部署我们的博客。下面以 Github Pages 为例，讲一下如何进行部署，其它平台的操作也是大同小异。 GitHub Pages GitHub 提供了 GitHub Pages 的服务，免费提供 username.github.io 的域名，来让我们部署一个静态网页。 首先我们要创建一个 GitHub 帐号，用户名一定要想好了再创建，因为用户名会关系到我们个人博客的域名哦~~ 然后创建一个名称为 username.github.io 的项目，然后点击项目的配置，就会发现，我们的Pages服务已经OK了,如下图所示 接下来只需要部署我们的代码就可以了 配置 _config.yml deploy:- type: git repo: https://github.com/haohaio/haohaio.github.io.git branch: master 执行命令 # 安装依赖以通过 Git 进行部署，然后生成静态文件进行部署$ npm install hexo-deployer-git --save &amp;&amp; hexo g &amp;&amp; hexo d 最好配置一下 GitHub 的 SSH key，将 repo 改成 SSH 类型的，这样部署的时候就不需要输入用户名和密码啦~~ 然后访问一下 username.github.io 就能看到自己搭建的博客啦~~ 主题但现在我们搭建的博客看上去还不是那么的好看，功能也很少，我们可以通过更换主题来改变一下我们博客的面貌。Hexo 提供了一份主题列表, 或者可以去 GitHub 上搜索 hexo theme 来选择一个喜欢的主题进行更换。 那我们就以 GitHub 上 Star 最多的 hexo-theme-next 为例来更换我们的主题。 执行命令 # 创建主题文件夹$ mkdir themes/next# 获取主题资源文件$ git clone https://github.com/iissnan/hexo-theme-next themes/next 配置 _config.yml theme: next 执行命令 # 重新部署$ hexo g &amp;&amp; hexo d 刷新页面后就可以看到我们已经成功的更换主题了，具体还可以根据 详细介绍 来让我们的博客更加美观、强大。 结语坚持！坚持！坚持！一定要把写博客的习惯坚持下去~~","categories":[{"name":"其它","slug":"others","permalink":"https://haohaio.github.io/categories/others/"}],"tags":[{"name":"Hexo","slug":"hexo","permalink":"https://haohaio.github.io/tags/hexo/"}]},{"title":"Spring Boot 日志配置","slug":"spring-boot-logging","date":"2019-01-25T03:02:39.000Z","updated":"2020-04-09T07:21:57.106Z","comments":true,"path":"back-end/spring-boot-logging.html","link":"","permalink":"https://haohaio.github.io/back-end/spring-boot-logging.html","excerpt":"","text":"Spring Boot 给我们集成了默认的日志系统，但有时我们需要自定义一些配置，今天我们就来了解一下如何进行自定义配置。 Spring Boot 默认采用了 slf4j+logback 的组合形式。 通过 application.properties 修改默认配置我们可以在 application.properties 文件中设置来修改日志默认配置： # 日志级别分为 TRACR &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR 五个级别，优先级由低到高# 修改日志的 root 级别（默认日志级别）logging.level.root=debug# 调整指定包的日志级别logging.level.com.haohaio=trace# 当 logging.file 和 logging.path 同时设置时，logging.path 不生效# 输入到当前项目根路径下的 spring-boot.log 文件中logging.file=spring-boot.log# 输入到当前项目根路径下的 logs 文件夹下的 spring-boot.log 文件中logging.file=logs/spring-boot.log# 输入到当前项目根路径下的 logs 文件夹里 spring.log 文件中logging.path=logs# 修改控制台日志格式logging.pattern.console=%d&#123;yyyy-MM-dd&#125; === [%thread] === %-5level === %logger&#123;50&#125; === %msg%n# 修改输入到日志文件中日志格式logging.pattern.file=%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; &gt;&gt;&gt; [%thread] &gt;&gt;&gt; %-5level &gt;&gt;&gt; %logger&#123;50&#125; &gt;&gt;&gt; %msg%n 日志输出格式说明： %d 表示输出时间，%thread 表示输出当前线程名，%-5level 表示输出日志级别，左对齐5个字符宽度，%logger{50} 表示输出全类名最长50个字符，超过按照句点分割，%msg 表示日志信息，%n 表示换行符 自定义配置我们可以 resources 目录下创建对应日志框架的自定义配置文件，来进行自定义配置。 日志系统 自定义日志配置文件名 Logback logback-spring.xml, logback-spring.groovy, logback.xml, or logback.groovy Log4j2 log4j2-spring.xml or log4j2.xml JDK (Java Util Logging) logging.properties 自定义 Logback 日志配置接下来我们可以对默认的 Logback 进行自定义配置 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!-- scan：当此属性设置为 true 时，配置文件如果发生改变，将会被重新加载，默认值为true。 scanPeriod：设置监测配置文件是否有修改的时间间隔，如果没有给出时间单位，默认单位是毫秒。当 scan 为 true 时，此属性生效。默认的时间间隔为 1 分钟。 debug：当此属性设置为 true 时，将打印出 logback 内部日志信息，实时查看 logback 运行状态。默认值为 false。--&gt;&lt;configuration scan=\"false\" scanPeriod=\"60 seconds\" debug=\"false\"&gt; &lt;!-- 定义日志的根目录 --&gt; &lt;property name=\"LOG_HOME\" value=\"logs\" /&gt; &lt;!-- 定义日志文件名称 --&gt; &lt;property name=\"appName\" value=\"spring-boot\"&gt;&lt;/property&gt; &lt;!-- ch.qos.logback.core.ConsoleAppender 表示控制台输出 --&gt; &lt;appender name=\"stdout\" class=\"ch.qos.logback.core.ConsoleAppender\"&gt; &lt;layout class=\"ch.qos.logback.classic.PatternLayout\"&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; &gt;&gt;&gt; [%thread] &gt;&gt;&gt; %-5level &gt;&gt;&gt; %logger&#123;50&#125; &gt;&gt;&gt; %msg%n&lt;/pattern&gt; &lt;/layout&gt; &lt;/appender&gt; &lt;!-- 滚动记录文件，先将日志记录到指定文件，当符合某个条件时，将日志记录到其他文件 --&gt; &lt;appender name=\"appLogAppender\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\"&gt; &lt;!-- 指定日志文件的名称 --&gt; &lt;file&gt;$&#123;LOG_HOME&#125;/$&#123;appName&#125;.log&lt;/file&gt; &lt;!-- TimeBasedRollingPolicy：最常用的滚动策略，它根据时间来制定滚动策略。--&gt; &lt;rollingPolicy class=\"ch.qos.logback.core.rolling.TimeBasedRollingPolicy\"&gt; &lt;!-- 滚动时产生的文件的存放位置及文件名称 %d&#123;yyyy-MM-dd&#125;：按天进行日志滚动, %i：当文件大小超过 maxFileSize 时，按照 i 进行文件滚动 --&gt; &lt;fileNamePattern&gt;$&#123;LOG_HOME&#125;/$&#123;appName&#125;-%d&#123;yyyy-MM-dd&#125;-%i.log&lt;/fileNamePattern&gt; &lt;maxFileSize&gt;10MB&lt;/maxFileSize&gt; &lt;!-- 只保存最近 30 天的文件 --&gt; &lt;MaxHistory&gt;30&lt;/MaxHistory&gt; &lt;totalSizeCap&gt;1GB&lt;/totalSizeCap&gt; &lt;/rollingPolicy&gt; &lt;!-- 日志输出格式 --&gt; &lt;layout class=\"ch.qos.logback.classic.PatternLayout\"&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [ %thread ] - [ %-5level ] [ %logger&#123;50&#125; : %line ] - %msg%n&lt;/pattern&gt; &lt;/layout&gt; &lt;/appender&gt; &lt;!-- logger 主要用于存放日志对象，也可以定义日志类型、级别，name：表示匹配的 logger 类型前缀，也就是包的前半部分，additivity：false：表示rootLogger 的 appender-ref 无效，true：表示当前 logger 的 appender-ref 和 rootLogger 的 appender-ref 都有效 --&gt; &lt;logger name=\"com.haohaio\" level=\"trace\" /&gt; &lt;logger name=\"org.springframework\" level=\"debug\" additivity=\"false\"&gt;&lt;/logger&gt; &lt;!-- root 与 logger 是父子关系，没有特别定义则默认为 root。--&gt; &lt;root level=\"info\"&gt; &lt;appender-ref ref=\"stdout\" /&gt; &lt;appender-ref ref=\"appLogAppender\" /&gt; &lt;/root&gt;&lt;/configuration&gt; 使用 Profile 特殊配置我们还可以使用 Profile 特殊配置，根据不同的环境来使用不同的配置。但我们首先需要将自定义日志配置文件名 logback.xml 改为 logback-spring.xml。比如： &lt;springProfile name=\"dev\"&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; === [%thread] === %-5level === %logger&#123;50&#125; === %msg%n&lt;/pattern&gt;&lt;/springProfile&gt;&lt;springProfile name=\"prod\"&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; &gt;&gt;&gt; [%thread] &gt;&gt;&gt; %-5level &gt;&gt;&gt; %logger&#123;50&#125; &gt;&gt;&gt; %msg%n&lt;/pattern&gt;&lt;/springProfile&gt; 切换日志框架我们可以在项目的 pom.xml 文件里切换日志框架。比如切换为 log4j2 日志框架： &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;!-- 先排除 spring-boot-starter-logging --&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;!-- 再使用 log4j2 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-log4j2&lt;/artifactId&gt;&lt;/dependency&gt; 切换完成后我们还可以使用 log4j2 对应的 log4j2.xml 和 log4j2-spring.xml 来进行自定义配置。 文档Spring Boot Logging","categories":[{"name":"后端","slug":"back-end","permalink":"https://haohaio.github.io/categories/back-end/"}],"tags":[{"name":"Spring","slug":"spring","permalink":"https://haohaio.github.io/tags/spring/"}]},{"title":"Canvas学习笔记七：动画","slug":"canvas-animation","date":"2019-01-14T03:07:15.000Z","updated":"2020-04-09T07:21:56.816Z","comments":true,"path":"front-end/canvas-animation.html","link":"","permalink":"https://haohaio.github.io/front-end/canvas-animation.html","excerpt":"","text":"使用 requestAnimationFrame() 方法让做动画 不要用 setInterval() 或 setTimeout() 来做动画setInterval() 与 setTimeout() 并不能提供和制作动画所需的精准计时机制。它们只是让应用程序能在某个大致时间点上运行代码的通用方法而已。 不应主动命令浏览器何时去绘制下一帧动画，这应有浏览器通知你在调用 setInterval() 与 setTimeout() 时，开发者会主动告知浏览器绘制下一帧动画的时间。然而，调用者并不知道绘制下一帧动画的最佳时机，浏览器肯定比开发者更了解这个时机。所以应该让浏览器在它觉得可以绘制下一帧动画时通知我们。 function animate(time) &#123; // Update and draw animation objects requsetAnimationFrame(animate); // sustain the animation&#125;requestAnimationFrame(animate); // start the animation requestAnimationFrame() 不需要调用者指定帧速率，浏览器会自行决定最佳的帧速率 我们还可以调用 cancelRequestAnimationFrame(long handle) 方法来将原来 requestAnimationFrame() 方法所注册的函数回调给取消执行。requestAnimationFrame() 方法会返回一个 long 型的对象，用作标识回调函数的句柄 (handle)，可传入 cancelRequestAnimationFrame() 方法来取消回调函数的执行。 但是 requestAnimationFrame() 的兼容性并不是很好，只兼容到了 IE10 以及以后的版本。我们可以定义一个 “Polyill式方法” 来向下兼容，具体代码如下： window.requestNextAnimationFrame = (function() &#123; var originalWebkitRequestAnimationFrame = undefined, wrapper = undefined, callback = undefined, geckoVersion = 0, userAgent = navigator.userAgent, index = 0, self = this; // Workaround for Chrome 10 bug where Chrome // does not pass the time to the animation function if (window.webkitRequestAnimationFrame) &#123; // Define the wrapper wrapper = function(time) &#123; if (time === undefined) &#123; time = +new Date(); &#125; self.callback(time); &#125;; // Make the switch originalWebkitRequestAnimationFrame = window.webkitRequestAnimationFrame; window.webkitRequestAnimationFrame = function(callback, element) &#123; self.callback = callback; // Browser calls the wrapper and wrapper calls the callback originalWebkitRequestAnimationFrame(wrapper, element); &#125; &#125; // Workaround for Gecko 2.0, which has a bug in // mozRequestAnimationFrame() that restricts animations // to 30-40 fps. if (window.mozRequestAnimationFrame) &#123; // Check the Gecko version. Gecko is used by browsers // other than Firefox. Gecko 2.0 corresponds to // Firefox 4.0. index = userAgent.indexOf('rv:'); if (userAgent.indexOf('Gecko') != -1) &#123; geckoVersion = userAgent.substr(index + 3, 3); if (geckoVersion === '2.0') &#123; // Forces the return statement to fall through // to the setTimeout() function. window.mozRequestAnimationFrame = undefined; &#125; &#125; &#125; return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(callback, element) &#123; var start, finish; window.setTimeout(function() &#123; start = +new Date(); callback(start); finish = +new Date(); self.timeout = 1000 / 60 - (finish - start); &#125;, self.timeout); &#125;; &#125;)();","categories":[{"name":"前端","slug":"front-end","permalink":"https://haohaio.github.io/categories/front-end/"}],"tags":[{"name":"CSS","slug":"css","permalink":"https://haohaio.github.io/tags/css/"}]},{"title":"[JavaScript LeetCode]35. 搜索插入位置","slug":"leetcode-search-insert-position","date":"2019-01-11T01:59:35.000Z","updated":"2020-04-21T14:22:59.247Z","comments":true,"path":"data-structure/leetcode-search-insert-position.html","link":"","permalink":"https://haohaio.github.io/data-structure/leetcode-search-insert-position.html","excerpt":"","text":"原题链接 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。 你可以假设数组中无重复元素。 示例: 输入: [1,3,5,6], 5输出: 2输入: [1,3,5,6], 2输出: 1输入: [1,3,5,6], 7输出: 4输入: [1,3,5,6], 0输出: 0 解法一直接遍历一遍，若目标值小于等于当前下标值，当前下标就是我们需要的值。可以先与首尾元素进行比较，顺便处理目标值比数组所有元素都大的情况。 var searchInsert = function (nums, target) &#123; if (target &lt; nums[0]) return 0; let len = nums.length; if (target &gt; nums[len - 1]) return len; for (let i = 0; i &lt; len; i++) &#123; if (target &lt;= nums[i]) return i; &#125;&#125;; 解法二根据题意，我们需要查找有序数组里的元素，那就可以使用二分查找法来解决问题。 var searchInsert = function (nums, target) &#123; let left = 0; let right = nums.length - 1; while (left &lt;= right) &#123; let mid = Math.round((left + right) / 2); if (nums[mid] === target) &#123; return mid; &#125; else if (target &lt; nums[mid]) &#123; right = mid - 1; &#125; else &#123; left = mid + 1; &#125; &#125; return left;&#125;;","categories":[{"name":"数据结构","slug":"data-structure","permalink":"https://haohaio.github.io/categories/data-structure/"}],"tags":[{"name":"LeetCode","slug":"leetcode","permalink":"https://haohaio.github.io/tags/leetcode/"}]},{"title":"[JavaScript LeetCode]28. 实现 strStr()","slug":"leetcode-implement-indexof-func","date":"2019-01-10T08:42:39.000Z","updated":"2020-04-21T09:22:51.884Z","comments":true,"path":"data-structure/leetcode-implement-strstr.html","link":"","permalink":"https://haohaio.github.io/data-structure/leetcode-implement-strstr.html","excerpt":"","text":"原题链接 实现 strStr() 函数。 给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从 0 开始)。如果不存在，则返回 -1。 示例: 输入: haystack = &quot;hello&quot;, needle = &quot;ll&quot;输出: 2输入: haystack = &quot;aaaaa&quot;, needle = &quot;bba&quot;输出: -1 说明: 当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。 对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与 C 语言的 strstr() 以及 Java 的 indexOf() 定义相符。 解法一根据题意，要实现的 strStr() 和 JavaScript 中的 indexOf() 是一样的，所以，现成的轮子可以直接拿来使用。 var strStr = function (haystack, needle) &#123; return haystack.indexOf(needle);&#125;; 解法二遍历即可。 var strStr = function (haystack, needle) &#123; let len1 = haystack.length; let len2 = needle.length; if (len1 &lt; len2) return -1; for (let i = 0; ; i++) &#123; if (i + len2 &gt; len1) return -1; for (let j = 0; ; j++) &#123; if (j == len2) &#123; return i; &#125; if (haystack[i + j] !== needle[j]) &#123; break; &#125; &#125; &#125;&#125;; 解法三使用 substr 减少一层遍历。 var strStr = function (haystack, needle) &#123; if (needle === \"\") return 0; for (var i = 0; i &lt; haystack.length; i++) &#123; if (haystack[i] === needle[0] &amp;&amp; haystack.substr(i, needle.length) === needle) return i; &#125; return -1;&#125;;","categories":[{"name":"数据结构","slug":"data-structure","permalink":"https://haohaio.github.io/categories/data-structure/"}],"tags":[{"name":"LeetCode","slug":"leetcode","permalink":"https://haohaio.github.io/tags/leetcode/"}]},{"title":"浅谈移动端H5页面的适配方案","slug":"html5-layout","date":"2019-01-07T10:10:11.000Z","updated":"2020-04-09T07:21:45.889Z","comments":true,"path":"front-end/html5-layout.html","link":"","permalink":"https://haohaio.github.io/front-end/html5-layout.html","excerpt":"","text":"由于现在的移动设备屏幕尺寸众多，所以要做好适配真的是一个让人头痛的问题。今天就来了解一下如何解决这个问题。 在介绍方案之前，我们要首先要对 viewport 的 meta 标签有一个大概的了解，其主要用来告诉浏览器如何规范的渲染 Web 页面。我们经常可以在页面中看到这样的代码： &lt;!-- 将视窗的宽度设置为设备宽度。网页不缩放，不允许用户缩放。页面占满整个屏幕 (适配“刘海”屏)。--&gt;&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover\"/&gt; 方案一：浏览器自动缩放首先来介绍一种最简单粗暴的一种解决方案： 假如我们设计稿的宽度是 750px, 那么我们可以将 viewport 的 meta 标签设置为这个样子： &lt;!-- 将视窗的宽度设置为 750px --&gt;&lt;meta name=\"viewport\" content=\"width=750\"&gt; 然后写 CSS 样式关于尺寸的值时，所有的值都保持与设计稿的大小一致，这样我们就可以适配各个不同尺寸的设备啦~~ 不信的话，可以复制代码在浏览器里悄悄： &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=750\"&gt; &lt;title&gt;固定视窗宽度，浏览器自动缩放&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; &#125; div &#123; height: 80px; line-height: 80px; margin-bottom: 80px; background: #000; color: #fff; font-size: 48px; text-align: center; &#125; #first &#123; width: 400px; &#125; #second &#123; width: 600px; &#125; #third &#123; width: 750px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"first\"&gt;400px&lt;/div&gt; &lt;div id=\"second\"&gt;600px&lt;/div&gt; &lt;div id=\"third\"&gt;750px&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 这种做法，就是将视窗设置成固定的宽度，让浏览器自动缩放进行适配。但这种做法有一个很明显的弊端，就是不支持媒体查询，当我们需要跟聚设备宽度做一些样式的定制时，这种方案就做不到了。其原因就是我们将视窗设置成了固定的宽度，媒体查询时获得的宽度始终都是 750px 了。。。 简单来说，当我们的页面没有那么精致的时候，这种方案就可以满足我们的要求了~~ 方案二：动态设置缩放比例此外，我们还可以将视窗的宽度设为 device-width，动态设置缩放比例来进行适配。但这种方案其实与方案一是一样的，还是不支持媒体查询。因为缩放也会影响视窗的尺寸。这种方案相对于方案一来说，兼容性可能会更好一点，但具体兼容性没有进行测试，不太清楚~~ 动态设置缩放比例的代码如下： var resizeEvt = 'onorientationchange' in window ? 'orientationchange' : 'resize';var recalc = function() &#123; var metaEl = document.querySelector('meta[name=\"viewport\"]'); var designWidth = 750; // 设计稿的宽度 var scale = document.documentElement.clientWidth / designWidth; // 视窗宽度与设计稿宽度的比例 if (!metaEl) &#123; metaEl = document.createElement('meta'); metaEl.setAttribute('name', 'viewport'); metaEl.setAttribute('content', 'width=device-width, initial-scale=' + scale + ', maximum-scale=' + scale + ', minimum-scale=' + scale + ', user-scalable=no', 'viewport-fit=cover'); document.documentElement.firstElementChild.appendChild(metaEl); &#125; else &#123; metaEl.setAttribute('content', 'width=device-width, initial-scale=' + scale + ', minimum-scale=' + scale + ', maximum-scale=' + scale + ', user-scalable=no', 'viewport-fit=cover'); &#125;&#125;;if (document.addEventListener) &#123; // 监听屏幕旋转事件 window.addEventListener(resizeEvt, recalc, false); // 监听 dom 内容加载完毕事件 document.addEventListener('DOMContentLoaded', recalc, false);&#125; document.documentElement.clientWidth 还是始终都是 750px。 方案三：使用 rem 进行布局有时为了让页面更加精致，我们还是不能将视窗设置成固定的宽度。一般情况下，我们通过设置告诉浏览器使用它的理想视口，即将视窗的宽度设为设备的宽度，并不进行缩放： 苹果引入了理想视口的概念，它是对设备来说最理想的布局视口尺寸。理想视口中的网页用户最理想的宽度，用户进入页面的时候不需要缩放。 &lt;!-- 解决各种浏览器兼容问题的 理想视口 设置 --&gt;&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; CSS3 引入了 rem，rem 是一种 CSS 单位。简单来讲 rem 就是相对于根元素 &lt;html&gt; 的 font-size 来计算尺寸大小。 /* 设置根元素 html 的 font-size 为 16px */html &#123; font-size: 16px;&#125;/* 相对于根元素字体大小，所以为 32px */p &#123; font-size: 2rem;&#125; 基于此，我们可以使用 rem 布局来解决移动端 H5 页面的适配问题。即把与元素尺寸有关的 CSS 属性都以 rem 作为单位，通过计算为不同设备的根元素设置不同的 fontSize，这样页面在不同设备下就能保持一致的网页布局。 动态设置根元素的 fontSize 大小的代码简单如下： var docEl = document.documentElement; // 获取根元素，即 &lt;html&gt; 元素var designWidth = 750; // 设计稿的宽度var baseFontSize = 100; // 写代码时所基于的根元素的 fontsize 大小。为了便于计算，设为 100var resizeEvt = 'onorientationchange' in window ? 'orientationchange' : 'resize';// 重新计算根元素的 fontsizevar recalc = function () &#123; var clientWidth = docEl.clientWidth; // 视窗宽度，即 viewport 的 meta 标签中 width 所设置的值 (device-width) * 缩放比例 if (clientWidth) &#123; docEl.style.fontSize = baseFontSize * (clientWidth / designWidth) + 'px'; &#125;&#125;;if (document.addEventListener) &#123; // 监听屏幕旋转事件 window.addEventListener(resizeEvt, recalc, false); // 监听 dom 内容加载完毕事件 document.addEventListener('DOMContentLoaded', recalc, false);&#125; 此外，我们还可以通过 CSS 预处理器来帮助我们将设计稿中的 px 转为 rem，比如在 sass 中封装一个方法： $base-font-size: 100;// 计算 px 转 rem@function px2rem($px) &#123; @return $px / $base-font-size * 1rem&#125; 方案四：使用 vw 进行布局vw 是基于Viewport视窗的长度单位，这里的视窗（Viewport）指的就是浏览器可视化的区域，而这个可视区域是 window.innerWidth/window.innerHeight 的大小。 vw：是 Viewport’s width 的简写，1vw 等于 window.innerWidth的1% vh：和 vw 类似，是Viewport’s height的简写，1vh 等于window.innerHeihgt的1% vmin：vmin的值是当前 vw 和 vh 中较小的值 vmax：vmax的值是当前 vw 和 vh 中较大的值 假如我们设计稿的宽度是 750px, 那么 1vw 就是 7.5px 我们依然是将 viewport 的 mate 标签设置为这个样子： &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; 我们直接将设计稿的中 px 换算成 vw 来设置样式后，就可以完成适配了，而不需要再像方案三中动态的修改 html 元素的 fontSize 了~~ 这种方案与方案三的方案思想是一致的，都是进行等比例缩放。相对于方案三来说，这种方案兼容性较差一些，\b但网上也有一些方法来处理这问题，这里就不详细介绍了。。。","categories":[{"name":"前端","slug":"front-end","permalink":"https://haohaio.github.io/categories/front-end/"}],"tags":[{"name":"HTML5","slug":"html5","permalink":"https://haohaio.github.io/tags/html5/"}]},{"title":"[JavaScript LeetCode]27. 移除元素","slug":"leetcode-remove-element","date":"2019-01-03T15:23:03.000Z","updated":"2020-04-21T08:26:36.799Z","comments":true,"path":"data-structure/leetcode-remove-element.html","link":"","permalink":"https://haohaio.github.io/data-structure/leetcode-remove-element.html","excerpt":"","text":"原题链接 给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。 不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。 示例: 给定 nums = [3,2,2,3], val = 3,函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。给定 nums = [0,1,2,2,3,0,4,2], val = 2,函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。 说明: 为什么返回数值是整数，但输出的答案是数组呢? 请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。 你可以想象内部操作如下: // nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝int len = removeElement(nums, val);// 在函数里修改输入数组对于调用者是可见的。// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。for (int i = 0; i &lt; len; i++) &#123; print(nums[i]);&#125; 解法一和 26 题一样，并不是真的要删除元素。所以，可以使用 newLen 记录要返回数组的长度。遍历数组时，当前元素与目标值不相同时，依次从下标 0 开始，覆盖原始数组的值即可。 var removeElement = function (nums, val) &#123; let newLen = 0; let len = nums.length; for (let i = 0; i &lt; len; i++) &#123; if (nums[i] != val) &#123; nums[newLen++] = nums[i]; &#125; &#125; return newLen;&#125;; 解法二当遍历时，遇到等于目标值的元素时，从数组末位元素开始倒序替换当前下标元素，并将要返回的数组长度 - 1。这种解法，当重复值较少时，可以减少赋值操作。 var removeElement = function (nums, val) &#123; let len = nums.length; for (let i = 0; i &lt; len; ) &#123; if (nums[i] === val) &#123; nums[i] = nums[len - 1]; len--; &#125; else &#123; // 只有当前下标元素和目标值不相等时，下标才移动 i++; &#125; &#125; return len;&#125;;","categories":[{"name":"数据结构","slug":"data-structure","permalink":"https://haohaio.github.io/categories/data-structure/"}],"tags":[{"name":"LeetCode","slug":"leetcode","permalink":"https://haohaio.github.io/tags/leetcode/"}]},{"title":"使用 Docker 搭建 MySQL 服务","slug":"docker-mysql","date":"2019-01-03T01:45:56.000Z","updated":"2020-04-09T07:21:45.770Z","comments":true,"path":"others/docker-mysql.html","link":"","permalink":"https://haohaio.github.io/others/docker-mysql.html","excerpt":"","text":"最近在学习 Spring Boot 的时候，需要搭建一个 mysql 的服务，我们可以通过 docker 非常方便地搭建一个 mysql 服务。只需一个命令： # 默认使用 mysql:@latest 镜像，若未安装会自动下载$ docker run --name mysql-dev -e MYSQL_ROOT_PASSWORD=123456 -p 3306:3306 -d mysql –-name：给新创建的容器命名，此处命名为 mysql-dev -e：配置信息，此处配置 mysql 的 root 用户的登陆密码 -p：端口映射，此处映射主机 3306 端口到容器 mysql-dev 的 3306 端口 -d：成功启动容器后输出容器的 ID mysql 的服务已经搭好了。 可以通过 docker 连接上 mysql 服务，进行其它一些操作 # 登录容器$ docker exec -it mysql-dev bash# 连接 mysql 服务 (-p后面没有空格。第一次连接时会提示在命令行界面上直接使用密码不安全)$ mysql -p123456 # 创建一个数据库 db_examplemysql&gt; create database db_example;# 创建用户mysql&gt; create user 'springuser'@'%' identified by 'ThePassword';# 给 springuser 用户 db_example 的所有权限mysql&gt; grant all on db_example.* to 'springuser'@'%'; Tips发现使用可视化工具 (笔者用的 Navicat) 连接 mysql 服务时，会报 Authentication plugin &#39;caching_sha2_password&#39; cannot be loaded 错误。是因为新版本的 mysql 加密方式改了, 而当前可视化工具还不支持。所以我们先通过修改密码将加密方式改为以前的加密方式： mysql&gt; ALTER USER 'root' IDENTIFIED WITH mysql_native_password BY '123456';","categories":[{"name":"其它","slug":"others","permalink":"https://haohaio.github.io/categories/others/"}],"tags":[{"name":"Docker","slug":"docker","permalink":"https://haohaio.github.io/tags/docker/"}]},{"title":"Canvas学习笔记六：绘制仪表盘","slug":"canvas-dashboard","date":"2019-01-02T02:02:05.000Z","updated":"2020-04-09T07:21:56.861Z","comments":true,"path":"front-end/canvas-dashboard.html","link":"","permalink":"https://haohaio.github.io/front-end/canvas-dashboard.html","excerpt":"","text":"基于之前所学的关于 Canvas 的知识，来完成一个综合实例，绘制一个刻度仪表盘。 一、绘制网格线function drawGrid(color, stepX, stepY) &#123; context.save(); context.strokeStyle = color; context.lineWidth = 0.5; for (var i = stepX + 0.5; i &lt; context.canvas.width; i += stepX) &#123; context.beginPath(); context.moveTo(i, 0); context.lineTo(i, context.canvas.height); context.stroke(); &#125; for (var i = stepY + 0.5; i &lt; context.canvas.height; i += stepY) &#123; context.beginPath(); context.moveTo(0, i); context.lineTo(context.canvas.width, i); context.stroke(); &#125;&#125;drawGrid('lightgray', 10, 10); 二、绘制仪表盘中心圆点function drawCentroid() &#123; context.beginPath(); context.save(); context.strokeStyle = 'rgba(0, 0, 0, .5)'; context.fillStyle = 'rgba(80, 190, 240, .6)'; context.arc(canvas.width / 2, canvas.height / 2, 10, 0, Math.PI * 2, false); context.stroke(); context.fill(); context.restore();&#125; 三、绘制仪表盘指针function drawCentroidGuidewire() &#123; // 计算得到刻度指示点坐标 var angle = -Math.PI / 4; var radius = 205; var endPoint = &#123; x: canvas.width / 2 + radius * Math.cos(angle), y: canvas.height / 2 + radius * Math.sin(angle) &#125;; context.save(); context.strokeStyle = 'goldenrod'; context.fillStyle = 'rgba(250, 250, 0, 0.6)'; // 绘制刻度指示点 context.beginPath(); context.strokeStyle = 'rgba(100, 140, 230, 0.9)'; context.arc(endPoint.x, endPoint.y, 5, 0, Math.PI * 2, false); context.fill(); context.stroke(); // 绘制中心原点与指示点连接线 context.beginPath(); context.moveTo(canvas.width / 2 , canvas.height / 2); context.lineTo(endPoint.x, endPoint.y); context.stroke(); context.restore();&#125; 四、绘制外层圆圈function drawRing() &#123; drawRingOuterCircle(); context.strokeStyle = 'rgba(0, 0, 0, .1)'; context.arc(canvas.width / 2, canvas.height / 2, 185, 0, Math.PI * 2, false); context.fillStyle = 'rgba(100, 140, 230, .1)'; context.fill(); context.stroke();&#125;function drawRingOuterCircle() &#123; context.shadowColor = 'rgba(0, 0, 0, .7)'; context.shadowOffsetX = 3; context.shadowOffsetY = 3; context.shadowBlur = 6; context.strokeStyle = 'rgba(100, 140, 230, .5)'; context.beginPath(); context.arc(canvas.width / 2, canvas.height / 2, 205, 0, Math.PI * 2, true); context.stroke();&#125; 五、绘制内层圆function drawTickInnerCircle() &#123; context.sava(); context.beginPath(); context.strokeStyle = 'rgba(0, 0, 0, .1)'; context.arc(canvas.width / 2, canvas.height / 2, 175, 0, Math.PI * 2, false); context.stroke(); context.restore();&#125; 六、绘制刻度线function drawTicks() &#123; context.save(); for (var angle = 0, cnt = 0; angle &lt; Math.PI * 2; angle += Math.PI / 64, cnt++) &#123; drawTick(angle, 185, cnt++); &#125; context.restore();&#125;function drawTick(angle, radius, cnt) &#123; context.beginPath(); var tickWidth = cnt % 4 === 0 ? 10 : 5; context.moveTo(canvas.width / 2 + Math.cos(angle) * (radius - tickWidth), canvas.height / 2 + Math.sin(angle) * (radius - tickWidth)); context.lineTo(canvas.width / 2 + Math.cos(angle) * (radius), canvas.height + Math.sin(angle) * (radius)); context.strokeStyle = 'rgba(100, 140, 230, 0.7)'; context.stroke();&#125; 七、绘制标注function drawAnnotations() &#123; context.save(); context.fillStyle = 'rgba(0, 0, 230, 0.9)'; context.font = '12px Helvetica'; for (var angle = 0; angle &lt; 2 * Math.PI; angle += Math.PI / 8) &#123; context.beginPath(); context.fillText((angle * 180 / Math.PI).toFixed(0), canvas.width / 2 + Math.cos(angle) * (185 - 10 * 2), canvas.height / 2 - Math.sin(angle) * (185 - 10 * 2)); &#125; context.restore();&#125;","categories":[{"name":"前端","slug":"front-end","permalink":"https://haohaio.github.io/categories/front-end/"}],"tags":[{"name":"CSS","slug":"css","permalink":"https://haohaio.github.io/tags/css/"}]},{"title":"Canvas学习笔记五：线段","slug":"canvas-line","date":"2018-12-29T03:01:09.000Z","updated":"2020-04-09T07:21:57.067Z","comments":true,"path":"front-end/canvas-line.html","link":"","permalink":"https://haohaio.github.io/front-end/canvas-line.html","excerpt":"","text":"Canvas 绘图环境提供了两个可以用来创建线段的方法： moveTo(x, y)向当前路径增加一条子路径，该子路径只包含一个点，就是参数传入的点。 lineTo(x, y)若当前路径没有子路径，那么这个方法就与 moveTo() 方法一样。如果当前路径中存在子路径，那么该方法会将会将参数传入的点加入到子路径中。 绘制线段时还是需要创建完路径后，调用 stroke() 方法才能绘制。 线段与像素边界 如果在像素边界绘制一条 1 像素宽的线段，那么 Canvas 的绘图环境对象会试着将分别将半个像素画在边界中线的两边。然而，在一个整像素范围内，绘制半个像素宽的像素是不可能的，所以边界两个方向的半个像素都被扩展为一个像素。所以最后绘制的线段宽度为 2 个像素。 如果将线段绘制在一个像素的中间，那么刚好绘制的就是 1 像素宽的线段。 示例 线段端点的绘制我们可以是使用 Canvas 绘图环境的 lineCap 属性来控制线段端点的绘制。可取值为： butt：默认值，无特殊处理。 round：在端点处多画一个半圆，其半径等于线宽的一半。 square：在端点处多画一个矩形，长度与线宽一致，宽度等于线宽的一半。 线段连接点的绘制我们可以是使用 Canvas 绘图环境的 lineJoin 属性来控制线段连接点的绘制。可取的值：bevel, round, miter，默认值是 miter，具体如下图所示： 当取值为 miter 时，还可以指定一个 miterLimit 属性，它表示对斜接线的长度与二分之一线宽的比值做出限制处理。 斜接线指的是在两条线交汇处内角和外角之间的距离。 若比值超过了设置的限制值，浏览器就会以 bevel 的方式来绘制线段的连接点。默认值为 10.0。","categories":[{"name":"前端","slug":"front-end","permalink":"https://haohaio.github.io/categories/front-end/"}],"tags":[{"name":"CSS","slug":"css","permalink":"https://haohaio.github.io/tags/css/"}]},{"title":"[JavaScript LeetCode]26. 删除排序数组中的重复项","slug":"leetcode-remove-duplicates-from-sorted-array","date":"2018-12-29T02:02:51.000Z","updated":"2020-04-21T07:50:31.805Z","comments":true,"path":"data-structure/leetcode-remove-duplicates-from-sorted-array.html","link":"","permalink":"https://haohaio.github.io/data-structure/leetcode-remove-duplicates-from-sorted-array.html","excerpt":"","text":"原题链接 给定一个排序数组，你需要在 原地 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。 不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。 示例: 给定数组 nums = [1,1,2],函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。你不需要考虑数组中超出新长度后面的元素。给定 nums = [0,0,1,1,1,2,2,3,3,4],函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。你不需要考虑数组中超出新长度后面的元素。 说明: 为什么返回数值是整数，但输出的答案是数组呢? 请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。 你可以想象内部操作如下: // nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝int len = removeDuplicates(nums);// 在函数里修改输入数组对于调用者是可见的。// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。for (int i = 0; i &lt; len; i++) &#123; print(nums[i]);&#125; 解法根据题意，并不是真的要删除数组中重复的元素。 所以可以用一个 temp 变量记录要返回的长度，遍历数组时，如果后面的元素和前面的元素不同，就以 temp 值为下标，修改该下标对应的值，然后让 temp 变量加 1，最后返回 temp 即可。 var removeDuplicates = function (nums) &#123; let len = nums.length; if (len &lt;= 1) return len; let temp = 1; for (let i = 1; i &lt; len; i++) &#123; if (nums[i - 1] !== nums[i]) &#123; nums[temp++] = nums[i]; &#125; &#125; return temp;&#125;;","categories":[{"name":"数据结构","slug":"data-structure","permalink":"https://haohaio.github.io/categories/data-structure/"}],"tags":[{"name":"LeetCode","slug":"leetcode","permalink":"https://haohaio.github.io/tags/leetcode/"}]},{"title":"[JavaScript LeetCode]21. 合并两个有序链表","slug":"leetcode-merge-two-sorted-lists","date":"2018-12-27T13:11:26.000Z","updated":"2020-04-28T02:29:15.520Z","comments":true,"path":"data-structure/leetcode-merge-two-sorted-lists.html","link":"","permalink":"https://haohaio.github.io/data-structure/leetcode-merge-two-sorted-lists.html","excerpt":"","text":"原题链接 将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 示例: 输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4 首先要对 ListNode 有一定的了解： ListNode 存储了两个变量：val 和 next。val 是这个节点的值，next 是指向下一节点的指针，当 next 为空指针时，这个节点是链表的最后一个节点。 function ListNode(val) &#123; this.val = val; this.next = null;&#125; 解法一可以创建一个新链表，新链表指针每次指向值小的节点，依次比较下去，最后，当其中一个链表到达了末尾，我们只需要把新链表指针指向另一个没有到末尾的链表此时的指针即可。 var mergeTwoLists = function (l1, l2) &#123; let head = new ListNode(0); let temp = head; while (l1 !== null &amp;&amp; l2 !== null) &#123;˝ if (l1.val &lt; l2.val) &#123; temp.next = l1; l1 = l1.next; &#125; else &#123; temp.next = l2; l2 = l2.next; &#125; temp = temp.next; &#125; temp.next = l1 !== null ? l1 : l2; return head.next;&#125;; 解法二也可以使用递归。 var mergeTwoLists = function (l1, l2) &#123; if (l1 === null) return l2; if (l2 === null) return l1; if (l1.val &lt; l2.val) &#123; l1.next = mergeTwoLists(l1.next, l2); return l1; &#125; else &#123; l2.next = mergeTwoLists(l1, l2.next); return l2; &#125;&#125;;","categories":[{"name":"数据结构","slug":"data-structure","permalink":"https://haohaio.github.io/categories/data-structure/"}],"tags":[{"name":"LeetCode","slug":"leetcode","permalink":"https://haohaio.github.io/tags/leetcode/"}]},{"title":"[JavaScript LeetCode]20. 有效的括号","slug":"leetcode-vaild-parentheses","date":"2018-12-26T14:32:30.000Z","updated":"2020-04-21T03:40:47.104Z","comments":true,"path":"data-structure/leetcode-vaild-parentheses.html","link":"","permalink":"https://haohaio.github.io/data-structure/leetcode-vaild-parentheses.html","excerpt":"","text":"原题链接 给定一个只包括 &#39;(&#39;，&#39;)&#39;，&#39;{&#39;，&#39;}&#39;，&#39;[&#39;，&#39;]&#39; 的字符串，判断字符串是否有效。 有效字符串需满足： 左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。 注意空字符串可被认为是有效字符串。 示例: 输入: &quot;()&quot;输出: true输入: &quot;()[]&#123;&#125;&quot;输出: true输入: &quot;(]&quot;输出: false输入: &quot;([)]&quot;输出: false输入: &quot;&#123;[]&#125;&quot;输出: true 解法一通过观察发现，在合法的情况下，当遇到第一个右括号时，其前面紧邻的一个括号必定是和其匹配的左括号。那么我们可以用栈来解决这个问题，当出现左括号的时候入栈，当遇到右括号时，判断栈顶的左括号是否和其匹配，匹配的话出栈，不匹配的话直接返回 false 即可。最终判断是否空栈即可。在 JavaScript 中，我们可以使用数组模拟栈数据结构。 var isValid = function (s) &#123; const map = &#123; \")\": \"(\", \"]\": \"[\", \"&#125;\": \"&#123;\", &#125;; let stack = []; for (let i = 0; i &lt; s.length; i++) &#123; let c = s[i]; if (map[c] !== undefined) &#123; let topElement = stack.length ? stack.pop() : \"\"; if (topElement !== map[c]) &#123; return false; &#125; &#125; else &#123; stack.push(c); &#125; &#125; return stack.length === 0;&#125;; 解法二用数字的 ++ 和 --模拟栈的操作，因为无需删除数组元素使其操作更快。有个细节注意下 top = 1;，从而省去了之后判空的操作和 top - 1 导致数组越界的错误。 var isValid = function (s) &#123; const map = &#123; \")\": \"(\", \"]\": \"[\", \"&#125;\": \"&#123;\", &#125;; let top = 1; let stack = new Array(s.length + top); for (let i = 0; i &lt; s.length; i++) &#123; let c = s[i]; if (map[c] !== undefined) &#123; let topElement = stack[--top]; if (topElement !== map[c]) &#123; return false; &#125; &#125; else &#123; stack[top++] = c; &#125; &#125; return top === 1;&#125;; 解法三找到最内层的括号对，消去，重复此过程，若存在无法消去的字符则说明字符串无效。逻辑简单，但是效率不高。 var isValid = function (s) &#123; while (s.length) &#123; let temp = s; s = s.replace(/\\(\\)/g, \"\"); s = s.replace(/\\[\\]/g, \"\"); s = s.replace(/\\&#123;\\&#125;/g, \"\"); if (s === temp) return false; &#125; return true;&#125;;","categories":[{"name":"数据结构","slug":"data-structure","permalink":"https://haohaio.github.io/categories/data-structure/"}],"tags":[{"name":"LeetCode","slug":"leetcode","permalink":"https://haohaio.github.io/tags/leetcode/"}]},{"title":"[JavaScript LeetCode]14. 最长公共前缀","slug":"leetcode-longest-common-prefix","date":"2018-12-26T01:23:16.000Z","updated":"2020-04-21T02:45:15.842Z","comments":true,"path":"data-structure/leetcode-longest-common-prefix.html","link":"","permalink":"https://haohaio.github.io/data-structure/leetcode-longest-common-prefix.html","excerpt":"","text":"原题链接 编写一个函数来查找字符串数组中的最长公共前缀。 如果不存在公共前缀，返回空字符串 “”。 示例: 输入: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]输出: &quot;fl&quot;输入: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]输出: &quot;&quot;解释: 输入不存在公共前缀。 说明: 所有输入只包含小写字母 a-z。 解法一暴力破解。 var longestCommonPrefix = function (strs) &#123; if (!strs.length) return \"\"; let prefix = strs[0]; let len = strs.length; for (let i = 1; i &lt; len; i++) &#123; while (!strs[i].startsWith(prefix)) &#123; prefix = prefix.substring(0, prefix.length - 1); &#125; if (!prefix.length) &#123; return \"\"; &#125; &#125; return prefix;&#125;; 解法二相对于解法一，使用垂直扫描进行优化。并取字符串数组中最短字符串的长度，以减少嵌套遍历次数。 var longestCommonPrefix = function (strs) &#123; if (!strs.length) return \"\"; let minLen = Infinity; strs.forEach((str) =&gt; &#123; minLen = Math.min(minLen, str.length); &#125;); let first = strs[0]; for (let i = 0; i &lt; minLen; i++) &#123; let c = first[i]; for (let j = 1; j &lt; strs.length; j++) &#123; if (strs[j][i] !== c) &#123; return first.substring(0, i); &#125; &#125; &#125; return first.substring(0, minLen);&#125;; 解法三首先利用 sort 的排序方法将数组按照编码排序，只需对数组首位和末位进行比较。 var longestCommonPrefix = function (strs) &#123; if (!strs.length) return \"\"; strs.sort(); let first = strs[0]; let end = strs[strs.length - 1]; if (first === end || end.startsWith(first))) &#123; return first; &#125; for (let i = 0; i &lt; first.length; i++) &#123; if (first[i] !== end[i]) &#123; return first.substring(0, i); &#125; &#125;&#125;;","categories":[{"name":"数据结构","slug":"data-structure","permalink":"https://haohaio.github.io/categories/data-structure/"}],"tags":[{"name":"LeetCode","slug":"leetcode","permalink":"https://haohaio.github.io/tags/leetcode/"}]},{"title":"[Java LeetCode]13. 罗马数字转整数","slug":"leetcode-roman-to-integer","date":"2018-12-24T01:40:46.000Z","updated":"2020-04-20T07:18:55.340Z","comments":true,"path":"data-structure/leetcode-roman-to-integer.html","link":"","permalink":"https://haohaio.github.io/data-structure/leetcode-roman-to-integer.html","excerpt":"","text":"原题链接 罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。 字符 数值I 1V 5X 10L 50C 100D 500M 1000 例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况： I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。 X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。 给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。 示例: 输入: &quot;III&quot;输出: 3输入: &quot;IV&quot;输出: 4输入: &quot;IX&quot;输出: 9输入: &quot;LVIII&quot;输出: 58解释: L = 50, V= 5, III = 3.输入: &quot;MCMXCIV&quot;输出: 1994解释: M = 1000, CM = 900, XC = 90, IV = 4. 解法可以看到罗马数字的计数机制中，小的数字（限于 Ⅰ、X 和 C）在大的数字的左边，所表示的数等于大数减小数得到的数。其它情况都是数字相加即可。那么我们可以利用 HashMap 来完成罗马数字的 7 个数字符号与整数的映射关系，然后对字符串逆向遍历，处理得到结果。代码如下： var romanToInt = function (s) &#123; var hashNum = &#123; I: 1, V: 5, X: 10, L: 50, C: 100, D: 500, M: 1000, &#125;; var len = s.length; var result = hashNum[s[len - 1]]; for (var i = len - 2; i &gt;= 0; i--) &#123; if (hashNum[s[i]] &lt; hashNum[s[i + 1]]) &#123; result -= hashNum[s[i]]; &#125; else &#123; result += hashNum[s[i]]; &#125; &#125; return result;&#125;;","categories":[{"name":"数据结构","slug":"data-structure","permalink":"https://haohaio.github.io/categories/data-structure/"}],"tags":[{"name":"LeetCode","slug":"leetcode","permalink":"https://haohaio.github.io/tags/leetcode/"}]},{"title":"Canvas学习笔记四：路径","slug":"canvas-path","date":"2018-12-22T09:05:30.000Z","updated":"2020-04-09T07:21:56.783Z","comments":true,"path":"front-end/canvas-path.html","link":"","permalink":"https://haohaio.github.io/front-end/canvas-path.html","excerpt":"","text":"除了绘制矩形的两个 API 外，Canvas 的绘图环境还提供了其它一些方法用于绘制更加复杂的图形。这些方法都是基于路径 (path) 的。 图形路径 (rect &amp; arc)我们可以先看一个使用 context 提供的 API 绘制简单图形路径 (矩形和圆弧) 的基本示例：Canvas Path 通过示例，我们可以看到绘制图形的基本步骤如下： context 调用 beginPath() 方法来开始一段新的路径。 context 使用 rect() 或 arc() 方法分别创建矩形及弧形路径。 rect() 方法创建的路径是封闭的。 arc() 方法创建的路径，是不封闭的。除非是个圆形路径。可调用 closePath() 方法封闭路径。 context 调用 stroke() 或 fill() 方法，对路径进行描边或填充。 其中对 arc() 方法进行一下详细介绍： /** * x: 圆的中心的 x 坐标 * y: 圆的中心的 y 坐标 * radii: 圆的半径 * startAngle: 起始角，以弧度计。 (弧的圆形的三点钟位置是 0 度) * endAngle: 结束角，以弧度计。 * counterclockwise: 规定应该逆时针还是顺时针绘图。false = 顺时针，true = 逆时针。默认值为 false。 */arc(x, y, radii, startAngle, endAngle, counterclockwise) rect() 方法绘制路径时，总是顺时针方向的。(我们可以自定义方法来支持逆时针方向绘制矩形路径) 子路径Canvas 之中只能有一条路径存在，Canvas 规范将其称为 “当前路径”（current path）。然而，这条路径可以包含许多子路径（subpath）。而子路径是由两个或更多的点组成的。 如果在当前路径中存在子路径的情况下调用 arc() 方法, 那么此方法就会从子路径的终点向圆弧的起点画一条线。 填充路径时的 “非零环绕规则” (nonzero winding rule)如果当前路径是循环的，或是包含多个相交的子路径，那么 Canvas 的绘图环境就需要判断，当 fill() 方法被调用时，应该如何进行填充。Canvas 是使用 “非零环绕规则” 来进行判断的： 对于路径中任意指定区域，从该区域内部画一条足够长的线段，使此线段的完全落在路径范围之外。 然后，将计数器初始化为 0，每当这个线段与路径上的直线或曲线相交时，就改变计数器的值，如果是与路径顺时针相交时，那么计数器就加 1， 如果是与路径逆时针相交时，那么计数器就减 1。 如果计数器最终值不是 0，那么此区域就在路径范围里面，在调用 fill() 方法时，浏览器就会对其进行填充。如果最终值是 0，那么此区域就不在路径范围内，浏览器就不会对其进行填充。 具体情况如图所示：","categories":[{"name":"前端","slug":"front-end","permalink":"https://haohaio.github.io/categories/front-end/"}],"tags":[{"name":"CSS","slug":"css","permalink":"https://haohaio.github.io/tags/css/"}]},{"title":"[JavaScript LeetCode]9. 回文数","slug":"leetcode-palindrome-number","date":"2018-12-22T02:19:46.000Z","updated":"2020-04-20T07:27:58.435Z","comments":true,"path":"data-structure/leetcode-palindrome-number.html","link":"","permalink":"https://haohaio.github.io/data-structure/leetcode-palindrome-number.html","excerpt":"","text":"原题链接 判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。 示例: 输入: 121输出: true输入: -121输出: false解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。输入: 10输出: false解释: 从右向左读, 为 01 。因此它不是一个回文数。 Example 2: 输入: 10输出: false解释: 从右向左读, 为 01 。因此它不是一个回文数。 进阶: 你能不将整数转为字符串来解决这个问题吗？ 解法一根据题意，可以看出负数肯定不是，非 0 的 10 的倍数的数也不是。把数字转为字符串，然后使用数组的 reverse() 方法。 var isPalindrome = function (x) &#123; if (x &lt; 0 || (x !== 0 &amp;&amp; x % 10 === 0)) &#123; return false; &#125; let rev = x.toString().split(\"\").reverse().join(\"\"); return x == rev;&#125;; 解法二把数字进行反转进行比较就可得出结果。 var isPalindrome = function (x) &#123; if (x &lt; 0 || (x !== 0 &amp;&amp; x % 10 === 0)) &#123; return false; &#125; let copyX = x; let rev = 0; while (copyX !== 0) &#123; rev = rev * 10 + (copyX % 10); copyX = parseInt(copyX / 10); &#125; return x === rev;&#125;; 解法三但其实我们不需要将数字完全反转进行比对，只需要将数字反转一半进行然后与前面一半的数字进行比对即可。代码如下： var isPalindrome = function (x) &#123; if (x &lt; 0 || (x !== 0 &amp;&amp; x % 10 === 0)) &#123; return false; &#125; let rev = 0; while (x &gt; rev) &#123; rev = rev * 10 + (x % 10); x = parseInt(x / 10); &#125; return x === rev || x === parseInt(rev / 10);&#125;;","categories":[{"name":"数据结构","slug":"data-structure","permalink":"https://haohaio.github.io/categories/data-structure/"}],"tags":[{"name":"LeetCode","slug":"leetcode","permalink":"https://haohaio.github.io/tags/leetcode/"}]},{"title":"[JavaScript LeetCode]7. 整数反转","slug":"leetcode-reverse-integer","date":"2018-12-21T15:08:32.000Z","updated":"2020-04-21T06:32:25.952Z","comments":true,"path":"data-structure/leetcode-reverse-integer.html","link":"","permalink":"https://haohaio.github.io/data-structure/leetcode-reverse-integer.html","excerpt":"","text":"原题链接 给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。 示例: 输入: 123输出: 321输入: -123输出: -321输入: 120输出: 21 假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−2^31, 2^31 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。 解法一var reverse = function (x) &#123; let rev = 0; while (x !== 0) &#123; let pop = x % 10; x = parseInt(x / 10); if ( rev &gt; parseInt((Math.pow(2, 31) - 1) / 10) || (rev === parseInt((Math.pow(2, 31) - 1) / 10) &amp;&amp; pop &gt; 7) ) &#123; return 0; &#125; if ( rev &lt; parseInt(Math.pow(-2, 31) / 10) || (rev === parseInt(Math.pow(-2, 31) / 10) &amp;&amp; pop &lt; -8) ) &#123; return 0; &#125; rev = rev * 10 + pop; &#125; return rev;&#125;; 解法二var reverse = function (x) &#123; var isNegative = x &lt; 0 ? true : false; var target = (isNegative ? -x : x).toString().split(\"\").reverse().join(\"\"); target = isNegative ? -target : +target; var outRange = target &lt; Math.pow(-2, 31) || target &gt; Math.pow(2, 31) - 1; return outRange ? 0 : target;&#125;;","categories":[{"name":"数据结构","slug":"data-structure","permalink":"https://haohaio.github.io/categories/data-structure/"}],"tags":[{"name":"LeetCode","slug":"leetcode","permalink":"https://haohaio.github.io/tags/leetcode/"}]},{"title":"[JavaScript LeetCode]1. 两数之和","slug":"leetcode-two-sum","date":"2018-12-21T13:24:11.000Z","updated":"2020-04-15T02:32:11.077Z","comments":true,"path":"data-structure/leetcode-two-sum.html","link":"","permalink":"https://haohaio.github.io/data-structure/leetcode-two-sum.html","excerpt":"","text":"原题链接 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 示例： 给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1] 解法一var twoSum = function (nums, target) &#123; for (var i = 0; i &lt; nums.length; i++) &#123; var dif = target - nums[i]; for (var j = i + 1; j &lt; nums.length; j++) &#123; if (nums[j] === dif) &#123; return [i, j]; &#125; &#125; &#125;&#125;; 解法二var twoSum = function (nums, target) &#123; var temp = &#123;&#125;; for (var i = 0; i &lt; nums.length; i++) &#123; var dif = target - nums[i]; if (temp[dif] !== undefined) &#123; return [temp[dif], i]; &#125; temp[nums[i]] = i; &#125;&#125;; var twoSum = function (nums, target) &#123; let map = new Map(); for (var i = 0; i &lt; nums.length; i++) &#123; let dif = target - nums[i]; if (map.has(dif)) &#123; return [map.get[i], i]; &#125; map.set(nums[i], i); &#125;&#125;;","categories":[{"name":"数据结构","slug":"data-structure","permalink":"https://haohaio.github.io/categories/data-structure/"}],"tags":[{"name":"LeetCode","slug":"leetcode","permalink":"https://haohaio.github.io/tags/leetcode/"}]},{"title":"CSS颜色值之HSL","slug":"CSS颜色值之HSL","date":"2018-12-20T10:01:17.000Z","updated":"2020-04-09T07:21:56.816Z","comments":true,"path":"front-end/css-color-hsl.html","link":"","permalink":"https://haohaio.github.io/front-end/css-color-hsl.html","excerpt":"","text":"CSS3 的 HSL 方法已经被现代浏览器广泛的支持，但在日常开发中还是很少使用，今天我们就来简单了解一下，示例代码如下： .test &#123; background-color: hsl(360, 50%, 50%);&#125; IE8 以及更早的版本不支持使用 HSL 设置颜色值。 RGB vs HSLCSS3 颜色规范中说到，之所以要增加对 HSL 格式的支持，是因为以 RGB 方式来指定颜色，主要有两个缺陷： 它是以硬件为导向的。这种表述颜色的形式，是基于“阴极射线管”的； 它不直观。 HSL 的 取值 H：Hue(色调)。0(或360)表示红色，120表示绿色，240表示蓝色，也可取其他数值来指定颜色。取值为：0 - 360 S：Saturation(饱和度)。取值为：0.0% - 100.0% L：Lightness(亮度)。取值为：0.0% - 100.0% HSL颜色当然可以转换为 RGB颜色 或 HEX颜色。","categories":[{"name":"前端","slug":"front-end","permalink":"https://haohaio.github.io/categories/front-end/"}],"tags":[{"name":"CSS","slug":"css","permalink":"https://haohaio.github.io/tags/css/"}]},{"title":"Docker 入门","slug":"Docker入门","date":"2018-12-19T13:47:46.000Z","updated":"2020-04-24T08:17:45.703Z","comments":true,"path":"others/docker-introduction.html","link":"","permalink":"https://haohaio.github.io/others/docker-introduction.html","excerpt":"","text":"简介Docker 属于 Linux 容器的一种封装，提供简单易用的容器使用接口。 Docker 将应用程序与该程序的依赖，打包在一个文件里面。运行这个文件，就会生成一个虚拟容器。程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。有了 Docker，就不用担心环境问题。 Docker 系统有两个程序：Docker 服务端 和 Docker 客户端。 Docker 服务端是一个服务进程，管理着所有的容器。 Docker 客户端则扮演着 Docker 服务端的远程控制器，可以用来控制 Docker 的服务端进程。 大部分情况下，Docker 服务端和客户端运行在一台机器上。 # 查看 docker 版本$ docker version 虚拟机 VS Linux 容器Linux 容器与虚拟机享有相似的资源隔离和分配，但是两者还是有很大区别的。 虚拟机可以在一种操作系统里面运行另一种操作系统。看上去跟真实系统一模一样，而对于底层系统来说，虚拟机就是一个普通文件，不需要了就删掉，对其他部分毫无影响。Linux 容器是 Linux 的一种虚拟化技术。它不是模拟一个完整的操作系统，而是对进程进行隔离。 由于 Linux 容器是进程级别的，相比虚拟机有很多优势： 启动快 (启动虚拟机就相当于启动操作系统) 资源占用少 (虚拟机会独占一部分内存和硬盘空间) 体积小 Docker Image An image is a lightweight, stand-alone, executable package that includes everything needed to run a piece of software, including the code, a runtime, libraries, environment variables, and config files. 只读模板，包含一个基本的操作系统。 # 搜索可用镜像$ docker search tutorial# 下载镜像（用户名/镜像名:标签名）默认标签为 lastest$ docker pull learn/tutorial# 利用该镜像创建一个容器，执行完成会进入 bash 界面，输入 exit 可退出$ docker run -it learn/tutorials bash# 查看所有镜像$ docker images# 删除镜像（需先删除使用镜像的容器，使用 -f 参数强制删除(不推荐)）$ docker rmi 镜像名/镜像id Docker container A container is a runtime instance of an image. 一个轻量级的沙箱，容器是从镜像创建的，应用的运行实例。可以启动、开始、停止和删除，容器彼此间相互隔离。 # 创建容器# -i：让容器的标准输入保持打开; -t：让docker分配一个伪终端(pseudo-tty)，并绑定到容器的标准输入上。即允许用户交互$ docker create -it --name ubuntu-demo ubuntu:16.04# 启动容器$ docker start 容器名/容器id# 查看正在运行的容器列表$ docker ps# 查看所有容器列表$ docker ps -a# 查看刚刚操作的容器id$ docker ps -l# 新建并启动容器 (docker run = docker create + docker start)(-d：后台运行)$ docker run -it ubuntu:16.04 /bin/bash# run 命令后可跟在镜像中运行的命令# 使用 Ubuntu 的 apt-get 命令来安装 ping 程序# 在执行 apt-get 命令的时候，要带上 -y 参数。如果不指定 -y 参数的话，apt-get 命令会进入交互模式，需要用户输入命令来进行确认，但在 Docker 环境中是无法响应这种交互的。$ docker run learn/tutorial apt-get install -y ping# 登录容器$ docker exec -it 容器名/容器id /bin/bash# 停止容器$ docker stop 容器名/容器id# 停止所有容器$ docker stop $(docker ps -a -q)# 删除容器$ docker rm 容器id（需先停止容器或者使用 -f）# 删除所有容器$ docker rm $(docker ps -a -q) Docker 数据管理# copy 本地文件到容器内$ docker cp ./index.html nginx-demo:/usr/share/nginx/html# Volume# 将本地的 ~/docker/nginx-demo 目录挂载到容器内部的 /usr/share/nginx/html$ docker run --name nginx-demo -v ~/docker/nginx-demo:/usr/share/nginx/html -d nginx Docker 端口映射在启动容器的时候，如果不指定对应的参数，在容器外部是无法通过网络来访问容器内的网络应用和服务的。 # 将本地的 8001 端口映射到容器的 80 端口$ docker run --name nginx-demo -p 8001:80 -d nginx$ curl http://localhost:8001/# 查看容器端口映射情况$ docker port 容器名/容器id Docker 其它常用命令# 登录$ docker login -u 用户名 -p 密码# 发布镜像$ docker push 镜像名","categories":[{"name":"其它","slug":"others","permalink":"https://haohaio.github.io/categories/others/"}],"tags":[{"name":"Docker","slug":"docker","permalink":"https://haohaio.github.io/tags/docker/"}]},{"title":"Canvas学习笔记三：描边与填充","slug":"Canvas描边与填充","date":"2018-12-17T09:46:54.000Z","updated":"2020-04-09T07:21:56.816Z","comments":true,"path":"front-end/canvas-basic-drawing.html","link":"","permalink":"https://haohaio.github.io/front-end/canvas-basic-drawing.html","excerpt":"","text":"Canvas 的绘制操作主要分为两种：描边与填充。 坐标系统在进行绘制之前，我们还要先需要了解一下 Canvas 的坐标系统。只有先通过坐标确定了位置，Canvas 绘图环境才知道在哪里进行绘制。 在默认情况下，坐标系统是以 canvas 的左上角为原点，X 坐标向右方增长，Y 坐标向下方延伸。 但Canvas 的坐标系统并不是固定的，我们还可以对坐标系统进行平移、旋转、缩放等操作。这里先不做详细介绍 文本的绘制Canvas 的绘图环境提供了下面两个 API 来直接绘制文本： strokeText(string text, double x, double y) fillText(string text, double x, double y) 矩形的绘制Canvas 的绘图环境中仅有两个方法可以用来立即绘制图形 (其它都需要路径)，用于有关矩形的绘制： - strokeRect(double x, double y, double width, double height)- fillRect(double x, double y, double width, double height) 还有一个与矩形相关的 API，可用来清除矩形区域： - clearRect(double x, double y, double width, double height)\b 示例：Canvas Rect 描边与填充的样式 (strokeStyle &amp; fillStyle)颜色Canvas 默认使用的颜色为不透明的黑色。在绘制矩形的示例中通过 strokeStyle 属性修改的描边的颜色，通过 fillStyle 属性修改了填充的颜色。代码如下： // 设置描边颜色context.strokeStyle = 'red';// 设置填充颜色context.fillStyle = 'rgba(0, 0, 255, .5)'; 可看到左边矩形的边框遮盖了文本，这是因为边框用的是不透明色。 strokeStyle 与 fillStyle 的属性值可以是任意有效的 CSS 颜色字符串。可以用 RGB、RGBA、HSL、HSLA 以及十六进制 RGB 标注法来指定，还可以通过 ‘red’、‘yellow’ 这样的颜色名称来指定。 渐变色Canvas 元素支持线性 (linear) 渐变和放射 (radial) 渐变。 线性渐变我们可以通过 context 调用 createLinearGradient(double x1, double y1, double x2, double y2) 方法来创建线性渐变。需要向该方法传入两个点的 x、y 坐标，两点之间的连线就是 canvas 建立颜色渐变效果的依据。可通过该方法创建返回的 LinearGradient 实例调用 addColorStop(double stop, string color) 来向该渐变色添加颜色停止点。然后将该实例指定为 fillStyle 进行绘制。 示例：Canvas Linear Gradient 放射渐变我们可以通过 context 调用 createRadialGradient(double x1, double y1, double d1,double x2, double y2, double d2) 方法来创建放射渐变需要指定两个圆形 (x、y 指定圆心，d 指定半径)，它们表示某个圆锥的起止部位。该方法会返回一个 RadialGradient 实例。 示例：Canvas Radial Gradient 图案除了颜色和渐变色，Canvas 元素也允许使用图案来对图形和文本进行描边和填充。这里的图案可以是 image元素、canvas元素 或 video元素。 可以用 createPattern(pattern, string repetition) 来创建图案。第一个参数指定了图案所用的图像，第二个参数指定如何重复图案：repeat | repeat-x | repeat-y | no-repeat。 示例：Canvas Pattern","categories":[{"name":"前端","slug":"front-end","permalink":"https://haohaio.github.io/categories/front-end/"}],"tags":[{"name":"CSS","slug":"css","permalink":"https://haohaio.github.io/tags/css/"}]},{"title":"Canvas学习笔记二：绘图环境","slug":"Canvas的绘图环境","date":"2018-12-17T07:33:17.000Z","updated":"2020-04-09T07:21:56.490Z","comments":true,"path":"front-end/canvas-context.html","link":"","permalink":"https://haohaio.github.io/front-end/canvas-context.html","excerpt":"","text":"canvas 元素仅仅是为了充当绘图环境对象的容器而存在的，该环境对象提供了全部的绘制功能。本篇文章我们只关注 2d 绘图环境。 2d 绘图环境Canvas 的 2d 绘图环境对象提供了功能强大的API，可以用来绘制图形与文本，显示并修改图像等等。本篇文章我们就对 canvas 绘图环境的属性和一些方法做一些简单的了解。 下表列出了绘图环境对象的所有属性： 属性 简介 canvas 指向绘图环境所属的canvas对象 fillstyle 指定该绘图环境在后续的图形填充操作中所使用的颜色，渐变色或方案 font 设定在调用绘图环境对象的 fillText() 或 strokeText() 方法时，所使用的字型 globalAlpha 全局透明度设定，取值范围 0~1.0 globalCompsiteOperation 将某个物体绘制在其他的物体之上时采用的绘制方式 lineCap 如何绘制线段的端点，可取的值：butt、round、square，默认值是 butt lineWidth 绘制线段的屏幕像素宽度。非负非无穷的 double 值，默认值是 1.0 lineJoin 在两条线段相交时如何绘制交点，可取的值：bevel, round, miter，默认值是 miter miterLimit 如何绘制 miter 形式的线段交点 shadowBlur 延伸的阴影效果，该值为高斯模糊方程式中的参数值，非负、非无穷的 double 值，默认值为 0 shadowColor 阴影的颜色值 shadowOffsetX 阴影效果的水平方向偏移量 shadowOffsetY 阴影效果的垂直方向偏移量 strokeStyle 对路径描边时所使用的绘制风格 textAlign fillText() 或 strokeText() 方法绘制的时候，所画文本的水平对齐方式 textBaseline fillText() 或 strokeText() 方法绘制的时候，所画文本的垂直对齐方式 此外，还有两个重要的方法，用来保存及恢复当前 canvas 绘图环境的所有属性： 方法 描述 save() 将当前 canvas 的状态推送到一个保存 canvas 状态的堆栈顶部 restore() 将 canvas 状态堆栈顶部的条目弹出。原来保存于栈顶的哪一组状态，在弹出之后，就被设置成 canvas 当前的状态了","categories":[{"name":"前端","slug":"front-end","permalink":"https://haohaio.github.io/categories/front-end/"}],"tags":[{"name":"CSS","slug":"css","permalink":"https://haohaio.github.io/tags/css/"}]},{"title":"使用 WePY 开发微信小程序","slug":"使用wepy开发微信小程序","date":"2018-12-17T02:10:45.000Z","updated":"2020-04-09T07:21:56.816Z","comments":true,"path":"front-end/hello-wepy.html","link":"","permalink":"https://haohaio.github.io/front-end/hello-wepy.html","excerpt":"","text":"项目搭建# 全局安装 WePY 命令行工具$ npm install wepy-cli -g# 使用 WePY 命令行工具新建一个 hello-wepy 项目$ wepy init standard hello-wepy# 安装依赖 &amp;&amp; 运行项目$ cd hello-wepy &amp;&amp; npm install &amp;&amp; npm run dev 开发工具微信开发者工具下载 微信开发者工具，安装成功后添加项目根目录为一个新项目即可。 根目录下有一个项目配置文件 - project.config.json，其中一些配置对应着微信开发者工具中的一些配置，需要注意一下 &#123; \"description\": \"project description\", \"setting\": &#123; \"urlCheck\": true, \"es6\": false, \"postcss\": false, \"minified\": false &#125;, \"compileType\": \"miniprogram\", \"appid\": \"touristappid\", \"projectname\": \"Project name\", \"miniprogramRoot\": \"./dist\"&#125; urlCheck：对应不检查安全域名选项，开启。 如果已配置好安全域名则建议关闭。 es6：对应关闭ES6转ES5选项，关闭。(未关闭会运行报错) postcss：对应关闭上传代码时样式自动补全选项，关闭。(某些情况下漏掉此项也会运行报错) minified：对应关闭代码压缩上传选项，关闭。(开启后，会导致真机 computed, props.sync 等等属性失效) 添加项目成功后，微信开发者工具展示如下： 使用 VS Code 进行开发推荐使用 VS Code 进行开发，可通过如下步骤来设置语法高亮： 在 Code 里先安装 Vue 的语法高亮插件 Vetur。 打开任意 .wpy 文件，点击右下角的选择语言模式，默认为纯文本；在弹出的窗口中选择 .wpy 的配置文件关联，在选择要与 .wpy 关联的语言模式中选择 Vue。 在 VS Code 编辑器设置中设置 settings.json，添加如下： &quot;files.associations&quot;: { &quot;*.wpy&quot;: &quot;vue&quot; }","categories":[{"name":"前端","slug":"front-end","permalink":"https://haohaio.github.io/categories/front-end/"}],"tags":[{"name":"微信小程序","slug":"mp-wechat","permalink":"https://haohaio.github.io/tags/mp-wechat/"}]},{"title":"Spring 之 IoC 简介","slug":"Spring之IoC简介","date":"2018-12-16T02:38:15.000Z","updated":"2020-04-09T07:21:56.816Z","comments":true,"path":"back-end/spring-ioc.html","link":"","permalink":"https://haohaio.github.io/back-end/spring-ioc.html","excerpt":"","text":"IoC (Inversion of Control)，中文通常翻译为“控制反转”。 好莱坞原则 “Don’t call us, we will call you.” 恰如其分地表达了“反转”的意味，是用来形容 IoC 最多的一句话。 为什么需要 IoC ？一般情况下，如果我们依赖于某个类或服务，最简单而有效的方式就是直接在类的构造函数中新建相应的依赖类。即我们自己主动地去获取依赖的对象。但其实我们最终要做的只是想要调用依赖对象的某项服务而已。只要用到这个依赖对象的时候，它能够准备就绪，我们完全可以不管这个对象是自己找来的还是别人送过来的。不需要自己去折腾。 实际上，IoC 就是为了帮助我们避免之前的“大费周折”，而提供了更加轻松简洁的方式。 IoC 的反转，就反转在让你从原来的事必躬亲，转变为现在的享受服务。简单点儿说，IoC 的理念就是，让别人为你服务! 通常情况下，被注入对象会直接依赖于被依赖对象。但是，在IoC的场景中，二者之间通过 IoC Service Provider 来打交道，所有的被注入对象和依赖对象现在由IoC Service Provider统一管理。 被注入对象需要什么，直接跟 IoC Service Provider 招呼一声，后者就会把相应的被依赖对象注入到被注入对象中，从而达到 IoC Service Provider 为被注入对象服务的目的。 IoC Service Provider 在这里就是通常的 IoC 容器所充当的角色。 从被注入对象的角度看，与之前直接寻求依赖对象相比，依赖对象的取得方式发生了反转，控制也从被注入对象转到了 IoC Service Provider 那里。 依赖注入 (Dependency Injection)IoC 和 依赖注入 其实是同一个概念的不同角度描述。IoC 是通过依赖注入实现的。相对 IoC 而言，依赖注入明确描述了 被注入对象依赖 IoC 容器配置依赖对象。 依赖注入的主要目的是为了解耦，体现了一种“组合”的理念。组合优于继承。 Java 有一个重要特征是反射（reflection），它允许程序在运行的时候动态的生成对象、执行对象的方法、改变对象的属性，Spring 就是通过反射来实现注入的。 依赖注入主要有三种方式： 构造方法注入构造方法注入，就是被注入对象可以通过在其构造方法中声明依赖对象的参数列表， 让外部(通常是IoC容器)知道它需要哪些依赖对象。IoC Service Provider 会检查被注入对象的构造方法，取得它所需要的依赖对象列表，进而为其注入相应的对象。 优点：对象在构造完成之后，即已进入就绪状态，可以马上使用。 缺点：当依赖对象比较多的时候，构造方法的参数列表会比较长。而通过反 射构造对象的时候，对相同类型的参数的处理会比较困难，维护和使用上也比较麻烦。而且在 Java 中，构造方法无法被继承，无法设置默认值。对于非必须的依赖处理，可能需要引入多个构造方法，而参数数量的变动可能造成维护上的不便。 setter 方法注入当前对象只要为其依赖对象所对应的属性添加 setter 方法，就可以通过 setter 方法将相应的依赖对象设置到被注入对象中。 优点：因为方法可以命名，所以 setter 方法注入在描述性上要比构造方法注入好一些。另外，setter 方法可以被继承，允许设置默认值，而且有良好的IDE支持。 缺点：对象无法在构造完成后马上进入就绪状态。 接口注入接口注入比较死板和烦琐，如果需要注入依赖对象，被注入对象就必须声明和实现另外的接口。 接口注入是现在不甚提倡的一种方式。因为它强制被注入对象实现不必要的接口，带有侵入性。 参考 《Spring 揭秘》","categories":[{"name":"后端","slug":"back-end","permalink":"https://haohaio.github.io/categories/back-end/"}],"tags":[{"name":"Spring","slug":"spring","permalink":"https://haohaio.github.io/tags/spring/"}]},{"title":"Spring Boot 注解之@SpringBootApplication","slug":"SpringBoot注解之-SpringBootApplication","date":"2018-12-15T13:12:34.000Z","updated":"2020-04-09T07:21:57.067Z","comments":true,"path":"back-end/spring-boot-logging.html","link":"","permalink":"https://haohaio.github.io/back-end/spring-boot-logging.html","excerpt":"","text":"我们经常可以在 Spring Boot 的引导类中见到如下代码： @SpringBootApplicationpublic class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class, args); &#125;&#125; 下面我们就来了解一下 @SpringBootApplication 这个注解。我们进入该注解的源码后就会发现，其内部主要是由 @ComponentScan、 @SpringBootConfiguration、 @EnableAutoConfiguration 这三个注解组成。接下来我们就来了解一下这三个注解 @SpringBootConfiguration查看源码发现 @SpringBootConfiguration 被 @Configuration 标注，声明当前类是一个配置类，等价于配置文件。再查看 @Configuration 源码发现，@Configuration 由 @Component 标注，表示将当前类添加到 spring 容器中，表示是一个组件。 Java 配置Java 配置是通过 @Configuration 和 @Bean 来实现的 @Configuration：声明当前类是一个配置类，相当于一个 Spring 配置的 xml 文件 @Bean：注解在方法上，声明当前方法返回的是一个 Bean Java 配置和注解配置的主要原则是：全局配置使用 Java 配置 (如数据库的相关配置、MVC 相关配置)，业务 Bean 的配置使用注解配置 (@Service、@Component、@Repository、@Controller) @EnableAutoConfiguration查看源码发现，@EnableAutoConfiguration 主要由 @AutoConfigurationPackage 和 @Import({AutoConfigurationImportSelector.class}) 这两个注解构成。 @AutoConfigurationPackage 的作用是将引导类所在包及其子包下面所有的组件添加到 spring 容器中。 @Import({AutoConfigurationImportSelector.class}) 的作用是就导入自动配置类，即从 classpath 中搜索所有 META-INF/spring.factories 配置文件，然后将其中 org.springframework.boot.autoconfigure.EnableAutoConfiguration key 对应的配置项加载到 spring 容器中。 @ComponentScan被 @ComponentScan 标注的类，会被 spring 容器进行管理。 Spring 里有四大注解：@Component、@Controller、@Service 和 @Repository。四个注解是等效的，可根据需要选用。 @ComponentScan 注解就是用来自动扫描被这些注解标识的类，最终生成 IoC 容器里的 Bean。","categories":[{"name":"后端","slug":"back-end","permalink":"https://haohaio.github.io/categories/back-end/"}],"tags":[{"name":"Spring","slug":"spring","permalink":"https://haohaio.github.io/tags/spring/"}]},{"title":"Git 常用命令","slug":"Git常用命令","date":"2018-12-15T12:03:21.000Z","updated":"2020-04-09T07:21:57.095Z","comments":true,"path":"others/git-common-commands.html","link":"","permalink":"https://haohaio.github.io/others/git-common-commands.html","excerpt":"","text":"配置# 配置git的全局账号$ git config --global user.name \"username\"# 配置git的全局账号邮箱$ git config --global user.email \"email\"# 查看配置的结果$ git config --global -l 仓库# 新建本地仓库$ git init# 克隆远程仓库$ git clone url (gcl)# 查看所有远程仓库信息$ git remote -v (grv)# 添加远程仓库$ git remote add name url# 删除远程仓库$ git remote remove name 基本命令 git add # 提交所有Working Dir修改到Index$ git add .# 提交所有Working Dir中dir目录/file文件的修改到Index$ git add dir/file # \"git add .\" 和 \"git add -A\" 的区别?# stages new and modified, without deleted$ git add .# stages all$ git add -A (gaa) git commit # 提交所有Index修改到HEAD，并附上 commit message$ git commit -m (gcmsg)# 提交所有修改到HEAD(包含Working Dir和Index，但不包含new files)，并附上 commit message$ git commit -a -m (gcam)# 修订HEAD的修改$ git commit --amend git push # 提交本地仓库修改至Remote仓库的master分支$ git push origin master git reset # 从Index中恢复所有修改$ git reset# 恢复到HEAD的上一次提交$ git reset HEAD^(HEAD~1) git checkout # 撤销相应的文件修改$ git checkout file(dir)# 检出某一commit ID的修改$ git checkout d928a3 git clean # 删除untracked files$ git clean -f# 连 untracked 的目录也一起删掉$ git clean -fd# 查看哪些文件会被删除$ git clean -nfd git diff # 查看 Working Dir 与 Index 的区别$ git diff (gd)# 查看 Index 与 HEAD 的区别$ git diff –-cached (gdca)# 查看 Working Dir与 HEAD 的区别$ git diff HEAD git log # 显示 commit log$ git log# 显示代码差异$ git log -p# 概要显示$ git log --stat# 单行显示$ git log --pretty=oneline# 显示最近3条提交$ git log -3# 显示最近24h的提交$ git log --since=\"24 hours\"# 显示某file文件修改的记录$ git log file# 通过信息检索提交$ git log --grep=\"fixbug\"# 通过作者检索提交$ git log --author=\"yuanfang\" git reflog 会记录所有HEAD的历史，也就是说当你做 reset，checkout等操作的时候，这些操作会被记录在reflog中。 git fsck –lost-found 查看“丢失的”对象们，比如因reset而看不到的commit git show # 查看HEAD的所有代码改动$ git show# 查看某一commit ID的所有代码改动$ git show d928a3 git blame # 查看file文件每一行的最近一次修改的信息 $ git blame file# 查看file文件50行至60行的最近一次修改的信息$ git blame -L 50,60 file git stash # 将修改暂存入栈$ git stash# 恢复栈顶的修改$ git stash pop# 列出栈中所有修改$ git stash list# 列出栈中所有修改的代码详情$ git stash list -p# 恢复栈中指定修改$ git stash apply stash@&#123;1&#125;# 清空栈$ git stash clear# 删除栈中修改$ git stash drop stash@&#123;1&#125; 分支 git branch # 列出本地已经存在的分支$ git branch# 列出远程分支$ git branch -r# 列出本地分支和远程分支$ git branch -a# 创建新的分支new_branch$ git branch new_branch# 切换到分支new_branch$ git checkout new_branch# 删除分支new_branch$ git branch -d new_branch# 推送new_branch到Remote仓库$ git push origin new_branch# 删除Remote仓库new_branch$ git push origin :new_branch git merge &amp; git rebase &amp; git cherry-pick # 合并 master 到当前分支$ git merge master# 变基当前分支到 master$ git rebase master# 合并某个commit到当前分支$ git cherry-pick commit-id 标签# 列出本地已经存在的标签$ git tag# 创建新的标签new_tag$ git tag new_tag# 删除标签new_tag$ git tag -d new_tag # 推送new_tag到Remote仓库$ git push origin new_tag# 推送所有标签到Remote仓库$ git push origin --tags# 删除Remote仓库new_tag$ git push origin -d tag new_tag$ git push origin :refs/tags/new_tag# 获取Remote仓库所有的标签$ git fetch origin 补丁# 将修改写入到patch文件 .patch$ git diff &gt; .patch# 将.patch的修改恢复到当前git工程$ patch -p1 &lt; .patch .gitignore 配置规则 *.a # 忽略所有 .a 结尾的文件!lib.a # 但 lib.a 除外/TODO # 仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODObuild/ # 忽略 build/ 目录下的所有文件doc/*.txt # 会忽略 doc/notes.txt 但不包括 doc/server/arch.txt .gitignore文件发现却没有生效时（ .gitignore只能忽略那些原来没有被track的文件） $ git rm -r --cached .$ git add .$ git commit -m 'update .gitignore' 统计某人提交代码的次数 $ git log --pretty=oneline --author='username' | wc -l","categories":[{"name":"其它","slug":"others","permalink":"https://haohaio.github.io/categories/others/"}],"tags":[{"name":"Git","slug":"git","permalink":"https://haohaio.github.io/tags/git/"}]},{"title":"Canvas学习笔记一：初识Canvas","slug":"初识Canvas","date":"2018-12-13T11:51:53.000Z","updated":"2020-04-09T07:21:56.380Z","comments":true,"path":"front-end/canvas-1.html","link":"","permalink":"https://haohaio.github.io/front-end/canvas-1.html","excerpt":"","text":"简介canvas 元素可以说是 HTML5 元素中功能最强大的一个。我们可以通过 canvas 元素来绘制图像，不过 canvas 本身并没有绘制能力，必须通过js脚本来完成实际的绘制任务。canvas的能力主要是通过 canvas 的 context 对象表现出来的，该对象提供了用于在画布上绘图的方法和属性。 可以先看一个简单的 demo Hello Canvas，来简单了解一下canvas。 context 对象的获取var canvas = getElementById('canvas');// '2d' 中的 'd' 必须小写var context = canvas.getContext('2d'); canvas 的 “后备内容” (fallback content) IE8 以及更早的版本不支持 canvas 元素。 当浏览器不支持 canvas 元素时，canvas 元素内部部分所含的文本就会显示出来，这种文本叫做“后备内容” (fallback content)。 &lt;canvas&gt; Canvas not supported&lt;/canvas&gt; 另外我们可以通过简单的 js 代码来检查浏览器对 canvas 的支持性： var canvas = document.getElementById('canvas');if (canvas.getContext) &#123; var ctx = canvas.getContext('2d'); // drawing code here&#125; else &#123; // canvas-unsupported code here&#125; canvas 的尺寸默认的canvas元素大小是 300 * 150 个像素。 我们可以通过指定 width 和 height 属性值来修改 canvas 元素的大小。 &lt;canvas id=\"canvas\" width=\"600\" height=\"300\"&gt; 在设置 canvas 的宽度和高度时，不能使用 px 后缀。虽说支持 canvas 的浏览器普遍都允许使用 px 后缀，但是这是不被 canvas 规范所接受的。根据规范，这些属性的取值，只能是非负整数。 canvas 元素的大小和绘图表面的大小我们还可以通过 CSS 属性来改变 canvas 元素的大小。 #canvas &#123; width: 600px; height: 300px;&#125; 不过通过 CSS 设置 canvas 元素的大小，与通过 width、height 属性值设定，效果并不一样。 其根本原因是因为 canvas 元素实际上有两套尺寸。一个是元素本身的大小，还有一个是元素绘图表面（drawing surface）的大小。 当设置元素的 width 和 height 属性时，实际上是同时修改了元素本身的大小和元素绘图表面的大小。然而，通过 CSS 来设定 canvas 元素的大小时，只会改变元素本身的大小，而不会影响到绘图表面。当 canvas 元素的大小不符合起绘图表面的大小时，浏览器就会对绘图表面进行缩放，使其符合元素的大小。具体效果如如下面两幅图所示： 通过设置元素的 width 和 height 属性修改 canvas 元素大小的效果 通过 CSS 来设定 canvas 元素的大小的效果 （浏览器自动缩放） 所以一般情况下我们都是通过 width 与 height 属性而非 CSS 来修改 canvas 元素的大小。 canvas 元素的 APIcanvas 元素只提供了2个属性与3个方法。 canvas元素的属性 属性 类型 默认值 width 非负整数 300 height 非负整数 150 canvas元素的方法 方法 描述 getContext() 返回与该 canvas 元素相关的绘图环境对象。 toDataURL(type, encoderOptions) 返回一个数据地址（data URL），可将其设定为 img 元素的 src 属性值。第一个参数指定了图像的类型，例如 image/jpeg 或 image/png，默认为 image/png。第二个参数在指定图片格式为 image/jpeg 或 image/webp的情况下, 可设定为 0 ~ 1.0 之间的 double 值，表示 JPEG 图像的显示质量，如果超出取值范围，将会使用默认值 0.92。 toBlob(callback, type, encoderOptions) 创建一个用于表示次canvas 元素图像文件的 Blob。第一个参数是一个回调函数，并传入一个 blob 对象作为参数，第二个参数为图像类型，最后一个参数为 JPEG 图像的显示质量","categories":[{"name":"前端","slug":"front-end","permalink":"https://haohaio.github.io/categories/front-end/"}],"tags":[{"name":"CSS","slug":"css","permalink":"https://haohaio.github.io/tags/css/"}]},{"title":"Web动画之animation","slug":"Web动画之animation","date":"2018-12-12T01:40:21.000Z","updated":"2020-04-09T07:21:56.628Z","comments":true,"path":"front-end/web-animation-animation.html","link":"","permalink":"https://haohaio.github.io/front-end/web-animation-animation.html","excerpt":"","text":"在 Web动画之transition 中我们可以了解到 transition 可以把一系列属性从一个状态变到另一个状态。CSS动画还提供了一种创建动画的方式，而且功能更加丰富。animation 能把一系列属性从一个状态变到另一个状态，再变到第三个状态，然后一直这么变下去。此外，还能重播动画，鼠标移到动画上时停止动画，甚至在动画结束时还能倒播动画。接下来我们就来了解一下 animation。 animation 比 transition 复杂一些，不过有个额外的好处：无需触发就能开始动画。 Animation 简介 与 transition 一样，IE9 及之前的版本也不支持 animation。 创建 animation 的过程主要分成以下两步： 定义动画即设置 keyframe (关键帧, 指展示画面的一帧)，列出要变化的CSS属性。基本结构如下： @keyframes animationName &#123; from &#123; /* 在这里列出CSS属性 */ &#125; to &#123; /* 在这里列出CSS属性 */ &#125;&#125; keyframes 不是CSS属性，而是@规则。此外，CSS还有几个@规则：在样式表中加载另外一个样式表的 @import 语句；为不同媒介类型定义样式的 @media。 首先在 @keyframes 后面定义一个名称，即动画的名称 (e.g. fadeIn、fadeOut)。 然后至少添加两个关键帧。在上面的示例中，关键字 from 用于创建起始关键帧，关键字 to 用于创建结束关键帧。在每个关键帧中可以添加一个或多个CSS属性，与定义样式一样。例如： fadeIn 不仅只能定义两个关键帧，还可以用百分比值定义多个关键帧。百分比表示在整个动画过程的什么位置发生变化。 例如：growAndGlow 百分比值的用法还有个特别的技巧：使用不同的百分比值定义相同的CSS属性。首先，当动画播放到摸一会时刻时暂停，然后再继续 (e.g. glow)。还可以用来不同时间段使用相同的CSS属性(e.g. glow) 可以把关键字 form 换成 0%，把关键字 to 换成 100%。 应用动画定义好动画后，若想播放动画，还需将动画应用到页面的元素上。 直接将动画加到动画的样式中，则动画在页面加载时就会播放(上面的例子都是如此)。 此外，可以把动画添加到某个伪类中 (e.g. :hover、:active、:target或:focus)，还可以把动画添加到类样式中，在需要的时候使用js动态应用那个类样式。 CSS提供了几个 animation 相关的属性，用于控制如何以及何时播放动画。 有些属性与 transition 基本相同，这里不做过多解释 animation-name 以CSS关键字做动画名称时，放在引号里能避免冲突 可以对应多个动画的名称，来让一个元素应用多个动画 animation-duration animation-timing-function 可以为每个关键帧设置不同的时序函数 animation-dealy animation-iteration-count (动画运行次数)(e.g. animation-iteration-count: 10;) 设为关键字 infinite 时，可无限次运行动画 animation-direction 当动画多次执行时，如有需要，可设为 alternate 关键字，动画会在奇数时正向播放，偶数时反向播放。 animation-fill-mode 可设为 forwords 关键字，当动画结束时让元素显示成动画结束后的样子。 animation属性的简写形式 名字和持续时间是必写的。 多个动画时，可用逗号分开。 暂停动画若有需要可使用伪类或js设置 animation-play-state (running|paused) 属性为 paused 来暂停动画。 推荐推荐一个CSS animation库 animate.css，这个库封装了很多动画，拿来即用，非常方便。","categories":[{"name":"前端","slug":"front-end","permalink":"https://haohaio.github.io/categories/front-end/"}],"tags":[{"name":"CSS","slug":"css","permalink":"https://haohaio.github.io/tags/css/"}]},{"title":"Web动画之transition","slug":"Web动画之transition","date":"2018-12-09T06:28:26.000Z","updated":"2020-04-09T07:21:56.368Z","comments":true,"path":"front-end/web-animation-transition.html","link":"","permalink":"https://haohaio.github.io/front-end/web-animation-transition.html","excerpt":"","text":"目前Web动画主要有两大实现途径： CSS3动画。这类动画是当前页面动画的主力军，主要通过 transition 和 animation 两种方式来实现。 transition (过渡) 一种简单的动画，在一定时间内从一组CSS\b属性变成另一组属性。 animation 是关键帧动画，可以预先为动画设置多个节点，在每个节点中含有不同的状态属性，通过使用 animation 我们可以得到更为复杂的动画效果。 JavaScript动画。这类动画是通过JavaScript来动态的控制并刷新元素的各个属性值，以形成动画效果。 除以上两者外，我们也可以使用SVG 或 canvas等来制作动画。 一般来说，大部分简单的动画都可以使用 transition 实现。JavaScript动画则往往用于更加复杂，或是需要结合各类用户交互操作的动画效果。在运行效率方面，像jQuery这种JavaScript类库的动画效果要低于CSS3动画。而在兼容性方面，CSS3动画的兼容性要差于jQuery等类库动画，前者并不支持IE9之前的浏览器。今天就先了解一下 transition 动画。 Transition简介一种简单的动画，在一定时间内从一组CSS\b属性变成另一组属性。 IE只有10和以后的版本才支持transition 为了实现过渡效果，要满足以下几个条件： 两个样式 (过渡前的样式和过渡\b后的样式) transition\b属性 (\b\b添加到初始样式中) 触发器 (指促使元素在两个在两个元素之间变化的操作。在CSS中可以使用伪类触发动画 (e.g. :hover、:active、:target或:focus)，还可以使用js触发 (增删类或者修改属性)) transition 的四个属性 transition-property (指定需要变化的属性，\b可用关键字all表示所有属性) transition-property: color, background-color;transition-property: all; transition-duration (动画持续时间) transition-duration: .5s;transition-duration: 500ms; transition-timing-function (过渡的时序，即持续过程的速率) linear (中间快，两头慢) ease (\b开始时慢，中间加速，\b末尾又降速)default ease-in \b(开始时慢，之后快) ease-out \b(开始时快，结束时候慢) ease-in-out (两头慢) 可通过演示具体比较一下\b\b各个速率的区别 演示地址 transition-delay (动画\b延时时间) transition属性的简写形式 要变化的属性和动画的持续时间是必写的。默认情况下，时序函数是ease，而且没有延迟。 多个要变化的属性时，可用逗号分开。 transition: all 1s;transition: background-color 1s, color .5s, border-color .5s 1s; 附上一个综合版的Demo transition demo 让动画更流畅以动画形式改变多个属性会增加Web浏览器的负担。一次有太多动画可能导致浏览器假死，甚至是崩溃。尤其是移动设备和平板电脑，因为这些设备的CPU比桌面电脑和笔记本电脑慢很多。 不过，有4种变化导致浏览器使用太多CPU：opacity，以及transform属性的translate、scale和rotate函数。这四个属性处理起来比其它CSS属性省事，所以它们的动画效果更流畅。 此外，还可以强制让电脑的GPU (Graphic Processing Unit, 图形处理器) 渲染动画。GPU的运算速度特别快，与电脑的CPU相比，执行特定类型的计算速度快得多。我们可以在样式中添加3D变形属性，以此“骗过”浏览器，让它使用GPU处理样式变化。但是因为GPU的处理能力有限，如果把太多视觉效果交给它处理，可能会拖慢浏览器，导致假死。","categories":[{"name":"前端","slug":"front-end","permalink":"https://haohaio.github.io/categories/front-end/"}],"tags":[{"name":"CSS","slug":"css","permalink":"https://haohaio.github.io/tags/css/"}]}]}